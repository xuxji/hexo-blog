<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

<!-- generator="WordPress/3.9.14" created="2016-12-24 04:10" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>Bugalot</title>
	<link>http://localhost:81/wordpress</link>
	<description>又一个WordPress站点</description>
	<pubDate>Sat, 24 Dec 2016 04:10:24 +0000</pubDate>
	<language>zh-CN</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://localhost:81/wordpress</wp:base_site_url>
	<wp:base_blog_url>http://localhost:81/wordpress</wp:base_blog_url>

	<wp:author><wp:author_id>1</wp:author_id><wp:author_login>xuxji</wp:author_login><wp:author_email>xuxji.123@163.com</wp:author_email><wp:author_display_name><![CDATA[xuxji]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>


	<generator>http://wordpress.org/?v=3.9.14</generator>

	<item>
				<title>移动互联网产品设计</title>
		<link>http://localhost:81/wordpress/?p=51</link>
		<pubDate>Tue, 01 Jul 2014 08:25:26 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=51</guid>
		<description></description>
		<content:encoded><![CDATA[<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;"><span style="word-wrap: break-word;">二、移动互联网产品的方法论</span></strong></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">手机作为一种联系工具，天然决定了移动互联网的主要服务对象是人群而非个人。移动互联网产品经理的主要任务是服务人群，主要工作是研究人类群落的行为模式。用产品为人群提供服务，并且要预判人群卷入之后行为模式的变化。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">从方法论的角度思考，人类群落也处于演进过程中。早期人类是村落人群模式，村落中的每个人认识每个人，人际关系以非常实际的亲戚关系和职业关系为纽带。现代人类是社会化人群模式，人群数目极大增长，人际关系依托于抽象的社会生产关系：契约、合同、雇佣关系……产品经理曾经是村落里的铁匠，他认识每个村民，每个村民也认识他。而在今天，产品经理完全退居幕后，他不可能认识每一个用户，用户甚至不知道这个人的存在。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">因此，产品经理在方法论上存在着各种选择：他可以提供某种基于熟人群落的旧式服务，以增进熟人群落的情感为产品目的；他也可以提供某种基于大数人群的新式基础服务，以便于人们彼此认识，协调工作，从自利为基础的无序活动中自组织处有序活动；或者，他也可以提供某种中间类型的产品，帮助人们平滑度过两种人群模式，减少由于变化而产生的阵痛。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">但是，产品经理的主流应该是服务于未来。先于人众接触新技术新知识，并把这种认知转化为产品，利用产品提供现代人类社会中的各种人群。尽一切可能，降低学习成本，利用人类的本能设计产品，使得人群得以顺利“滑入”新的产品使用场景。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">在所有这一切之上，产品经理的目标应该是实现社会美和善和总量。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;"><span style="word-wrap: break-word;">三、移动互联网产品经理的素养</span></strong></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;">1、敏锐感知潮流变化。</strong>移动互联网产品会从相对匮乏时代进入相对富足时代，用户可以选择的产品会随时日流逝而日渐增加，产品终将成为一种时尚业。产品经理若是沉溺于各种新鲜玩意儿之中，追逐新奇，很可能错过真实的时代潮流，无法把握人群的真实需求。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;">2、放弃理性思维。</strong>移动互联网的最大特点是变化极快，传统的分析用户，调研市场，制定产品三年规划，在新的时代里已经落伍。人类群落本身也在迁移演变，产品经理更应该依靠直觉和感性，而非图表和分析，把握用户需求。产品经理永远都应该是文艺青年，而非理性青年。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;">3、海量的实践。</strong>尽管移动互联网方兴未艾，没有任何人可以自称是领域内的专家。但是，这不意味着存在天降天才的可能。《异类》中提出的一万小时定律，同样适用于产品经理。他们需要超过千次的产品实践，才能称得上是了解产品设计，拥有解决问题的能力。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;">4、博而不专的积累。</strong>美术、音乐、阅读、摄影、旅游等等文艺行为貌似不能直接转化为生产力，但是合格的产品经理需要广博的知识储备，以此才能了解和认识大数量的人群，理解时代的审美，让自己的所思所感符合普通用户的思维范式。以此为基础，设计的产品才不会脱离人群。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;">5、负责的态度。</strong>拥有合适的方法论和合适的素养，成功的产品经理还应该有对自己和产品负责的态度，唯其如此，产品经理才能足够偏执，清楚地知道自己究竟要做什么，抵挡住来自上级和绩效考核的压力，按照自己的意志不变形、不妥协地执行产品策划。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;"><span style="word-wrap: break-word;">四、移动互联网产品设计的原则</span></strong></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">1、绝不考虑Web形态，一切考虑都基于APP。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">2、产品优先级：</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">①有趣高于功能，产品必须有趣，必须Cool，才可能形成传播和口碑。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">②功能高于交互，明确的功能满足明确的需求，用户不会在意炫酷交互效果。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">③交互高于UI。便捷、快速的交互设计为先，围绕具体功能实现UI，而非有优质UI方案为此专门设立一个功能。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">3、聚焦：一个APP只做一件事情，一个大而全的APP意味着全面的平庸。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">4、永远一维化：让用户在一个维度里解决具体的问题，Twitter的Timeline就是一个好的范例。而类似Facebook、Path那样的滑出式菜单则是一个灾难，因为这使得产品拥有两个维度，加大了用户理解的困难。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">5、保持主干清晰，枝干适度。产品的主要功能架构是产品的骨骼，它应该尽量保持简单、明了，不可以轻易变更，让用户无所适从。次要功能丰富主干，不可以喧宾夺主，尽量隐藏起来，而不要放在一级页面。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">6、不要让用户选择。同一个页面之内，有多个入口；同一个功能，有多个实现方式；同一个界面，有多个展示方式。这对于用户来说是一种痛苦而非享受，因为他们只会因此而感觉到困惑和恐惧。用户宁可采取重复操作漫长而固定的操作路径，也不愿意使用多变的快捷方式。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">7、隐藏技术，永远展现简单的、人性化的、符合人类直觉的界面。开发不可以为了炫技而展示功能，产品不可以为了炫耀而功能堆砌。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">8、拒绝个性化。除了依靠设计特色而立身的APP，换肤一类的个性化设计，除了让产品经理幻觉自己做了许多工作而自我满足之外，没有任何价值。它只能证明产品经理对自己的产品不自信，因为自信的产品经理凭借默认皮肤就可以满足用户。延伸开去，一个好的产品，其功能应该满足全球用户需求，无需为地区做特别定制化。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">9、产品一定程度上是为了满足人性中的贪嗔痴，这是用户的痛点。能把握住之后，产品经理应该超越其上，用产品帮助人们得以解脱。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">10、想清楚自己究竟要做什么，不去迎合上司，不去讨好用户，不去取悦自己。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">11、分类！分类！分类！这是产品经理在确定产品主要功能构架之后，唯一应该为用户做的事情。分类无助于降低产品使用的难度，但是可以帮助用户认知产品和周边的世界。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">12、永远围绕功能而做设计，永远不要倒过来做这件事情。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">13、一个产品的基本功能不受用户认可，做加法也无济于事。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">14、想不清楚一个功能点之前，宁可不做。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">15、千万不要让用户在产品里“管理”什么。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"><strong style="word-wrap: break-word;"><span style="word-wrap: break-word;">五、“自然流”的设计思路</span></strong></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">好的产品应该隐藏产品经理的个人意图，用户仅仅凭借直觉和经验就可以顺利使用，以达到“自然而然”的境界。坏的产品提供产品说明书，其恶劣程度和Tip和文字说明数量正相关。为此，好的产品经理可以和用户之间平等对话，无需刻意谄媚、恶意卖萌，产品本身就会说话。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">自然流的产品，它本身就可以可用户交流。针对用户的任意一个动作，给出唯一的、清晰的反馈，并且能让用户没有任何偏差地接受。它没有人造物的冰冷生硬，而有一种温暖的人性存在。例如在IOS中微信朋友圈里的评论按钮，按下之后弹出“赞”和“评论”弹窗。这一弹窗快速向左滑动，然后像碰到什么东西一样快速向右反弹一个很小的距离，然后才最终停下来。用户可能根本未能意识到这一微小的停顿，但是在潜意识里，他们会感受到这个弹窗并非全然的人造物。因为根据生活经验，世界上没有任何东西可以从运动直接变到绝对静止。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">绝对不要让用户在使用产品的过程中感受到产品经理的伟大和聪慧，产品经理应该完全隐没在产品之中。用户应该可以不假思索地上手，按照设计意图行事，从中获得既定的正向反馈。这一切应该自然而然地发生，用户感觉似乎产品天生就应该这样使用，从产品还未出现之前很久就应该如此。好的产品不会强调自己存在于世界之上，它只是努力地、毫无痕迹地成为这个世界的一部分。</div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;"></div>
<div style="color: #333333; font-family: Arial; font-size: 14px; line-height: 26px;">做自然流的产品，必然会在美学上倾向于简单，反逻辑。产品经理必然的选择是做减法，在诸多功能中选取最能解决实际问题的一个，在诸多特性中选取最符合直觉的一项，于是产品也就拥有了优雅和简洁，让人难以忘怀。极简和极自然，使得模仿无法存在，因为没有人可以造出更好的体验来。</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>51</wp:post_id>
		<wp:post_date>2014-07-01 16:25:26</wp:post_date>
		<wp:post_date_gmt>2014-07-01 08:25:26</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%a7%bb%e5%8a%a8%e4%ba%92%e8%81%94%e7%bd%91%e4%ba%a7%e5%93%81%e8%ae%be%e8%ae%a1</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="product"><![CDATA[Product]]></category>
		<category domain="post_tag" nicename="%e4%ba%a7%e5%93%81"><![CDATA[产品]]></category>
		<category domain="post_tag" nicename="%e7%a7%bb%e5%8a%a8%e4%ba%92%e8%81%94%e7%bd%91"><![CDATA[移动互联网]]></category>
	</item>
	<item>
				<title>Oracle EBS WMS功能介绍（一）</title>
		<link>http://localhost:81/wordpress/?p=64</link>
		<pubDate>Tue, 01 Jul 2014 09:07:33 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=64</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="color: #000000;">Oracle EBS WMS功能介绍（一）</p>
<p style="color: #000000;">Oracle WMS是仓储管理，是Oracle 高级供应链和制造解决方案中的一个组件，不完全等同于库存（Oracle Inventory)，因为它支持高度自动化的手持扫描枪和物料处理系统；且极大的扩展了现有EBS的功能，并提供了包括仓存资源管理，仓储配置，生产率，性能分析，任务计划，高级拣货方法和附加值服务。所以WMS中的大部分操作是通过扫描枪来进行的。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">要使用WMS的一个重要前提就是必须使用下面三个模块，因为它高度依赖和扩展了现有的Oracle 生产应用的功能。</p>
<p style="color: #000000;">l  Oracle Inventory(库存)</p>
<p style="color: #000000;">l  Oracle Purchasing[Receiving](采购，主要是其中的收货功能)</p>
<p style="color: #000000;">l  Oracle Order Manager[Shipping](订单管理，主要是其中的发运功能)</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">Oracle WMS主要提供了下面几种功能</p>
<p style="color: #000000;">l  任务（Task）管理</p>
<p style="color: #000000;">l  使用LPNs(LicensePlate Numbers)来跟踪物料</p>
<p style="color: #000000;">l  用户可配置的规则引擎，使你可以使用拣货规则，存储规则和承诺标签来自定义你的仓储。</p>
<p style="color: #000000;">l  高级库存和物料管理，包括物料状态，批次和序列号支持等等。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>存储概览</strong></p>
<p style="color: #000000;">仓库是一种拥有很多功能的设施。主要的，仓库包含下面的功能：</p>
<p style="color: #000000;">l  从一个来源接收货物（内部的或者外部的来源）</p>
<p style="color: #000000;">l  存储货物</p>
<p style="color: #000000;">l  拣货</p>
<p style="color: #000000;">l  进行附加值服务</p>
<p style="color: #000000;">l  发运货物</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">仓库有很多优点，主要包括以下</p>
<p style="color: #000000;">l  供应和需求的协调</p>
<p style="color: #000000;">l  在生产进程中帮助存储生产组件和完工产品</p>
<p style="color: #000000;">l  Kitting,打包，标签和aging服务</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">一个仓库是有几样东西所组成的，包括</p>
<p style="color: #000000;">l  人员</p>
<p style="color: #000000;">l  发货区</p>
<p style="color: #000000;">l  收货区</p>
<p style="color: #000000;">l  物料处理设备</p>
<p style="color: #000000;">l  处理区</p>
<p style="color: #000000;">l  库存</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">仓库有很多的布局和设计规范，一些通用的原则包括：</p>
<p style="color: #000000;">l  Use one story facilities if possible</p>
<p style="color: #000000;">l  在直线上移动货物</p>
<p style="color: #000000;">l  可能的话利用最有效的物料处理设备</p>
<p style="color: #000000;">l  最小化过道空间</p>
<p style="color: #000000;">l  完全利用建筑的高度</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>仓储管理的功能</strong></p>
<p style="color: #000000;">仓储管理的功能主要包括</p>
<p style="color: #000000;">l  进货物流</p>
<p style="color: #000000;">l  出货物流</p>
<p style="color: #000000;">l  存储和设施管理</p>
<p style="color: #000000;">l  逆向物流</p>
<p style="color: #000000;">l  附加值服务</p>
<p style="color: #000000;">l  规则和规则引擎</p>
<p style="color: #000000;">l  LPNs(License Plate Number)</p>
<p style="color: #000000;">l  物料状态</p>
<p style="color: #000000;">l  控制面板</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>进货物流逻辑主要包括</strong></p>
<p style="color: #000000;">1.      收货，Oracle 采购模块中的三种标准收货模式在Oracle WMS中都可以使用。包括，标准收货，直接收货和检验收货。WMS同样处理RMA, ISO和IOT的收货类型。</p>
<p style="color: #000000;">2.      质量检验，收货物料的检验是基于供应商，产品或者一个组织层上的默认值。</p>
<p style="color: #000000;">3.      标签打印，可以根据需要打印产品和包装标签。</p>
<p style="color: #000000;">4.      直接入库和存储优化，为仓管人员提供一个可用的存储位置进行存放，这可以通过匹配物料处理限制和使用物料/库存的实时信息来实现。</p>
<p style="color: #000000;">5.      越库（cross docking）,在收货时，通过检查延期交货的销售订单来重定向收入的货物。如果必要的话，系统或自动把产品从收货码头导向到staging lane或者发运码头而没有把物品放到存货位置。</p>
<p style="color: #000000;">（转载原文：http://blog.csdn.net/tavor/article/details/30849953）</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>64</wp:post_id>
		<wp:post_date>2014-07-01 17:07:33</wp:post_date>
		<wp:post_date_gmt>2014-07-01 09:07:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-ebs-wms%e5%8a%9f%e8%83%bd%e4%bb%8b%e7%bb%8d%ef%bc%88%e4%b8%80%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>Oracle EBS WMS LPN(License Plate Number)</title>
		<link>http://localhost:81/wordpress/?p=66</link>
		<pubDate>Tue, 01 Jul 2014 09:30:24 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=66</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">LPN(License Plate Number) is an object carries the location where it is residing and items that are holding.<span style="text-decoration: underline;"> LPN need <strong>not </strong>be a physical object, it could be logical grouping.</span> LPN simpley a group of items represented systematically. <span style="text-decoration: underline;">The major advantage of LPN is less number of transactions. Entire LPN can be transacted at once instead of by each line that LPN holds.</span></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><span style="text-decoration: underline;">In a word,A LPN allows you to logically group items together that physically travel together on the floor.</span></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">
All material received through Oracle Warehouse Management is associated with a unique LPN.
<span style="text-decoration: underline;">This enables material to easily be tracked and transacted throughout your warehouse without scanning the item, quantities, lots or serial numbers.</span>(There is a good example,see <a style="color: rgb(255, 153, 0); text-decoration: none;" href="https://forums.oracle.com/forums/thread.jspa?threadID=2141912" target="_blank">here</a>)<span style="text-decoration: underline;">
</span></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><img style="border: none; max-width: 100%;" src="http://www.oracleug.com/sites/default/files/users/oracleug/wms002.PNG" alt="" /></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>A Corresponding Concept</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">Packed Items(LPN) &lt;--&gt; Loose Material(Non-LPN)</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">In Oracle Mobile,All transactions can be for either loose material or LPN triggered.
LPN triggered transactions require less data entry because an LPN has its current subinventory, location, and item contents all associated with a single identifier.
The benefit of an LPN triggered transaction is greater when it contains serial controlled items because the amount of data entry is greater.</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>Using LPNs</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">Oracle Warehouse Management enables you to track, transact, and nest LPNs.</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>

<ol style="color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">
	<li>Store information about an LPN such as item, revision, lot, serial, organization, subinventory, or locator</li>
	<li>Track contents of any container in receiving, inventory, or in-transit</li>
	<li>Receive, store, and pick material by LPN</li>
	<li>View on hand balances by LPN</li>
	<li>Move multiple items in a transaction by LPN</li>
	<li>Transfer LPN contents</li>
	<li>Pack, unpack, consolidate, split, and update LPNs</li>
	<li>Print labels and reports for referencing container contents</li>
	<li>Track nested LPNs Oracle Internal &amp; OAI Use OnlyOracle Only</li>
	<li>Reuse empty LPNs</li>
	<li>Receive and send LPN information on an ASN</li>
</ol>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>Nesting License Plate Numbers</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><img style="border: none; max-width: 100%;" src="http://www.oracleug.com/sites/default/files/users/oracleug/wms003.PNG" alt="" /></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">Oracle Warehouse Management enables you to nest LPNs.</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">For example, pallet LPN P5555 contains three nested LPNs: LPN P5552, LPN P5553, and LPN P5554. In the system, you would see LPN P5555 as the top-level LPN, and each of the of the three box LPNs would fall under LPN P5555.</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">You can nest LPNs within other LPNs. In the above example, item A is packed in LPN 2, and LPN1, LPN2, and LPN3 are nested within LPN4. When you transact LPN4, all of the LPNs nested within it are transacted.</p>
&nbsp;
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>LPN Transactions</strong>(<a style="color: rgb(255, 153, 0); text-decoration: none;" href="http://docs.oracle.com/cd/E18727_01/doc.121/e13434/T210618T210923.htm#T210984" target="_blank">refer</a>)</p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">LPN transactions allow movement of material in to and out of LPNs and enable you to manually create nested LPNs. The available LPN Transactions are as follows:</p>

<ul style="color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">
	<li>
<p style="margin: 0px; padding: 0px;">Pack transaction- The Pack transaction enables you to pack loose material into an LPN.</p>
</li>
	<li>
<p style="margin: 0px; padding: 0px;">Consolidate transaction- The Consolidate transaction enables you to nest a child LPN inside a parent LPN.</p>
</li>
	<li>
<p style="margin: 0px; padding: 0px;">Unpack transaction- The Unpack transaction enables you to unpack either material or a nested LPN from a parent LPN.</p>
</li>
	<li>
<p style="margin: 0px; padding: 0px;">Split transaction- The Split transaction is essentially an Unpack and Pack combined together, creating a new LPN with some material from another LPN.</p>
</li>
	<li>
<p style="margin: 0px; padding: 0px;">Update LPN transaction- The Update LPN transaction enables you to update the weight, volume, and container item of an LPN. As in all other transactions, LPN transactions of lot, serial, or revision controlled material requires you to enter the item controls.</p>
</li>
</ul>
&nbsp;
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>Relationship between Some LPN Related Tables</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><img style="border: none; max-width: 100%;" src="http://img.my.csdn.net/uploads/201302/21/1361431893_3273.png" alt="" /></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"><strong>Meaning of LPN Context Code(<a style="color: rgb(255, 153, 0); text-decoration: none;" href="http://docs.oracle.com/cd/E18727_01/doc.121/e13434/T210618T211428.htm" target="_blank">refer</a>)</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">Oracle Warehouse Management system (WMS) defines a context for each LPN to denote the current state of the LPN. Some of these contexts can be used in the WMS Rules Engine to define specialized picking and put away rules. <strong>
</strong></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>

<table style="color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;" border="1" summary="table is summarized in text" cellspacing="0" cellpadding="4">
<tbody>
<tr class="HEADER" valign="CENTER" bgcolor="#E0E0E0">
<th scope="col"><strong>LPN Context Value</strong></th>
<th scope="col"><strong>Description</strong></th>
</tr>
<tr valign="TOP">
<td>1</td>
<td>Resides in Inventory</td>
</tr>
<tr valign="TOP">
<td>2</td>
<td>Resides in WIP</td>
</tr>
<tr valign="TOP">
<td>3</td>
<td>Resides in Receiving</td>
</tr>
<tr valign="TOP">
<td>4</td>
<td>Resides in Stores</td>
</tr>
<tr valign="TOP">
<td>5</td>
<td>Pre-generated</td>
</tr>
<tr valign="TOP">
<td>6</td>
<td>Resides in Intransit</td>
</tr>
<tr valign="TOP">
<td>7</td>
<td>Resides in Vendor Site</td>
</tr>
<tr valign="TOP">
<td>8</td>
<td>Packing context, used as a temporary context value</td>
</tr>
<tr valign="TOP">
<td>9</td>
<td>Loaded for shipment</td>
</tr>
<tr valign="TOP">
<td>10</td>
<td>Prepack of WIP</td>
</tr>
<tr valign="TOP">
<td>11</td>
<td>Picked</td>
</tr>
</tbody>
</table>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">Reference: <a style="color: rgb(255, 153, 0); text-decoration: none;" href="http://www.oracleug.com/user-guide/warehouse-management/license-plate-numbers-lpns" target="_blank">http://www.oracleug.com/user-guide/warehouse-management/license-plate-numbers-lpns</a></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;"></p>
<p style="margin: 0px; padding: 0px; color: rgb(0, 0, 0); font-family: Arial; font-size: 14px; line-height: 26px;">转载原文：http://blog.csdn.net/pan_tian/article/details/8598798</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>66</wp:post_id>
		<wp:post_date>2014-07-01 17:30:24</wp:post_date>
		<wp:post_date_gmt>2014-07-01 09:30:24</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-ebs-wms-lpnlicense-plate-number</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="post_tag" nicename="lpn"><![CDATA[LPN]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>Oracle EBS WMS功能介绍（二）</title>
		<link>http://localhost:81/wordpress/?p=70</link>
		<pubDate>Tue, 01 Jul 2014 09:28:17 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=70</guid>
		<description></description>
		<content:encoded><![CDATA[Oracle EBS WMS功能介绍（二）
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>出货物流逻辑主要包括</strong></p>
<p style="color: #000000;">1.      打包，可以进行多层嵌套式的打包，并通知用户为订单所做的特殊打包方法。打包可以在拣货时做，也可以作为一个独立的操作来做。</p>
<p style="color: #000000;">2.      为行程进行码头预约，可以使仓库经理计划出库运输公司的预约，码头门的可用性和仓库内的待装区的使用。</p>
<p style="color: #000000;">3.      拣货方法，为不同订单的拣货需要选择不同的拣货方法。</p>
<p style="color: #000000;">4.      管理拣货，可以使订单基于移动手持应用拣货或者基于纸质拣货单进行拣货</p>
<p style="color: #000000;">5.      Cantonization, 在履行订单的过程中，选择需要的合适数量和大小的容器。</p>
<p style="color: #000000;">6.      标准标签，使用你建立的标准标签来打印特定的标签</p>
<p style="color: #000000;">7.      发运阶段/联合和装货，可以合并多个部分填充的容器/LPNs到更少的和更加优化的的容器中。</p>
<p style="color: #000000;">8.      发运验证和关闭，立刻通知Oracle WMS什么物料，多少数量和什么容器已经被拣货或装货，还有那些应从库存中扣除。</p>
<p style="color: #000000;">9.      仓储管理控制面板，仓储管理控制面板提供了仓库多个区域中工作进程的实时快照，这样使仓库经理调整他的工作人员到一个可能落后于其它区域的区域。</p>
<p style="color: #000000;">10.  波次拣货，提供了一个图形化的查询方式，使你可以基于几种选择条件的组合构建一个波次拣货，包括订单行，容器，投递，行程，收件人，发运方式，收货地址，订单收益，客户投递计划，运输公司等等。</p>
<p style="color: #000000;">11.  拣货发放任务的生成和库存的分配，拣货任务的次序是由波次拣货生成时决定的，并根据用户可定义的规则来确定优先级，包括拣货方法，工作负载，拣货路径，库存分配规则订单。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>存储和设备管理概览</strong></p>
<p style="color: #000000;">1.      自动补货，提供了库存和MRP补货计划，动态补货，直接从收货补货。</p>
<p style="color: #000000;">2.      高级批次和序列号控制，包含对批次的分隔，合并和改名的支持。</p>
<p style="color: #000000;">3.      容器管理，使用户可以跟踪任何收货,WIP，库存，发运和在途容器中的内容。</p>
<p style="color: #000000;">4.      物料状态控制，表明物料是否可用于哪些业务。</p>
<p style="color: #000000;">5.      看板(Kanban)管理,即支持内部也支持外部供应商看板。</p>
<p style="color: #000000;">6.      任务分配，指导仓库人员到必须的任务分配，仓库区域位置，和完成分配任务所需要的设备。</p>
<p style="color: #000000;">7.      库存业务，促进商品进入仓库，出仓库和仓库内的移动。</p>
<p style="color: #000000;">8.      循环盘点/物理盘点，使多用户可以通过物料，位置，拣货频率，天数，不一致性，期望收货等等来定义盘点条件。启动时的完全物理盘点和审核物理盘点也是支持的。</p>
<p style="color: #000000;">9.      基于异常管理的工作流，帮助仓库经理通过配置实时警报和基于工作流的供应链事件提醒来改进他们业务操作的有效性。比如，当员工拣货的数量少于订单要求的数量时，工作流会发送一个提醒来对库位进行盘点。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>逆向物流概览</strong></p>
<p style="color: #000000;">l  RMA(Return Material Authorization),使用Orcle仓储管理来记录客户退货的收货和检验情况。收货的物料，日期和数量可以根据RMA来验证。</p>
<p style="color: #000000;">l  供应商退货（退货给供应商return to vendor RTV）,使物料从之前收货的采购订单或者采购协议退回给合适的供应商。</p>
<p style="color: #000000;">l  翻新和回收利用，为需要高级逆向物流和修理服务的业务流程提供Oracle Service and Depot Repair支持。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>附加值服务</strong></p>
<p style="color: #000000;">l  Kitting/Dekitting,支持Kit to Stock（通过Work Order-less completion来进行支持）和Kit to Order（通过Pick toOrder支持）。</p>
<p style="color: #000000;">l  混合节点生产，支持按订单生产(ATO),基于项目/按订单设计（ETO），同时离散和重复/流程环境。</p>
<p style="color: #000000;">l  生产组件的拣货，支持通过移动用户接口为WIP进行拣货(Work in process).</p>
<p style="color: #000000;">l  产品承诺标签，使你可以打印产品特定的标签，基于用户定义的产品承诺标签规则。</p>
<p style="color: #000000;">l  VAS/生产质量检验，基于可配置性，系统自动产生物理移动事务来把一个物料从生产区域移到质量控制检验区域。</p>
<p style="color: #000000;">l  于PJM,Flow和OSFM的集成，仓储管理可以与项目管理，流程制造和车间管理进行集成。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>规则和规则引擎</strong></p>
<p style="color: #000000;">规则引擎为和你的仓库有关的客户限制和业务策略提供了一个存储区。</p>
<p style="color: #000000;">l  客户限制和业务策略通过作为规则为规则引擎实现和强制执行。</p>
<p style="color: #000000;">l  规则是直接从标准Oracleforms来定义和实现的。当定义和实现规则时，不必写自定义的代码。</p>
<p style="color: #000000;">l  你通过提供的值列表的选择来构建规则。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>LPN(License Plate Numbers)</strong></p>
<p style="color: #000000;">一个LPN代表了任意一个存在于一个位置并持有物料的对象</p>
<p style="color: #000000;">l  所有通过OracleWMS接收的物料都关联一个唯一的LPN。这使物料更容易在仓库中被跟踪和进行事务处理，而不需要扫描物料，数量，批次或者序列号。</p>
<p style="color: #000000;">l  Oracle WMS对存储于LPNs的库存物料提供了完全的可见性。一个LPN可能是一个容器，但它不需要代表一个物理实体。它可以像贴在一些物料集合上的标签一样简单，Oracle WMS使用户可以跟踪，进行事务处理，和嵌套（组合）LPNs极其它们的内容。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>使用LPNs</strong></p>
<p style="color: #000000;">你可以使用LPNs来做下面这些事情：</p>
<p style="color: #000000;">l  通过LPN进行收货，存储和拣货。</p>
<p style="color: #000000;">l  通过LPN查看现有量。</p>
<p style="color: #000000;">l  通过LPN对多个物料在一个事务中进行处理。</p>
<p style="color: #000000;">l  打印标签和报表以便参考容器中的内容。</p>
<p style="color: #000000;">l  跟踪嵌套的LPNs,比如运货板上的cartons（这里运货板是一个LPN且每个carton都有自己的LPN）。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>物料状态</strong></p>
<p style="color: #000000;">物料状态控制通过提供一个额外的控制和事务控制区域扩展了item状态控制功能。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">除了可以在item级别指定事务行为，物料状态控制使你可以在子库存，库位，批次或序列号级别指定物料状态。这样你可以为库存物料指定那些事务是允许的，哪些是不允许的。</p>
<p style="color: #000000;">物料状态也使你可以通过物料当前的状态来进行查询，也使你可以生成和查看仓库中物料状态的历史改变报表。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>仓储管理控制面板</strong></p>
<p style="color: #000000;">仓储管理控制面板为仓库经理提供了仓库中所有工作的实时进展的快照。它使仓库经理可以做以下事情：</p>
<p style="color: #000000;">l  提供活动类型和资源来管理工作任务</p>
<p style="color: #000000;">l  跟踪工作进程且指导他的人力到可能落后的区域。</p>
<p style="color: #000000;">l  重新分配已经被一个员工接受的任务给另一个员工。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>仓储管理系统的集成点</strong></p>
<p style="color: #000000;"></p>
<p style="color: #000000;">仓储系统与下面系统的集成</p>
<p style="color: #000000;">l  采购（Purchasing）</p>
<p style="color: #000000;">l  WIP(Work in process)</p>
<p style="color: #000000;">l  库存(Inventory)</p>
<p style="color: #000000;">l  发运(Shipping)</p>
<p style="color: #000000;">l  订单管理(OrderManagement)</p>
<p style="color: #000000;">l  生产(Manufacturing)</p>
<p style="color: #000000;">l  成本(Costing)</p>
<p style="color: #000000;">l  质量(Qulity)</p>
<p style="color: #000000;">仓储管理使用了和库存相同的设置步骤，只是对有些方面做了一些修改。比如，仓储使用了你在库存中定义的子库存和库位。仓储管理紧密地和库存集成并增强了它的功能并添加了新的功能。</p>
<p style="color: #000000;">l  WMS使用了库存相同的设置步骤，但是当实现WMS是要考虑额外的属性。</p>
<p style="color: #000000;">l  因为当使用WMS时库存是必须的，当实现WMS时，不得不考虑库存属性。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>移动应用程序和仓储管理</strong></p>
<p style="color: #000000;">移动应用程序使你可以实时输入事务并接受系统分配的仓库任务。</p>
<p style="color: #000000;">移动应用程序代表了移动手持设备，它可以帮助降低成本并在事务处理时提高效率。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>移动应用程序集成</strong></p>
<p style="color: #000000;">移动应用程序为很多现在在桌面上进行的事务提供了移动接口。作为Oracle EBS方案的一部分，移动应用程序与Oracle Manufacturing, Oracle Quality, Oracle Shipping和OracleInventory集成.比如，在Receiving里，移动应用程序与收货事务，质量检测，RMAs和越库集成。</p>
<p style="color: #000000;">在Manufacuturing里，移动应用程序提供了一个移动应用接口来进行move,scrap/reject，completion事务，resource 事务，和work orderless assemblies.质量数据也可以事务过程中输入。移动应用为FlowManufacturing提供了类似的集成。</p>
<p style="color: #000000;">Oracle Quality提供了一个接口来在移动设备上收集质量数据和查看详细说明。</p>
<p style="color: #000000;">Oracle Inventory在移动设备上支持杂项事务，组织间转移，周期盘点，物理盘点，并提供了查看现有库存量的能力。</p>
<p style="color: #000000;">拣货和发运流程集成了Oracle 订单管理和Oracle采购提供在流程中任意点上订单上精确图画。</p>
<p style="color: #000000;">与标签打印方案集成的整个方案，完成了整个流程。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>数据标识符</strong></p>
<p style="color: #000000;">数据标识符通过为每种要扫描的数据的类型关联一个不同的前缀来允许订单之外的扫描。</p>
<p style="color: #000000;">移动设备在放置数据到设备上的正确的位置之前，会自动移除这些前缀。</p>
<p style="color: #000000;">Oracle 仓储管理支持数据字段标识符(DFI),包含前缀的条形码可以标示包含在条形码中的值。有3个步骤来使用这个功能：</p>
<p style="color: #000000;">要设置DFI，前缀可以关联移动设备上的字段。另外，DFIs可以指定为必填的或者可选的。多个DFIs可以关联一个特定的订单来指明匹配的订单。</p>
<p style="color: #000000;">比如，要为Item设置DFI，文本”DFI=P+,p+P,p REQ=N”会在AK Prompt Form上注册。这会告诉移动服务器查找下面的DFIs:”订单上的P+”, “p+”, “P”, “p”。它也指明了这个DFI是可选的。这意味着如果服务器找到一个DFI，它就会移除掉。但是没有找到，那么整个条形码都会被使用。</p>
<p style="color: #000000;">除了设置DFI，移动设备必须配置为为条形码前置一个ASCII控制字符来向移动服务器表明数据来自于条形码并查找DFI。</p>
<p style="color: #000000;">DFI移除，当移动设备识别出时一个条形码扫描时，它会检查所有匹配的DFIs.如果找到了一个DFI，它会移除掉DFI并插入余下的数据到当前字段。</p>
<p style="color: #000000;">订单之外的扫描，如果页面上包含一个DFI的字段在订单之外扫描，移动服务器会移除掉DFI并立即把值放到合适的字段上。光标还是留在当前字段上，但是扫描字段的值会被插入。你仅需要通过订单之外扫描字段来处理合适的验证。</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">（转载原文：http://blog.csdn.net/tavor/article/details/32733161）</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>70</wp:post_id>
		<wp:post_date>2014-07-01 17:28:17</wp:post_date>
		<wp:post_date_gmt>2014-07-01 09:28:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-ebs-wms%e5%8a%9f%e8%83%bd%e4%bb%8b%e7%bb%8d%ef%bc%88%e4%ba%8c%ef%bc%89</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>Oracle EBS INV&amp;WMS Picking Rule</title>
		<link>http://localhost:81/wordpress/?p=72</link>
		<pubDate>Tue, 01 Jul 2014 09:35:44 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=72</guid>
		<description></description>
		<content:encoded><![CDATA[<h3>Inventory Picking Rule(Oracle Apps R12)</h3>
<p style="color: #000000;">用于在非WMS组织下，给Sales Order, WIP, OPM Manufacturing设置挑库规则</p>
<p style="color: #000000;">路径:Inventory &gt; Setup &gt; Rules &gt; Picking</p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341211318_9995.jpg" alt="" width="510" height="227" /></p>
<p style="color: #000000;"></p>

<ul style="color: #000000;">
	<li>Lot: You can sort by lot based on the following criteria:
<ul>
	<li>Lot Number Asc: Sorts the lot by number in ascending order.</li>
	<li>Lot Number Desc: Sorts the lot by number in descending order.</li>
	<li>FIFO: Sorts the lot by first in first out.</li>
	<li>FEFO: Sorts the lot by first expired first out.</li>
</ul>
</li>
	<li>Revision: You can sort by revision based on the following criteria:
<ul>
	<li>Revision Asc: Sorts by revision in ascending order.</li>
	<li>Revision Asc: Sorts by revision in descending order.</li>
	<li>Effective Date Asc: Sorts by revision effective date in ascending order.</li>
	<li>Effect Date Desc: Sorts by revision effective date in descending order.</li>
</ul>
</li>
	<li>Subinventory: You can sort by subinventory based on the following criteria:
<ul>
	<li>Subinventory Asc: Sorts by subinventory in ascending order.</li>
	<li>Subinventory: Desc: Sorts by subinventory in descending order.</li>
	<li>Receipt Date Asc: Sorts by receipt date in ascending order.</li>
	<li>Receipt Date: Desc: Sorts by receipt date in descending order.</li>
</ul>
</li>
	<li>Locator: You can choose to sort by locator based on the following criteria:
<ul>
	<li>Locator Asc: Sorts by locator in ascending order.</li>
	<li>Locator Desc: Sort by locator in descending order.</li>
	<li>Receipt Date Asc: Sorts by receipt date in ascending order.</li>
	<li>Receipt Date: Desc: Sorts by receipt date in descending order.</li>
</ul>
</li>
</ul>
<p style="color: #000000;"></p>
<p style="color: #000000;">创建完一个Picking rule之后，你可以使用Rules Workbench来把Picking Rule规则分配给具体的Item项。Seq的数字越小，优先级越高。</p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341211556_2564.jpg" alt="" width="563" height="375" /></p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>Organization Parameter下边关于Picking Rule的设置</strong></p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341217494_8416.jpg" alt="" width="560" height="486" /></p>
<p style="color: #000000;">Picking Default里的Rule是用于选择一个默认的rule规则,这个默认的Picking rules用于<strong>Order Management</strong>来挑选货物。根据NOTE1327488.1，If it will assign seeded picking rule at Org Paramerts and user define Picking rules in Rules Bench.. Which one is effective?</p>
<p style="color: #000000;">The Rules workbench has a high priority over the Organization Parameters Picking Rule。</p>
<p style="color: #000000;">特别注意：<span style="text-decoration: underline;">This rule will not be employed in a WMS enabled organization.</span> (WMS 的Org不用默认的Org Picking Rule)</p>
<p style="color: #000000;"><strong>Item下Picking Rule的设置</strong></p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341218585_2886.jpg" alt="" width="687" height="354" /></p>
<p style="color: #000000;">用于设置这个Item默认选取的rule规则。所以Picking Rule可以在Org级设置也可以在Item级制定。</p>
&nbsp;
<h3><a style="color: #ff9900;" name="t1"></a>WMS Picking Rule</h3>
<span style="color: #000000;">路径：Warehouse Manager &gt; Setup &gt; Warehouse Configuration &gt; Rules &gt; Warehouse Execution &gt; Rules</span>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>INV Rule和WMS Rule的关系：</strong></p>
<p style="color: #000000;">对于非WMS组织，应该使用Inv的Picking Rule，只有WMS才用上边这个路径来设置Picking Rule。下图为非WMS组织打开WMS Rule form的提示，"WMS Rules / Strategies are not supported in INV org. Use Picking Rules : Inventory -&gt; Setup -&gt; Rule -&gt; picking"</p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341212735_6844.jpg" alt="" width="497" height="232" /></p>
<p style="color: #000000;">如果是在WMS下，打开WMS Rules form，界面如下：</p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341217241_3270.jpg" alt="" width="586" height="370" /></p>
<p style="color: #000000;"><img src="http://my.csdn.net/uploads/201207/02/1341217260_4261.jpg" alt="" width="605" height="381" /></p>
<p style="color: #000000;">很明显WMS的Picking Rule能定义更负责的挑库规则。下边为<a style="color: #ff9900;" href="http://www.oracleug.com/user-guide/warehouse-management/overview-picking" target="_blank">http://www.oracleug.com/user-guide/warehouse-management/overview-picking</a>的一段解释</p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><em>picking rule in inventory determine the order in which revisions, lots, subinventories, and locators are picked for sales orders.
</em></p>
<p style="color: #000000;"><em>Picking rule in WMS is used for<span style="color: #3366ff;"> directed picking creates material allocations and directs operators to pick material from specific locations.</span></em></p>
<em style="color: #000000;">They(INV rule and WMS Rule) workin conjunction with the different pick methodologies. Pick methodologies refer to the different method an operator performs picking tasks. For example, an operator may select to pick an order by itself, or to pick multiple orders at the same time.</em>
<p style="color: #000000;"><em>The system generates picking tasks and dispatches them to qualified operators based on rules. After picking is complete, the system provides operators with the appropriate number and size of containers the order requires for shipping.</em></p>
<p style="color: #000000;"></p>
<p style="color: #000000;"><strong>WMS Rule定义的流程</strong></p>
<p style="color: #000000;">In a WMS Organization,you need to create your rule with following nav path:

Warehouse Manager &gt; Setup &gt; Warehouse Configuration &gt; Warehouse Execution &gt; Rules

After doing that and enabling the rule you should be able to assign rule to Rules Workbench.

Nav Path: Warehouse Manager &gt; Setup &gt; Warehouse Configuration &gt; Warehouse Execution &gt; Rules Workbench

Then you should run Generate All Rules concurrent program

Warehouse Manager &gt; Others &gt; Others &gt; Requests &gt; Requests &gt; Run &gt; Generate All Rules</p>
<p style="color: #000000;"></p>

<h2><a style="color: #ff9900;" name="t2"></a>另外关于Pick Release Rules</h2>
<p style="color: #000000;">路径：Order Management &gt; Shipping &gt; setup &gt; Define Release Rules Forms</p>
<p style="color: #000000;">Pick Release Rule和Picking Rule 是两个不同的东西，Pick Release rule是一个在做SO Pick Release时的模板，做SO Pick Release的时候，你可以选择不同的模板，这样可以会自动带出Pick Release的预定义选项。（感觉应该改名字叫Release Template，会更清楚些）
<img src="http://my.csdn.net/uploads/201207/02/1341221215_9963.jpg" alt="" width="574" height="364" /></p>
<p style="color: #000000;"></p>

<h2><a style="color: #ff9900;" name="t3"></a>INV Picking Rule的后台逻辑</h2>
<p style="color: #000000;">从R12开始，对于非WMS Org，在做Pick Release的时候，WMS Rules Engine会被调用，就是说，对于non WMS organizations，Rule Engine将不会看WMS strategies，它只会看Inventory Picking Rules。</p>
<p style="color: #000000;">每创建一个新的Rule，在MTL_PICKING_RULES表会插入一条记录，Sample Query：
<em>SELECT * FROM mtl_inv_picking_rules WHERE wms_rule_id = 10533;</em>

几个MTL_PICKING_RULES表中的字段
<em><strong>LOT_SORT</strong>:                 0 - NONE, no sort; 1 - Lot number Asc; 2 - Lot number Desc; 3 - FIFO , first in first out; 4 - FEFO, first expire first out
<strong>LOT_SORT_RANK</strong>:     Order by rank regarding to other sort criteria, saved as wms_sort_criteria.sequence_number
<strong>REVISION_SORT</strong>:        0 - NONE; 1 - Revision Asc; 2 - Revision Desc; 3 - Effective date Asc; 4 - Effective date Desc
<strong>REVISION_SORT_RANK</strong>:Order by rank regarding to other sort criteria, saved as wms_sort_criteria.sequence_number
<strong>SUBINVENTORY_SORT</strong>:0 - NONE; 1 - Subinventory Asc; 2 - Subinventory Desc; 3 - Receipt date Asc; 4 - Receipt date Desc
<strong>SUBINVENTORY_SORT_RANK</strong>:Order by rank regarding to other sort criteria, saved as wms_sort_criteria.sequence_number
<strong>LOCATOR_SORT</strong>:        0 - NONE; 1 - Locator Asc; 2 - Locator Desc; 3 - Receipt date Asc; 4 - Receipt date Desc
<strong>LOCATOR_SORT_RANK</strong>:Order by rank regarding to other sort criteria, saved as wms_sort_criteria.sequence_number</em>

当Enable这个Rule之后，在wms_rules_b表也会有对应的记录产生，Sample Query：
<em>SELECT tl.name,tl.description,b.*
FROM wms_rules_b b,wms_rules_tl tl
WHERE b.rule_id = tl.rule_id
AND b.rule_id=10533
AND LANGUAGE = 'US';</em></p>
<p style="color: #000000;"></p>
<p style="color: #000000;">Rule Workbench对应的Table是wms_selection_criteria_txn(picking rule assignments),可以使用下边的Query查询Rule Workbench的信息，Sample Query：
<em>Select * from wms_selection_criteria_txn where return_type_id=&amp;rule_id;</em>

并且会动态生成一个新的Package:WMS_RULE_&lt;rule_id&gt;，你可以通过下边的SQL查看WMS_RULE_&lt;Rule_ID&gt;的内容
select text from dba_source where name='WMS_RULE_XXXX';

可以从INV Log中找到，挑库的时候到底使用了那个Rule Id，比如，可以在日志中找到下边的信息
[01-AUG-11 05:57:43] wms.plsql.WMS_Rule_PVT.Apply.l_rule_id: 10533
如果Pick的过程报错，可以在日志中看到下边类似的信息：</p>
<p style="color: #000000;">wms.plsql.WMS_Engine_PVT.Create_Suggestions.end G_SUGG_FAILURE_MESSAGE: WMS_PICK_NO_ROWS</p>
<p style="color: #000000;"></p>
<p style="color: #000000;">Reference:</p>
<p style="color: #000000;"><a style="color: #ff9900;" href="http://www.scribd.com/doc/60058250/WMS-RULE" target="_blank">http://www.scribd.com/doc/60058250/WMS-RULE</a></p>
<p style="color: #000000;"><a style="color: #ff9900;" href="http://www.oracleug.com/user-guide/warehouse-management/overview-picking" target="_blank">http://www.oracleug.com/user-guide/warehouse-management/overview-picking</a></p>
<p style="color: #000000;"></p>
<p style="color: #000000;">转载出处：<a style="color: #ff9900;" href="http://blog.csdn.net/pan_tian/article/details/7708578">http://blog.csdn.net/pan_tian/article/details/7708578</a></p>
<p style="color: #000000;"></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>72</wp:post_id>
		<wp:post_date>2014-07-01 17:35:44</wp:post_date>
		<wp:post_date_gmt>2014-07-01 09:35:44</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-ebs-invwms-picking-rule</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="category" nicename="inv"><![CDATA[INV]]></category>
		<category domain="post_tag" nicename="inv"><![CDATA[INV]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>Oracle EBS on Mobile Device</title>
		<link>http://localhost:81/wordpress/?p=76</link>
		<pubDate>Tue, 01 Jul 2014 10:08:09 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=76</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="color: #000000;">近期看了一些EBS在移动终端的应用案例，大体研究了下，EBS移动终端的实现方法大体有以下几种:</p>
<p style="color: #000000;"><img src="http://www.oracle.com/technetwork/developer-tools/adf/html5-java-ios-android-1864261.png" alt="" /></p>
&nbsp;
<p style="color: #000000;"><strong>1.<a style="color: #ff9900;" href="http://www.oracle.com/technetwork/developer-tools/adf/overview/index.html" target="_blank">ADF</a> Mobile</strong></p>
<p style="color: #000000;">Oracle ADF Mobile是基于Java和HTML5的移动开发框架，基于这个框架构建，扩展企业应用到安卓和iOS。</p>
<p style="color: #000000;">Demo1:<a style="color: #ff9900;" href="http://download.oracle.com/otn_hosted_doc/jdeveloper/11gdemos/adfmobiledemo/adfmobiledemo.html" target="_blank">http://download.oracle.com/otn_hosted_doc/jdeveloper/11gdemos/adfmobiledemo/adfmobiledemo.html</a></p>
<p style="color: #000000;">Demo2:<a style="color: #ff9900;" href="https://blogs.oracle.com/shay/entry/building_iphone_interfaces_for_oracle" target="_blank">https://blogs.oracle.com/shay/entry/building_iphone_interfaces_for_oracle</a></p>
<p style="color: #000000;">Presentation:<a style="color: #ff9900;" href="http://download.oracle.com/otn_hosted_doc/jdeveloper/11gdemos/ADFMobileInsiderOverview/ADFMobileInsiderOverview.html" target="_blank">http://download.oracle.com/otn_hosted_doc/jdeveloper/11gdemos/ADFMobileInsiderOverview/ADFMobileInsiderOverview.html</a></p>
<p style="color: #000000;">Youtube上转了开发<a style="color: #ff9900;" href="http://v.youku.com/v_show/id_XNTI1ODAyNTA4.html" target="_blank">视频到youku</a>上：</p>
<p style="color: #000000;"><strong>2.APEX on Mobile</strong></p>
<p style="color: #000000;">APEX可以快速的构建移动应用，或直接访问数据库，或通过webservice来调用EBS的服务，最终实现EBS的终端访问。</p>
<p style="color: #000000;">11g的数据库会默认安装APEX，所以对企业来说也不需要额外的成本。</p>
<p style="color: #000000;"><img src="http://img.my.csdn.net/uploads/201303/12/1363092827_9224.png" alt="" />  <img src="http://img.my.csdn.net/uploads/201303/12/1363092851_4813.png" alt="" /></p>
<p style="color: #000000;"><img src="http://img.my.csdn.net/uploads/201303/12/1363092887_2305.png" alt="" />  <img src="http://img.my.csdn.net/uploads/201303/12/1363092907_1186.png" alt="" /></p>
<p style="color: #000000;">Demo1:<a style="color: #ff9900;" href="http://www.click-apex.at/apex/f?p=mobile" target="_blank">http://www.click-apex.at/apex/f?p=mobile</a></p>
<p style="color: #000000;">Demo 2:<a style="color: #ff9900;" href="http://apex-outsource.com/pls/apex/f?p=169:2" target="_blank">http://apex-outsource.com/pls/apex/f?p=169:2</a></p>
<p style="color: #000000;">Vedio:<a style="color: #ff9900;" href="http://v.youku.com/v_show/id_XNTI1ODE2NzY0.html" target="_blank">http://v.youku.com/v_show/id_XNTI1ODE2NzY0.html</a></p>
<p style="color: #000000;">A Useful Book:<a style="color: #ff9900;" href="http://www.itpub.net/forum.php?mod=viewthread&amp;tid=1797459&amp;page=1" target="_blank">Oracle Application Express for Mobile Web Applications</a></p>
<p style="color: #000000;"><strong>3.Oracle Business Approvals for Managers</strong></p>
<p style="color: #000000;">暂时只能应用于iPhone手机上的免费应用，经理层可以通过这款应用来处理来自E-Business Suite请求，比如费用报销，采购请求，请假申请等。传输的信息通过SSL加密，所以安全性是有保证的。</p>
<p style="color: #000000;">参考文章：<a style="color: #ff9900;" href="https://blogs.oracle.com/stevenChan/entry/oracle_business_approvals_for_managers_iphone_app_now_available" target="_blank">Oracle Business Approvals for Managers Now Available for iPhone </a></p>
<p style="color: #000000;">Integration Architecture</p>
<p style="color: #000000;"><img src="http://blogs.oracle.com/stevenChan/resource/images/iphone-bus-approvals-arch.png" alt="" /></p>
<p style="color: #000000;">转载出处：<a style="color: #ff9900;" href="http://blog.csdn.net/pan_tian/article/details/8665372" target="_blank">http://blog.csdn.net/pan_tian/article/details/8665372</a></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>76</wp:post_id>
		<wp:post_date>2014-07-01 18:08:09</wp:post_date>
		<wp:post_date_gmt>2014-07-01 10:08:09</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>76</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="adfm"><![CDATA[ADFm]]></category>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="category" nicename="mobile"><![CDATA[Mobile]]></category>
		<category domain="post_tag" nicename="mobile"><![CDATA[Mobile]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>Inter-Org Transfer  组织间转移</title>
		<link>http://localhost:81/wordpress/?p=81</link>
		<pubDate>Tue, 01 Jul 2014 10:44:08 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=81</guid>
		<description></description>
		<content:encoded><![CDATA[Inter-Org Transfer 可分为：
1、组织间直接转移 Direct Inter-Org Transfer
2、组织间在途转移 Intransit Inter-Org Transfer

接收方式有三种：

直接接收（Direct Receipt)
标准接收（Standard Receipt)
检验后接收（Inspection Required Receipt）
设置Shipping Networks (M1 -&gt; W1)

创建IOT, 输入自定义的Number

<a href="http://bugalot.com/wp-content/uploads/2014/07/IOT_1.png"><img class="alignnone size-full wp-image-82" src="http://bugalot.com/wp-content/uploads/2014/07/IOT_1.png" alt="IOT_1" width="1348" height="616" /></a> <a href="http://bugalot.com/wp-content/uploads/2014/07/IOT_2.png"><img class="alignnone size-full wp-image-83" src="http://bugalot.com/wp-content/uploads/2014/07/IOT_2.png" alt="IOT_2" width="1494" height="636" /></a>
在W1进行接收

<a href="http://bugalot.com/wp-content/uploads/2014/07/IOT_3.png"><img class="alignnone size-full wp-image-84" src="http://bugalot.com/wp-content/uploads/2014/07/IOT_3.png" alt="IOT_3" width="300" height="350" /></a> <a href="http://bugalot.com/wp-content/uploads/2014/07/IOT_4.png"><img class="alignnone size-full wp-image-85" src="http://bugalot.com/wp-content/uploads/2014/07/IOT_4.png" alt="IOT_4" width="300" height="350" /></a> <a href="http://bugalot.com/wp-content/uploads/2014/07/IOT_5.png"><img class="alignnone size-full wp-image-86" src="http://bugalot.com/wp-content/uploads/2014/07/IOT_5.png" alt="IOT_5" width="300" height="350" /></a>

最后入库

Related SQL query
<pre lang="sql" line="1" escaped="true">--After receipt
--IOT# = shipment_num
--header_id = 4824921
SELECT * FROM rcv_shipment_headers WHERE shipment_num = 'IOT20140523-2';
--line_id = 4816477
--shipment_line_status_code = fully received
SELECT * FROM rcv_shipment_lines rsl WHERE shipment_header_id = 4824921;
--MTRL
SELECT * FROM mtl_txn_request_lines mtrl WHERE lpn_id = 12277;
SELECT wlpn.lpn_context, wlpn.* FROM wms_license_plate_numbers wlpn WHERE license_plate_number = 'LPN128A';
SELECT * FROM wms_lpn_contents WHERE parent_lpn_id = 12277;
SELECT * FROM rcv_transactions WHERE shipment_line_id = 4816477;
SELECT * FROM rcv_supply WHERE shipment_line_id = 4816477;
SELECT * FROM mtl_material_transactions WHERE content_lpn_id = 12276;
SELECT mmt.* FROM mtl_material_transactions mmt WHERE shipment_number = 'IOT20140523-2';
SELECT mmt.content_lpn_id, mmt.* FROM mtl_material_transactions mmt WHERE last_update_date &gt; sysdate -1 /24;
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>81</wp:post_id>
		<wp:post_date>2014-07-01 18:44:08</wp:post_date>
		<wp:post_date_gmt>2014-07-01 10:44:08</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>inter-org-transfer-%e7%bb%84%e7%bb%87%e9%97%b4%e8%bd%ac%e7%a7%bb</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="post_tag" nicename="iot"><![CDATA[IOT]]></category>
		<category domain="post_tag" nicename="mwa"><![CDATA[MWA]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title> ASN（Advance Shipment Notice) via iSupplier Portal with LPNs and Lot Attributes</title>
		<link>http://localhost:81/wordpress/?p=94</link>
		<pubDate>Wed, 02 Jul 2014 09:34:11 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=94</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>ASN is a notice sent from the supplier to the customer to let him know  that the shipment is coming. </strong>

<strong>优点：</strong>

将到货通知提前发给客户，以便使客户做好接收货物的安排。

普通的Purchase Order接收，只有货到时才知道，不利于接收组织提交做好接收安排。

<strong>ASN processing：</strong>
<ol>
	<li>Shipment authorization</li>
	<li>Supplier sends the ASN</li>
	<li>Verify ASN</li>
	<li>The goods arrive.</li>
</ol>
&nbsp;

0.setup Supplier User or use the existing User
<table width="100%">
<tbody>
<tr>
<td>Go to Purchasing -&gt; Supply base -&gt; Supplier User Management -&gt; Register Supplier User

This will bring up the form for you to create a new user for a supplier.
Once you are done, log back to the application as 'System Administrator' and set the password for the supplier user u created earlier.
Now you can start using the supplier user...</td>
</tr>
</tbody>
</table>
1.Create Purchase Order

&nbsp;
<table width="627">
<tbody>
<tr>
<td width="80">Line</td>
<td width="100">Item</td>
<td width="90">Qty</td>
<td width="129">Receipt Routing</td>
<td width="52">Org</td>
<td width="175">Promised date</td>
</tr>
<tr>
<td width="80">1</td>
<td width="100">WM100</td>
<td width="90">100</td>
<td width="129">Standard</td>
<td width="52">W1</td>
<td width="175">today</td>
</tr>
<tr>
<td width="80">2</td>
<td width="100">WM219</td>
<td width="90">100</td>
<td width="129">Standard</td>
<td width="52">W1</td>
<td width="175">today</td>
</tr>
<tr>
<td width="80">3</td>
<td width="100">WM500</td>
<td width="90">100</td>
<td width="129">Standard</td>
<td width="52">W1</td>
<td width="175">today</td>
</tr>
</tbody>
</table>
&nbsp;

PO# : 6035

Approve PO

<a href="http://bugalot.com/wp-content/uploads/2014/07/ASN_1.png"><img class="alignnone size-full wp-image-98" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_1.png" alt="ASN_1" width="994" height="598" /></a>

2.Create ASN using ISupplier Portal

User : Advantage

Pass : welcome
<table width="100%">
<tbody>
<tr>
<td>
<ol start="6">
	<li>Click on ‘I supplier portal full access’ -&gt; ‘Home Page’</li>
	<li>You are on the home page of iSupplier Portal. Supplier Reviews PO in iSupplier Portal.</li>
	<li>Click on Shipments -&gt; Shipment Notices -&gt; Create Advance Shipment Notices.</li>
	<li>Select your PO, line 1 and click on ‘Add to shipment notice’.</li>
	<li>Enter 10 in ‘Quantity Shipped’. Click on LPN/LOT/Serial attribute button.</li>
	<li>Enter a unique LPN no and quantity. Note down your LPN no. Click OK. (If the item is lot/serial controlled, you can enter lot/serial attributes too)</li>
	<li>Click on ‘Shipment Header’. Enter a unique shipment no, shipment date and expected receipt date. Note down ‘shipment no’ and click on ‘submit’.</li>
</ol>
</td>
</tr>
</tbody>
</table>
<a href="http://bugalot.com/wp-content/uploads/2014/07/ASN_2.png"><img class="alignnone size-full wp-image-99" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_2.png" alt="ASN_2" width="820" height="414" /></a>

3.Receive ASN via Mobile UI

ASN# : ASN6035

Receipt#  5087

<img class="alignnone size-full wp-image-100" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_3.png" alt="ASN_3" width="300" height="350" />

4.Verify Receipt
<table width="100%">
<tbody>
<tr>
<td>
<ol start="5">
	<li>On the desktop, go to Warehouse Manager -&gt; Inquiry -&gt; Material Workbench</li>
</ol>
Enter sub inventory type as ‘Receiving’ and LPN as the LPN received in earlier step and click on ‘find’. You will see the LPN in subinventory RCV and locator RCV1.1.1. If the item in the LPN is lot/serial controlled, you’ll also see lot/serial numbers associated with the LPN.</td>
</tr>
</tbody>
</table>
<img class="alignnone size-full wp-image-101" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_4.png" alt="ASN_4" width="879" height="673" />

<img class="alignnone size-full wp-image-102" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_5.png" alt="ASN_5" width="758" height="504" />

&nbsp;

5.Review Putaway rules
<table width="100%">
<tbody>
<tr>
<td>
<ol start="6">
	<li>On the desktop application, review putaway plan for org W1 and item WM100.</li>
</ol>
Warehouse Manager -&gt; Set up -&gt; warehouse configuration -&gt; rules -&gt; warehouse execution -&gt; rules workbench

Notice that for org W1 and item WM100, putaway strategy being used is ‘Putaway to BULK’.
<ol start="7">
	<li>Warehouse Manager -&gt; Set up -&gt; warehouse configuration -&gt; rules -&gt; warehouse execution -&gt; Strategies</li>
</ol>
Notice that the putaway strategy ‘Putaway to BULK’ uses rule ‘Put away to BULK subinventory’.
<ol start="8">
	<li>Warehouse Manager -&gt; Set up -&gt; warehouse configuration -&gt; rules -&gt; warehouse execution -&gt; rules</li>
</ol>
Notice that the putaway rule ‘Put away to BULK subinventory’ is directing material to BULK sub-inventory.</td>
</tr>
</tbody>
</table>
&nbsp;

5.Put away

<img class="alignnone size-full wp-image-103" src="http://bugalot.com/wp-content/uploads/2014/07/ASN_6.png" alt="ASN_6" width="300" height="350" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>94</wp:post_id>
		<wp:post_date>2014-07-02 17:34:11</wp:post_date>
		<wp:post_date_gmt>2014-07-02 09:34:11</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>asn%ef%bc%88advance-shipment-notice-via-isupplier-portal-with-lpns-and-lot-attributes</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="asn"><![CDATA[ASN]]></category>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="wms"><![CDATA[WMS]]></category>
		<category domain="post_tag" nicename="wms"><![CDATA[WMS]]></category>
	</item>
	<item>
				<title>大数据(Big Data)</title>
		<link>http://localhost:81/wordpress/?p=106</link>
		<pubDate>Thu, 03 Jul 2014 03:16:41 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=106</guid>
		<description></description>
		<content:encoded><![CDATA[<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">什么是大数据</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">大数据</span>是指无法在一定时间内用常规软件工具对其内容进行抓取、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="管理" href="http://wiki.mbalib.com/wiki/%E7%AE%A1%E7%90%86">管理</a>和处理的数据集合。大数据技术，是指从各种各样类型的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE">数据</a>中，快速获得有价值信息的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="能力" href="http://wiki.mbalib.com/wiki/%E8%83%BD%E5%8A%9B">能力</a>。适用于大数据的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="技术" href="http://wiki.mbalib.com/wiki/%E6%8A%80%E6%9C%AF">技术</a>，包括大规模并行处理（MPP）数据库，数据挖掘电网，分布式文件系统，分布式数据库，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="云计算平台" href="http://wiki.mbalib.com/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0">云计算平台</a>，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="互联网" href="http://wiki.mbalib.com/wiki/%E4%BA%92%E8%81%94%E7%BD%91">互联网</a>，和可扩展的存储系统。<span style="font-size: 16px;">
具体来说，大数据具有4个基本特征：</span></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">

<a class="headline" style="margin: 0px; color: #2153b0;" name=".E5.A4.A7.E6.95.B0.E6.8D.AE.E7.9A.84.E7.89.B9.E7.82.B9.07UNIQ3dc665c38ea38e3-nowiki-00000004-QINU1.07UNIQ3dc665c38ea38e3-nowiki-00000005-QINU"></a>
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的特点</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">一是数据体量巨大。</span>百度资料表明，其新首页导航每天需要提供的数据超过1.5PB（1PB=1024TB），这些数据如果打印出来将超过5千亿张A4纸。有资料证实，到目前为止，人类生产的所有印刷材料的<a class="new" style="margin: 0px; color: red; text-decoration: none;" title="数据量" href="http://wiki.mbalib.com/w/index.php?title=%E6%95%B0%E6%8D%AE%E9%87%8F&amp;action=edit">数据量</a>仅为200PB。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">二是数据类型多样。</span>现在的数据类型不仅是文本形式，更多的是图片、视频、音频、地理位置信息等多类型的数据，个性化数据占绝对多数。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">三是处理速度快。</span>数据处理遵循“1秒定律”，可从各种类型的数据中快速获得高价值的信息。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">四是价值密度低。</span>以视频为例，一小时的视频，在不间断的监控过程中，可能有用的数据仅仅只有一两秒。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的作用</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">第一，对大数据的处理分析正成为新一代信息技术融合应用的结点。</span><a style="margin: 0px; color: #173abd; text-decoration: none;" title="移动互联网" href="http://wiki.mbalib.com/wiki/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91">移动互联网</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="物联网" href="http://wiki.mbalib.com/wiki/%E7%89%A9%E8%81%94%E7%BD%91">物联网</a>、社交网络、数字家庭、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="电子商务" href="http://wiki.mbalib.com/wiki/%E7%94%B5%E5%AD%90%E5%95%86%E5%8A%A1">电子商务</a>等是新一代信息技术的应用形态，这些应用不断产生大数据。<a style="margin: 0px; color: #173abd; text-decoration: none;" title="云计算" href="http://wiki.mbalib.com/wiki/%E4%BA%91%E8%AE%A1%E7%AE%97">云计算</a>为这些海量、多样化的大数据提供存储和运算平台。通过对不同来源数据的管理、处理、分析与优化，将结果反馈到上述应用中，将创造出巨大的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="经济" href="http://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E">经济</a>和社会价值。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　大数据具有催生社会变革的能量。但释放这种能量，需要严谨的数据治理、富有洞见的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据分析" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90">数据分析</a>和激发管理创新的环境(Ramayya Krishnan,<a style="margin: 0px; color: #173abd; text-decoration: none;" title="卡内基·梅隆大学" href="http://wiki.mbalib.com/wiki/%E5%8D%A1%E5%86%85%E5%9F%BA%C2%B7%E6%A2%85%E9%9A%86%E5%A4%A7%E5%AD%A6">卡内基·梅隆大学</a>海因兹学院院长)。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">第二，大数据是信息产业持续高速增长的新引擎。</span>面向大数据市场的新技术、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="新产品" href="http://wiki.mbalib.com/wiki/%E6%96%B0%E4%BA%A7%E5%93%81">新产品</a>、新服务、新业态会不断涌现。在硬件与集成设备领域，大数据将对<a style="margin: 0px; color: #173abd; text-decoration: none;" title="芯片" href="http://wiki.mbalib.com/wiki/%E8%8A%AF%E7%89%87">芯片</a>、存储产业产生重要影响，还将催生一体化数据存储处理服务器、内存计算等<a style="margin: 0px; color: #173abd; text-decoration: none;" title="市场" href="http://wiki.mbalib.com/wiki/%E5%B8%82%E5%9C%BA">市场</a>。在软件与服务领域，大数据将引发数据快速处理分析、数据挖掘技术和软件产品的发展。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">第三，大数据利用将成为提高<a style="margin: 0px; color: #173abd; text-decoration: none;" title="核心竞争力" href="http://wiki.mbalib.com/wiki/%E6%A0%B8%E5%BF%83%E7%AB%9E%E4%BA%89%E5%8A%9B">核心竞争力</a>的关键因素。</span>各行各业的决策正在从“业务驱动” 转变“数据驱动”。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　对大数据的分析可以使<a style="margin: 0px; color: #173abd; text-decoration: none;" title="零售商" href="http://wiki.mbalib.com/wiki/%E9%9B%B6%E5%94%AE%E5%95%86">零售商</a>实时掌握市场动态并迅速做出应对；可以为商家制定更加精准有效的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="营销策略" href="http://wiki.mbalib.com/wiki/%E8%90%A5%E9%94%80%E7%AD%96%E7%95%A5">营销策略</a>提供决策支持；可以帮助<a style="margin: 0px; color: #173abd; text-decoration: none;" title="企业" href="http://wiki.mbalib.com/wiki/%E4%BC%81%E4%B8%9A">企业</a>为<a style="margin: 0px; color: #173abd; text-decoration: none;" title="消费者" href="http://wiki.mbalib.com/wiki/%E6%B6%88%E8%B4%B9%E8%80%85">消费者</a>提供更加及时和个性化的服务；在医疗领域，可提高诊断准确性和药物有效性；在公共事业领域，大数据也开始发挥促进<a style="margin: 0px; color: #173abd; text-decoration: none;" title="经济发展" href="http://wiki.mbalib.com/wiki/%E7%BB%8F%E6%B5%8E%E5%8F%91%E5%B1%95">经济发展</a>、维护社会稳定等方面的重要作用。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">第四，大数据时代科学研究的方法手段将发生重大改变。</span>例如，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="抽样调查" href="http://wiki.mbalib.com/wiki/%E6%8A%BD%E6%A0%B7%E8%B0%83%E6%9F%A5">抽样调查</a>是<a style="margin: 0px; color: #173abd; text-decoration: none;" title="社会科学" href="http://wiki.mbalib.com/wiki/%E7%A4%BE%E4%BC%9A%E7%A7%91%E5%AD%A6">社会科学</a>的基本研究方法。在大数据时代，可通过实时监测、跟踪研究对象在互联网上产生的海量行为数据，进行挖掘分析，揭示出规律性的东西，提出研究结论和对策。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的分析</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　从所周知，大数据已经不简简单单是数据大的事实了，而最重要的现实是对大数据进行分析，只有通过分析才能获取很多智能的，深入的，有价值的信息。那么越来越多的应用涉及到大数据，而这些大数据的属性，包括数量，速度，多样性等等都是呈现了大数据不断增长的复杂性，所以大数据的分析方法在大数据领域就显得尤为重要，可以说是决定最终信息是否有价值的决定性因素。基于如此的认识，大数据分析普遍存在的方法理论有哪些呢？</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">1. 可视化分析。</span>大数据分析的使用者有大数据分析专家，同时还有普通用户，但是他们二者对于大数据分析最基本的要求就是可视化分析，因为可视化分析能够直观的呈现大数据特点，同时能够非常容易被读者所接受，就如同看图说话一样简单明了。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">2. 数据挖掘算法。</span>大数据分析的理论核心就是数据挖掘算法，各种数据挖掘的算法基于不同的数据类型和格式才能更加科学的呈现出数据本身具备的特点，也正是因为这些被全世界统计学家所公认的各种统计方法（可以称之为真理）才能深入数据内部，挖掘出公认的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="价值" href="http://wiki.mbalib.com/wiki/%E4%BB%B7%E5%80%BC">价值</a>。另外一个方面也是因为有这些数据挖掘的算法才能更快速的处理大数据，如果一个算法得花上好几年才能得出结论，那大数据的价值也就无从说起了。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">3. 预测性分析。</span>大数据分析最终要的应用领域之一就是预测性分析，从大数据中挖掘出特点，通过科学的建立模型，之后便可以通过模型带入新的数据，从而预测未来的数据。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">4. 语义引擎。</span>非结构化数据的多元化给数据分析带来新的挑战，我们<a style="margin: 0px; color: #173abd; text-decoration: none;" title="需要" href="http://wiki.mbalib.com/wiki/%E9%9C%80%E8%A6%81">需要</a>一套工具系统的去分析，提炼数据。语义引擎需要设计到有足够的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="人工智能" href="http://wiki.mbalib.com/wiki/%E4%BA%BA%E5%B7%A5%E6%99%BA%E8%83%BD">人工智能</a>以足以从数据中主动地提取信息。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">5.数据质量和<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据管理" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86">数据管理</a>。</span>大数据分析离不开数据质量和数据管理，高质量的数据和有效的数据管理，无论是在学术研究还是在商业应用领域，都能够保证分析结果的真实和有价值。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　大数据分析的基础就是以上五个方面，当然更加深入大数据分析的话，还有很多很多更加有特点的、更加深入的、更加专业的大数据分析方法。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的技术</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据采集" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E9%87%87%E9%9B%86">数据采集</a>：ETL工具负责将分布的、异构数据源中的数据如关系数据、平面数据文件等抽取到临时中间层后进行清洗、转换、集成，最后加载到<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据仓库" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93">数据仓库</a>或<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据集市" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E9%9B%86%E5%B8%82">数据集市</a>中，成为<a style="margin: 0px; color: #173abd; text-decoration: none;" title="联机分析处理" href="http://wiki.mbalib.com/wiki/%E8%81%94%E6%9C%BA%E5%88%86%E6%9E%90%E5%A4%84%E7%90%86">联机分析处理</a>、数据挖掘的基础。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据存取" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%AD%98%E5%8F%96">数据存取</a>：<a style="margin: 0px; color: #173abd; text-decoration: none;" title="关系数据库" href="http://wiki.mbalib.com/wiki/%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E5%BA%93">关系数据库</a>、NOSQL、SQL等。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　基础架构：<a style="margin: 0px; color: #173abd; text-decoration: none;" title="云存储" href="http://wiki.mbalib.com/wiki/%E4%BA%91%E5%AD%98%E5%82%A8">云存储</a>、分布式文件存储等。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　数据处理：自然语言处理(<a style="margin: 0px; color: #173abd; text-decoration: none;" title="NLP" href="http://wiki.mbalib.com/wiki/NLP">NLP</a>，Natural Language Processing)是研究人与<a style="margin: 0px; color: #173abd; text-decoration: none;" title="计算机" href="http://wiki.mbalib.com/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA">计算机</a>交互的语言问题的一门学科。处理自然语言的关键是要让计算机"理解"自然语言，所以自然语言处理又叫做自然语言理解(NLU，Natural Language Understanding)，也称为计算语言学(Computational Linguistics。一方面它是语言信息处理的一个分支，另一方面它是人工智能(AI, Artificial Intelligence)的核心课题之一。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<a style="margin: 0px; color: #173abd; text-decoration: none;" title="统计分析" href="http://wiki.mbalib.com/wiki/%E7%BB%9F%E8%AE%A1%E5%88%86%E6%9E%90">统计分析</a>：<a style="margin: 0px; color: #173abd; text-decoration: none;" title="假设检验" href="http://wiki.mbalib.com/wiki/%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C">假设检验</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="显著性检验" href="http://wiki.mbalib.com/wiki/%E6%98%BE%E8%91%97%E6%80%A7%E6%A3%80%E9%AA%8C">显著性检验</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="差异分析" href="http://wiki.mbalib.com/wiki/%E5%B7%AE%E5%BC%82%E5%88%86%E6%9E%90">差异分析</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="相关分析" href="http://wiki.mbalib.com/wiki/%E7%9B%B8%E5%85%B3%E5%88%86%E6%9E%90">相关分析</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="T检验" href="http://wiki.mbalib.com/wiki/T%E6%A3%80%E9%AA%8C">T检验</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="方差分析" href="http://wiki.mbalib.com/wiki/%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90">方差分析</a>、卡方分析、偏相关分析、距离分析、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="回归分析" href="http://wiki.mbalib.com/wiki/%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90">回归分析</a>、简单回归分析、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="多元回归分析" href="http://wiki.mbalib.com/wiki/%E5%A4%9A%E5%85%83%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90">多元回归分析</a>、逐步回归、回归预测与残差分析、岭回归、logistic回归分析、曲线估计、因子分析、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="聚类分析" href="http://wiki.mbalib.com/wiki/%E8%81%9A%E7%B1%BB%E5%88%86%E6%9E%90">聚类分析</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="主成分分析" href="http://wiki.mbalib.com/wiki/%E4%B8%BB%E6%88%90%E5%88%86%E5%88%86%E6%9E%90">主成分分析</a>、因子分析、快速聚类法与聚类法、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="判别分析" href="http://wiki.mbalib.com/wiki/%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90">判别分析</a>、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="对应分析" href="http://wiki.mbalib.com/wiki/%E5%AF%B9%E5%BA%94%E5%88%86%E6%9E%90">对应分析</a>、多元对应分析（最优尺度分析）、bootstrap技术等等。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据挖掘" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98">数据挖掘</a>：分类 （Classification）、估计（Estimation）、预测（Prediction）、相关性分组或关联规则（Affinity grouping or association rules）、聚类（Clustering）、描述和可视化、Description and Visualization）、复杂数据类型挖掘(Text, <a style="margin: 0px; color: #173abd; text-decoration: none;" title="Web" href="http://wiki.mbalib.com/wiki/Web">Web</a> ,图形图像，视频，音频等)</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　模型预测：预测模型、机器学习、建模仿真。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　结果呈现：云计算、标签云、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="关系图" href="http://wiki.mbalib.com/wiki/%E5%85%B3%E7%B3%BB%E5%9B%BE">关系图</a>等。
<span style="margin: 0px; font-weight: bolder;">1. 大数据处理之一：采集</span></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">

<a class="headline" style="margin: 0px; color: #2153b0;" name=".E5.A4.A7.E6.95.B0.E6.8D.AE.E7.9A.84.E5.A4.84.E7.90.86"></a>
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的处理</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　大数据的采集是指利用多个数据库来接收发自客户端（Web、App或者传感器形式等）的数据，并且用户可以通过这些数据库来进行简单的查询和处理工作。比如，电商会使用传统的关系型数据库MySQL和<a style="margin: 0px; color: #173abd; text-decoration: none;" title="Oracle" href="http://wiki.mbalib.com/wiki/Oracle">Oracle</a>等来存储每一笔事务数据，除此之外，Redis和MongoDB这样的NoSQL数据库也常用于数据的采集。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　在大数据的采集过程中，其主要特点和挑战是并发数高，因为同时有可能会有成千上万的用户来进行访问和操作，比如火车票售票网站和<a style="margin: 0px; color: #173abd; text-decoration: none;" title="淘宝" href="http://wiki.mbalib.com/wiki/%E6%B7%98%E5%AE%9D">淘宝</a>，它们并发的访问量在峰值时达到上百万，所以需要在采集端部署大量数据库才能支撑。并且如何在这些<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据库" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E5%BA%93">数据库</a>之间进行负载均衡和分片的确是需要深入的思考和设计。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">2. 大数据处理之二：导入/预处理</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　虽然采集端本身会有很多数据库，但是如果要对这些海量数据进行有效的分析，还是<a style="margin: 0px; color: #173abd; text-decoration: none;" title="应该" href="http://wiki.mbalib.com/wiki/%E5%BA%94%E8%AF%A5">应该</a>将这些来自前端的数据导入到一个集中的大型分布式数据库，或者分布式存储集群，并且可以在导入基础上做一些简单的清洗和预处理工作。也有一些用户会在导入时使用来自<a style="margin: 0px; color: #173abd; text-decoration: none;" title="Twitter" href="http://wiki.mbalib.com/wiki/Twitter">Twitter</a>的Storm来对数据进行流式计算，来满足部分业务的实时计算需求。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　导入与预处理过程的特点和挑战主要是导入的数据量大，每秒钟的导入量经常会达到百兆，甚至千兆级别。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">3. 大数据处理之三：统计/分析</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　统计与分析主要利用分布式数据库，或者分布式计算集群来对存储于其内的海量数据进行普通的分析和分类汇总等，以满足大多数常见的分析需求，在这方面，一些实时性需求会用到<a style="margin: 0px; color: #173abd; text-decoration: none;" title="EMC" href="http://wiki.mbalib.com/wiki/EMC">EMC</a>的GreenPlum、Oracle的Exadata，以及基于MySQL的列式存储Infobright等，而一些批处理，或者基于半结构化数据的需求可以使用Hadoop。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　统计与分析这部分的主要特点和挑战是分析涉及的数据量大，其对系统资源，特别是I/O会有极大的占用。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">4. 大数据处理之四：挖掘</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　与前面统计和分析过程不同的是，数据挖掘一般没有什么预先设定好的主题，主要是在现有数据上面进行基于各种算法的计算，从而起到预测（Predict）的效果，从而实现一些高级别数据分析的需求。比较典型算法有用于聚类的Kmeans、用于统计学习的SVM和用于分类的NaiveBayes，主要使用的工具有Hadoop的Mahout等。该过程的特点和挑战主要是用于挖掘的算法很复杂，并且计算涉及的数据量和计算量都很大，常用数据挖掘算法都以单线程为主。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　整个大数据处理的普遍流程至少应该满足这四个方面的步骤，才能算得上是一个比较完整的大数据处理。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据的常见误解</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">一、数据不等于<a style="margin: 0px; color: #173abd; text-decoration: none;" title="信息" href="http://wiki.mbalib.com/wiki/%E4%BF%A1%E6%81%AF">信息</a></span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　经常有人把数据和信息当作同义词来用。其实不然，数据指的是一个原始的数据点（无论是通过数字，文字，图片还是视频等等），信息则直接与内容挂钩，需要有资讯性（informative）。数据越多，不一定就能代表信息越多，更能不能代表信息就会成比例增多。有两个简单的例子：</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　备份。很多人如今已经会定期的对自己的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="硬盘" href="http://wiki.mbalib.com/wiki/%E7%A1%AC%E7%9B%98">硬盘</a>进行备份。这个没什么好多解释的，每次备份都会创造出一组新的数据，但信息并没有增多。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　多个社交网站上的信息。我们当中的很多人在多个社交网站上活跃，随着我们上的社交网站越多，我们获得的数据就会成比例的增多，我们获得的信息虽然也会增多，但却不会成比例的增多。不单单因为我们会互相转发好友的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="微博" href="http://wiki.mbalib.com/wiki/%E5%BE%AE%E5%8D%9A">微博</a>（或者其他社交网站上的内容），更因为很多内容会十分类似，有些<a style="margin: 0px; color: #173abd; text-decoration: none;" title="微博" href="http://wiki.mbalib.com/wiki/%E5%BE%AE%E5%8D%9A">微博</a>虽然具体文字不同，但表达的内容十分相似。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">二、信息不等于智慧（Insight）</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　现在我们去除了数据中所有重复的部分，也<a style="margin: 0px; color: #173abd; text-decoration: none;" title="整合" href="http://wiki.mbalib.com/wiki/%E6%95%B4%E5%90%88">整合</a>了内容类似的数据，现在我们剩下的全是信息了，这对我们就一定有用吗？不一定，信息要能转化成智慧，至少要满足一下三个标准：</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　可破译性。这可能是个大数据时代特有的问题，越来越多的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="企业" href="http://wiki.mbalib.com/wiki/%E4%BC%81%E4%B8%9A">企业</a>每天都会<a style="margin: 0px; color: #173abd; text-decoration: none;" title="生产" href="http://wiki.mbalib.com/wiki/%E7%94%9F%E4%BA%A7">生产</a>出大量的数据，却还没想好怎么用，因此，他们就将这些数据暂时非结构化（unstructured）的存储起来。这些非结构化的数据却不一定可破译。比如说，你记录了某<a style="margin: 0px; color: #173abd; text-decoration: none;" title="客户" href="http://wiki.mbalib.com/wiki/%E5%AE%A2%E6%88%B7">客户</a>在你网站上三次翻页的时间间隔：3秒，2秒，17秒，却忘记标注这三个时间到底代表了什么，这些数据是信息（非重复性），却不可破译，因此不可能成为智慧。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　关联性。无关的信息，至多只是噪音。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　新颖性。这里的新颖性很多时候无法仅仅根据我们手上的数据和信息进行判断。举个例子，某电子商务公司通过一组数据/信息，分析出了客户愿意为当天送货的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="产品" href="http://wiki.mbalib.com/wiki/%E4%BA%A7%E5%93%81">产品</a>多支付10块钱，然后又通过另一组完全独立的数据/信息得到了同样的内容，这样的情况下，后者就不具备新颖性。不幸的是，很多时候，我们只有在处理了大量的数据和信息以后，才能判断它们的新颖性。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据时代存储所面对的问题</h2>
</div>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　随着大数据应用的爆发性增长，它已经衍生出了自己独特的架构，而且也直接推动了存储、网络以及计算技术的发展。毕竟处理大数据这种特殊的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="需求" href="http://wiki.mbalib.com/wiki/%E9%9C%80%E6%B1%82">需求</a>是一个新的挑战。硬件的发展最终还是由软件需求推动的，就这个例子来说，我们很明显的看到大数据分析应用需求正在影响着数据存储基础设施的发展。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　从另一方面看，这一变化对存储厂商和其他IT基础设施厂商未尝不是一个机会。随着结构化数据和非结构化数据量的持续增长，以及分析数据来源的多样化，此前存储系统的设计已经无法满足大数据应用的需要。存储厂商已经意识到这一点，他们开始修改基于块和文件的存储系统的架构设计以适应这些新的要求。在这里，我们会讨论哪些与大数据存储基础设施相关的属性，看看它们如何迎接大数据的挑战。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">容量问题</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　这里所说的“大容量”通常可达到PB级的数据规模，因此，海量数据存储系统也一定要有相应等级的扩展能力。与此同时，存储系统的扩展一定要简便，可以通过增加模块或磁盘柜来增加容量，甚至不需要停机。基于这样的需求，客户现在越来越青睐Scale-out架构的存储。Scale-out集群结构的特点是每个节点除了具有一定的存储容量之外，内部还具备数据处理能力以及互联设备，与传统存储系统的烟囱式架构完全不同，Scale-out架构可以实现无缝平滑的扩展，避免存储孤岛。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　“大数据”应用除了数据规模巨大之外，还意味着拥有庞大的文件数量。因此如何管理文件系统层累积的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="元数据" href="http://wiki.mbalib.com/wiki/%E5%85%83%E6%95%B0%E6%8D%AE">元数据</a>是一个难题，处理不当的话会影响到系统的扩展能力和性能，而传统的NAS系统就存在这一瓶颈。所幸的是，基于对象的存储架构就不存在这个问题，它可以在一个系统中管理十亿级别的文件数量，而且还不会像传统存储一样遭遇元数据管理的困扰。基于对象的存储系统还具有广域扩展能力，可以在多个不同的地点部署并组成一个跨区域的大型存储基础架构。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">延迟问题</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　“大数据”应用还存在实时性的问题。特别是涉及到与<a style="margin: 0px; color: #173abd; text-decoration: none;" title="网上交易" href="http://wiki.mbalib.com/wiki/%E7%BD%91%E4%B8%8A%E4%BA%A4%E6%98%93">网上交易</a>或者金融类相关的应用。举个例子来说，网络成衣销售行业的在线广告推广服务需要实时的对客户的浏览记录进行分析，并<a style="margin: 0px; color: #173abd; text-decoration: none;" title="准确" href="http://wiki.mbalib.com/wiki/%E5%87%86%E7%A1%AE">准确</a>的进行<a style="margin: 0px; color: #173abd; text-decoration: none;" title="广告投放" href="http://wiki.mbalib.com/wiki/%E5%B9%BF%E5%91%8A%E6%8A%95%E6%94%BE">广告投放</a>。这就要求存储系统在必须能够支持上述特性同时保持较高的响应速度，因为响应延迟的结果是系统会推送“过期”的广告内容给客户。这种场景下，Scale-out架构的存储系统就可以发挥出优势，因为它的每一个节点都具有处理和互联组件，在增加容量的同时处理能力也可以同步增长。而基于对象的存储系统则能够支持并发的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据流" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E6%B5%81">数据流</a>，从而进一步提高数据吞吐量。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　有很多“大数据”应用环境需要较高的IOPS性能(IOPS (Input/Output Operations Per Second)，即每秒进行读写（I/O）操作的次数，多用于数据库等场合，衡量随机访问的性能)，比如HPC高性能计算。此外，服务器虚拟化的普及也导致了对高IOPS的需求，正如它改变了传统IT环境一样。为了迎接这些挑战，各种模式的固态存储设备应运而生，小到简单的在服务器内部做高速缓存，大到全固态介质的可扩展存储系统等等都在蓬勃发展。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　并发访问一旦企业认识到大数据分析应用的潜在价值，他们就会将更多的数据集纳入系统进行比较，同时让更多的人分享并使用这些数据。为了创造更多的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="商业价值" href="http://wiki.mbalib.com/wiki/%E5%95%86%E4%B8%9A%E4%BB%B7%E5%80%BC">商业价值</a>，企业往往会综合分析那些来自不同平台下的多种数据对象。包括全局文件系统在内的存储基础设施就能够帮助用户解决数据访问的问题，全局文件系统允许多个主机上的多个用户并发访问文件数据，而这些数据则可能存储在多个地点的多种不同类型的存储设备上。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">安全问题</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　某些特殊行业的应用，比如金融数据、医疗信息以及政府情报等都有自己的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="安全标准" href="http://wiki.mbalib.com/wiki/%E5%AE%89%E5%85%A8%E6%A0%87%E5%87%86">安全标准</a>和保密性需求。虽然对于IT管理者来说这些并没有什么不同，而且都是必须遵从的，但是，大数据分析往往需要多类数据相互参考，而在过去并不会有这种数据混合访问的情况，因此大数据应用也催生出一些新的、需要考虑的安全性问题。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">成本问题</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　“大”，也可能意味着代价不菲。而对于那些正在使用大数据环境的企业来说，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="成本控制" href="http://wiki.mbalib.com/wiki/%E6%88%90%E6%9C%AC%E6%8E%A7%E5%88%B6">成本控制</a>是关键的问题。想控制成本，就意味着我们要让每一台设备都实现更高的“效率”，同时还要减少那些昂贵的部件。目前，像重复数据删除等技术已经进入到主存储市场，而且现在还可以处理更多的数据类型，这都可以为大数据存储应用带来更多的价值，提升存储效率。在数据量不断增长的环境中，通过减少后端存储的消耗，哪怕只是降低几个百分点，都能够获得明显的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="投资回报" href="http://wiki.mbalib.com/wiki/%E6%8A%95%E8%B5%84%E5%9B%9E%E6%8A%A5">投资回报</a>。此外，自动精简配置、快照和克隆技术的使用也可以提升存储的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="效率" href="http://wiki.mbalib.com/wiki/%E6%95%88%E7%8E%87">效率</a>。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　很多大数据存储系统都包括归档组件，尤其对那些需要分析历史数据或需要长期保存数据的机构来说，归档设备必不可少。从单位容量存储成本的角度看，磁带仍然是最经济的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="存储介质" href="http://wiki.mbalib.com/wiki/%E5%AD%98%E5%82%A8%E4%BB%8B%E8%B4%A8">存储介质</a>，事实上，在许多企业中，使用支持TB级大容量磁带的归档系统仍然是事实上的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="标准" href="http://wiki.mbalib.com/wiki/%E6%A0%87%E5%87%86">标准</a>和惯例。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　对成本控制影响最大的因素是那些商业化的硬件设备。因此，很多初次进入这一领域的用户以及那些应用规模最大的用户都会定制他们自己的“硬件平台”而不是用现成的商业产品，这一举措可以用来平衡他们在业务扩展过程中的成本控制战略。为了适应这一需求，现在越来越多的存储产品都提供纯软件的形式，可以直接安装在用户已有的、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="通用" href="http://wiki.mbalib.com/wiki/%E9%80%9A%E7%94%A8">通用</a>的或者现成的硬件设备上。此外，很多存储软件公司还在<a style="margin: 0px; color: #173abd; text-decoration: none;" title="销售" href="http://wiki.mbalib.com/wiki/%E9%94%80%E5%94%AE">销售</a>以软件产品为核心的软硬一体化装置，或者与硬件厂商结盟，推出合作型产品。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">数据的积累</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　许多大数据应用都会涉及到法规遵从问题，这些法规通常要求数据要保存几年或者几十年。比如医疗信息通常是为了保证患者的生命安全，而<a style="margin: 0px; color: #173abd; text-decoration: none;" title="财务信息" href="http://wiki.mbalib.com/wiki/%E8%B4%A2%E5%8A%A1%E4%BF%A1%E6%81%AF">财务信息</a>通常要保存7年。而有些使用大数据存储的用户却希望数据能够保存更长的时间，因为任何数据都是历史记录的一部分，而且数据的分析大都是基于时间段进行的。要实现长期的数据保存，就要求存储厂商开发出能够持续进行数据一致性检测的功能以及其他保证长期高可用的特性。同时还要实现数据直接在原位更新的功能需求。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">灵活性</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　大数据存储系统的基础设施规模通常都很大，因此必须经过仔细设计，才能<a style="margin: 0px; color: #173abd; text-decoration: none;" title="保证" href="http://wiki.mbalib.com/wiki/%E4%BF%9D%E8%AF%81">保证</a>存储系统的灵活性，使其能够随着应用分析软件一起扩容及扩展。在大数据存储环境中，已经没有必要再做<a style="margin: 0px; color: #173abd; text-decoration: none;" title="数据迁移" href="http://wiki.mbalib.com/wiki/%E6%95%B0%E6%8D%AE%E8%BF%81%E7%A7%BB">数据迁移</a>了，因为数据会同时保存在多个部署站点。一个大型的数据存储基础设施一旦开始投入使用，就很难再调整了，因此它必须能够适应各种不同的应用类型和数据场景。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">应用感知</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　最早一批使用大数据的用户已经开发出了一些针对应用的定制的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="基础设施" href="http://wiki.mbalib.com/wiki/%E5%9F%BA%E7%A1%80%E8%AE%BE%E6%96%BD">基础设施</a>，比如针对政府项目开发的系统，还有大型互联网服务商创造的专用服务器等。在主流存储系统领域，应用感知技术的使用越来越普遍，它也是改善系统效率和性能的重要手段，所以，应用感知技术也应该用在大数据存储环境里。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　<span style="margin: 0px; font-weight: bolder;">小用户怎么办？</span></p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　依赖大数据的不仅仅是那些特殊的大型用户群体，作为一种商业需求，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="小型企业" href="http://wiki.mbalib.com/wiki/%E5%B0%8F%E5%9E%8B%E4%BC%81%E4%B8%9A">小型企业</a>未来也一定会应用到大数据。我们看到，有些存储厂商已经在开发一些小型的“大数据”存储系统，主要吸引那些对成本比较敏感的用户。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"></p>

<div class="headline-2" style="margin: 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">
<h2 style="margin-top: 1.5em; margin-bottom: 0.25em; font-weight: bold; font-size: 1.4em; unicode-bidi: embed; border-bottom-width: 1px; border-bottom-style: solid; border-bottom-color: #cec39c; line-height: 1.4em; padding-bottom: 0.2em;">大数据应用与案例分析</h2>
</div>
<dl style="margin-top: 0.2em; margin-bottom: 0.5em; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"><dt style="margin: 0px 0px 0.1em; unicode-bidi: embed;">　　1. 大数据应用案例之：医疗行业</dt></dl>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[1] Seton Healthcare是采用<a style="margin: 0px; color: #173abd; text-decoration: none;" title="IBM" href="http://wiki.mbalib.com/wiki/IBM">IBM</a>最新沃森技术医疗保健内容分析预测的首个客户。该技术允许企业找到大量病人相关的临床医疗信息，通过大数据处理，更好地分析病人的信息。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[2] 在加拿大多伦多的一家医院，针对早产婴儿，每秒钟有超过3000次的数据读取。通过这些数据分析，医院能够提前知道哪些早产儿出现问题并且有针对性地采取措施，避免早产婴儿夭折。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[3] 它让更多的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="创业者" href="http://wiki.mbalib.com/wiki/%E5%88%9B%E4%B8%9A%E8%80%85">创业者</a>更方便地开发产品，比如通过社交网络来收集数据的健康类App。也许未来数年后，它们搜集的数据能让医生给你的诊断变得更为精确，比方说不是通用的成人每日三次一次一片，而是检测到你的血液中药剂已经代谢完成会自动提醒你再次服药。</p>

<dl style="margin-top: 0.2em; margin-bottom: 0.5em; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"><dt style="margin: 0px 0px 0.1em; unicode-bidi: embed;">　　2. 大数据应用案例之：能源行业</dt></dl>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[1] <a style="margin: 0px; color: #173abd; text-decoration: none;" title="智能电网" href="http://wiki.mbalib.com/wiki/%E6%99%BA%E8%83%BD%E7%94%B5%E7%BD%91">智能电网</a>现在欧洲已经做到了<a style="margin: 0px; color: #173abd; text-decoration: none;" title="终端" href="http://wiki.mbalib.com/wiki/%E7%BB%88%E7%AB%AF">终端</a>，也就是所谓的智能电表。在德国，为了鼓励利用太阳能，会在家庭安装太阳能，除了卖电给你，当你的太阳能有多余电的时候还可以买回来。通过电网收集每隔五分钟或十分钟收集一次数据，收集来的这些数据可以用来预测客户的用电习惯等，从而推断出在未来2~3个月时间里，整个电网大概需要多少电。有了这个预测后，就可以向发电或者供电企业购买一定数量的电。因为电有点像期货一样，如果提前买就会比较便宜，买现货就比较贵。通过这个预测后，可以降低<a style="margin: 0px; color: #173abd; text-decoration: none;" title="采购成本" href="http://wiki.mbalib.com/wiki/%E9%87%87%E8%B4%AD%E6%88%90%E6%9C%AC">采购成本</a>。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[2] 维斯塔斯风力系统，依靠的是BigInsights软件和IBM超级计算机，然后对气象数据进行分析，找出安装风力涡轮机和整个风电场最佳的地点。利用大数据，以往需要数周的分析工作，现在仅需要不足1小时便可完成。</p>

<dl style="margin-top: 0.2em; margin-bottom: 0.5em; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"><dt style="margin: 0px 0px 0.1em; unicode-bidi: embed;">　　3. 大数据应用案例之：通信行业</dt></dl>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[1] XO Communications通过使用IBM SPSS预测分析软件，减少了将近一半的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="客户流失率" href="http://wiki.mbalib.com/wiki/%E5%AE%A2%E6%88%B7%E6%B5%81%E5%A4%B1%E7%8E%87">客户流失率</a>。XO现在可以预测客户的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="行为" href="http://wiki.mbalib.com/wiki/%E8%A1%8C%E4%B8%BA">行为</a>，发现行为趋势，并找出存在缺陷的环节，从而帮助公司及时采取措施，<a style="margin: 0px; color: #173abd; text-decoration: none;" title="保留客户" href="http://wiki.mbalib.com/wiki/%E4%BF%9D%E7%95%99%E5%AE%A2%E6%88%B7">保留客户</a>。此外，IBM新的Netezza网络分析加速器，将通过提供单个端到端网络、<a style="margin: 0px; color: #173abd; text-decoration: none;" title="服务" href="http://wiki.mbalib.com/wiki/%E6%9C%8D%E5%8A%A1">服务</a>、客户分析视图的可扩展平台，帮助通信企业制定更科学、合理决策。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[2] 电信业者透过数以千万计的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="客户资料" href="http://wiki.mbalib.com/wiki/%E5%AE%A2%E6%88%B7%E8%B5%84%E6%96%99">客户资料</a>，能分析出多种使用者行为和<a style="margin: 0px; color: #173abd; text-decoration: none;" title="趋势" href="http://wiki.mbalib.com/wiki/%E8%B6%8B%E5%8A%BF">趋势</a>，卖给需要的企业，这是全新的资料经济。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[3] <a style="margin: 0px; color: #173abd; text-decoration: none;" title="中国移动" href="http://wiki.mbalib.com/wiki/%E4%B8%AD%E5%9B%BD%E7%A7%BB%E5%8A%A8">中国移动</a>通过大数据分析，对企业运营的全业务进行针对性的监控、预警、跟踪。系统在第一时间自动捕捉市场变化，再以最快捷的方式推送给指定负责人，使他在最短时间内获知市场行情。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[4] NTT docomo(日本最大的移动通信运营商，拥有超过6千万的签约用户)把手机位置信息和互联网上的信息结合起来，为<a style="margin: 0px; color: #173abd; text-decoration: none;" title="顾客" href="http://wiki.mbalib.com/wiki/%E9%A1%BE%E5%AE%A2">顾客</a>提供附近的餐饮店信息，接近末班车时间时，提供末班车信息服务。</p>

<dl style="margin-top: 0.2em; margin-bottom: 0.5em; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;"><dt style="margin: 0px 0px 0.1em; unicode-bidi: embed;">　　4. 大数据应用案例之：<a style="margin: 0px; color: #2153b0; text-decoration: none;" title="零售业" href="http://wiki.mbalib.com/wiki/%E9%9B%B6%E5%94%AE%E4%B8%9A">零售业</a></dt></dl>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[1] "我们的某个客户，是一家领先的专业时装零售商，通过当地的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="百货商店" href="http://wiki.mbalib.com/wiki/%E7%99%BE%E8%B4%A7%E5%95%86%E5%BA%97">百货商店</a>、网络及其邮购目录业务为客户提供服务。公司希望向客户提供<a style="margin: 0px; color: #173abd; text-decoration: none;" title="差异化服务" href="http://wiki.mbalib.com/wiki/%E5%B7%AE%E5%BC%82%E5%8C%96%E6%9C%8D%E5%8A%A1">差异化服务</a>，如何定位公司的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="差异化" href="http://wiki.mbalib.com/wiki/%E5%B7%AE%E5%BC%82%E5%8C%96">差异化</a>，他们通过从 Twitter 和<a style="margin: 0px; color: #173abd; text-decoration: none;" title="Facebook" href="http://wiki.mbalib.com/wiki/Facebook">Facebook</a> 上收集社交信息，更深入的理解化妆品的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="营销模式" href="http://wiki.mbalib.com/wiki/%E8%90%A5%E9%94%80%E6%A8%A1%E5%BC%8F">营销模式</a>，随后他们认识到必须保留两类有价值的客户：高消费者和高影响者。希望通过接受免费化妆服务，让用户进行口碑宣传，这是交易数据与交互数据的完美结合，为业务挑战提供了解决方案。"Informatica的技术帮助这家零售商用社交平台上的数据充实了客户主数据，使他的业务服务更具有目标性。</p>
<p style="margin: 1em 0px; unicode-bidi: embed; color: #333333; font-family: sans-serif; font-size: 14px; line-height: 19.488000869750977px;">　　[2] <a style="margin: 0px; color: #173abd; text-decoration: none;" title="零售企业" href="http://wiki.mbalib.com/wiki/%E9%9B%B6%E5%94%AE%E4%BC%81%E4%B8%9A">零售企业</a>也监控客户的店内走动情况以及与<a style="margin: 0px; color: #173abd; text-decoration: none;" title="商品" href="http://wiki.mbalib.com/wiki/%E5%95%86%E5%93%81">商品</a>的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="互动" href="http://wiki.mbalib.com/wiki/%E4%BA%92%E5%8A%A8">互动</a>。它们将这些数据与交易记录相结合来展开分析，从而在销售哪些商品、如何摆放货品以及何时调整售价上给出意见，此类方法已经帮助某领先零售企业减少了17%的<a style="margin: 0px; color: #173abd; text-decoration: none;" title="存货" href="http://wiki.mbalib.com/wiki/%E5%AD%98%E8%B4%A7">存货</a>，同时在保持市场份额的前提下，增加了高利润率自有品牌商品的比例。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>106</wp:post_id>
		<wp:post_date>2014-07-03 11:16:41</wp:post_date>
		<wp:post_date_gmt>2014-07-03 03:16:41</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%a4%a7%e6%95%b0%e6%8d%aebig-data</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%91%e8%ae%a1%e7%ae%97"><![CDATA[云计算]]></category>
		<category domain="category" nicename="big-data"><![CDATA[大数据]]></category>
		<category domain="post_tag" nicename="%e5%a4%a7%e6%95%b0%e6%8d%ae"><![CDATA[大数据]]></category>
	</item>
	<item>
				<title>为什么要&quot;去IOE&quot; </title>
		<link>http://localhost:81/wordpress/?p=115</link>
		<pubDate>Thu, 03 Jul 2014 04:44:22 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=115</guid>
		<description></description>
		<content:encoded><![CDATA[<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">2013 年5月17日，阿里集团最后一台IBM小机在支付宝下线。这是自2009年“去IOE”战略透露以来，“去IOE”非常重要的一个节点。“去 IOE”指的是摆脱掉IT部署中原有的IBM小型机、Oracle数据库以及EMC存储的过度依赖。告别最后一台小机，意味着整个阿里集团尽管还有一些 Oracle数据库和EMC存储，但是IBM小型机已全部被替换。2013年7月10日，淘宝重中之重的广告系统使用的Oracle数据库下线，也是整个 淘宝最后一个 Oracle数据库。这两件事合在一起是阿里巴巴技术发展过程中的一个重要里程碑。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><img src="http://img.blog.csdn.net/20140313200659703" alt="" width="356" height="237" /></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><strong>何谓IOE？</strong></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">IOE 这个说法来自阿里技术团队内部的称谓，然后才在整个业界流传开来。IOE是传统IT三大件，指以 IBM 、Oracle、EMC 为代表的小型机、集中式数据库和高端存储的技术架构。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><strong>I</strong> 指 IBM p 系列小型机，操作系统是 AIX（IBM 专有的 Unix 系统）；</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><strong>O</strong> 指 Oracle 数据库(RDBMS)；</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><strong>E</strong> 指 EMC 中高端 SAN 存储。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><img src="http://img.blog.csdn.net/20140313200736859" alt="" width="417" height="210" /></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;"><strong>为什么要去IOE?</strong></div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">阿里巴巴过去一直采用的是Oracle数据库，并利用小型机和高端存储设备提供高性能的数据处理和存储服务。随着业务的不断发展，数据量和业务量呈爆发性增长，传统的集中式Oracle数据库架构在扩展性方面遭遇瓶颈。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">传统的商业数据库软件(Oracle,DB2)，多以集中式架构为主，这些<strong>传统数据库软件的最大特点就是将所有的数据都集中在一个数据库中，依靠大型高端设备来提供高处理能力和扩展性。集中式数据库的扩展性主要采用向上扩展(Scale up)的方式，通过增加CPU，内存，磁盘等方式提高处理能力</strong>。这种集中式数据库的架构，使得数据库成为了整个系统的瓶颈，已经越来越不适应海量数据对计算能力的巨大需求。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">
<div></div>
<div>传 统架构在主机端大多通过两台主机共享存储设备，平时其中一台主机使用存储通过数据库软件来管理。这样的架构只能有一台主机(RAC除外)上的数据库能够提 供服务，另一台主机只能是作为热备冗余，不能启动数据库实例提供服务。所以，其处理能力就完全取决于这台主机的最大扩展能力，很难通过增加主机数量来增加 处理能力。而单台主机的扩展能力毕竟是有限的，即使是某些厂商的大型机，同样也有其扩展限制。此外，传统架构对高端设备的依赖，无疑将直接导致系统成本的 大幅度增加，甚至可能会导致系统被主机和硬件厂商所“绑架”，不得不持续增加投入成本。</div>
<div></div>
</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">在 阿里看来，“IOE”实际上代表了一种高成本、高维护费、很不互联网(不擅长处理大规模高并发的互联网行为)的商用数据库系统，特别是阿里盘子越来越大， 所需要付出的升级硬件和维护的代价也会越来越惊人，阿里巴巴采用数据切分(sharding)的策略，将部分海量数据应用<strong>从集中式Oracle切换到分布式MySQL集群，从纵向扩展到水平扩展，解决了数据库扩展性的问题</strong>， 并用PC服务器替换了小型机。事实上，这里可以做一个不那么技术但比较简单的理解：传统的IOE代表的是集中式架构，而去IOE化其实就是推动分布式架构 代替集中式架构，也就是更好的拥抱云计算—当然对阿里本身来说，用通俗的语言解读出阿里云甚至阿里的IT计算(甚至商业模式)发展路径：</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">1、鉴于类似双11这种超大规模并发行为的产生，背后需要的计算资源非常庞大，所以整个阿里对IT资源的投入都是非常大的。
2、当投入大量的资源应对高峰期高并发时，低峰低并发时就造成了计算资源的冗余，这个时候就可以以云计算的方式出租给中小企业。而当然企业就可能有更高的野心，比如把云计算作为主要的商业模式。但是对于那些对计算要求很高的公司，还不够。</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">

软件决定整体架构，如果要动O，那么I和E就必须要动 – 相信不会有人在小型机上跑 MySQL 的。

</div>
<div style="color: #000000; font-family: Tahoma; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: -webkit-auto; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; font-size: 14px;">
<img src="http://img.blog.csdn.net/20140313200754750" alt="" width="364" height="326" />

</div>
<div><strong>Oracle RAC不能满足扩展要求么？</strong>
转自：<a href="http://www.hellodb.net/2010/07/database_scalability.html" target="_blank">可扩展的分布式数据库架构</a></div>
<div>几乎每个数据库产品都有集群解决方案，Oracle RAC是业界最流行的产品。其架构的最大特点是共享存储架构（Shared-disk），整个RAC集群是建立在一个共享的存储设备之上的，节点之间采用高速网络互连。<strong>Oracle RAC提供了非常好的高可用特性</strong>，比如负载均衡和应用透明切换(TAF)，其最大优势在于对应用完全透明，应用无需修改便可以切换到RAC集群。但是，<strong>RAC的扩展能力有限，首先因为整个集群都依赖于底层的共享存储，所以共享存储的IO能力和可用性决定了整个集群的可以提供的能力</strong>， 其依然无法摆脱对 大型存储设备的依赖。Oracle显然也意识到了这个问题，在Oracle的MAA(Maximum Availability Architecture)架构中，采用ASM来整合多个存储设备的能力，使得RAC底层的共享存储也具备线性扩展的能力，整个集群不再依赖于大型存储的 处理能力和可用性。</div>
<strong>RAC的另外一个问题是，随着节点数的不断增加，节点间通信的成本也会随之增加，当到达某个限度时，增加节点可能不会 再带来性能上的提高，甚至可能造成性能下降。</strong>这 个问题的主要原因是Oracle RAC对应用透明，应用可以连接集群中的任意节点进行处理，当不同节点上的应用争用资源时，RAC节点间的通信开销会严重影响集群的处理能力。所以使用 Oracle RAC有两个建议：1.节点间通信使用高速互联网络；2.尽可能将不同的应用分布在不同的节点上。基于这个原因，Oracle RAC通常在DSS环境中可以做到很好的扩展性，因为DSS环境很容易将不同的任务分布在不同的计算节点上，而对于OLTP应用，Oracle RAC更多情况下是用来提高可用性，而不是为了提高扩展性。

&nbsp;

转载原文：http://blog.csdn.net/pan_tian/article/details/21186307]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>115</wp:post_id>
		<wp:post_date>2014-07-03 12:44:22</wp:post_date>
		<wp:post_date_gmt>2014-07-03 04:44:22</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%ba%e4%bb%80%e4%b9%88%e8%a6%81%e5%8e%bbioe</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="emc"><![CDATA[EMC]]></category>
		<category domain="post_tag" nicename="ibm"><![CDATA[IBM]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="oracle-db"><![CDATA[Oracle DB]]></category>
		<category domain="category" nicename="architecture"><![CDATA[架构&amp;框架]]></category>
		<category domain="post_tag" nicename="%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4"><![CDATA[阿里巴巴]]></category>
	</item>
	<item>
				<title>淘宝技术发展</title>
		<link>http://localhost:81/wordpress/?p=117</link>
		<pubDate>Thu, 03 Jul 2014 07:22:32 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=117</guid>
		<description></description>
		<content:encoded><![CDATA[目录

一、引言

二、个人网站

三、Oracle/支付宝/旺旺

四、淘宝技术发展（Java时代：脱胎换骨）

五、淘宝技术发展（Java时代：坚若磐石）

六、淘宝技术发展（Java时代：创造技术-TFS）

七、淘宝技术发展（分布式时代：服务化）

作者：赵超

<a name="c1"></a><strong>一、引言</strong>

<strong>　　光棍节的狂欢</strong>

“时间到，开抢！”坐在电脑前早已等待多时的小美一看时间已到 2011 年 11 月 11 日零时，便迫不及待地投身于淘宝商城一年一度的大型网购促销活动 —— “淘宝双11购物狂欢节”。小美打开早已收藏好的宝贝 —— 某品牌的雪地靴，飞快的点击购买，付款，一回头发现 3000 双靴子已被抢购一空。

小美跳起来，大叫一声“欧耶！”

小美不知道，就在 11 日零点过后的这一分钟内，全国有 342 万人和她一起涌入淘宝商城。当然，她更不知道，此时此刻，在淘宝杭州的一间办公室里，灯火通明，这里是“战时指挥部”，淘宝技术部的一群工程师，正在紧盯 着网站的流量和交易数据。白板上是他们刚刚下的注，赌谁能最准确地猜中流量峰值和全天的交易总额。他们的手边放着充足的食物和各类提神的饮料。

一阵急促的电话声响起来，是前线部门询问数据的，工程师大声报着：“第 1 分钟，进入淘宝商城的会员有 342 万”。过一会工程师主动拿起电话：“交易额超过 1 亿了，现在是第 8 分钟。”接下来，“第 21 分钟，刚突破 2 亿”。“第 32 分钟，3 亿了”。“第 1 个小时，4.39 亿”。这些数据随后出现在微博上，引起一片惊呼。

“完蛋了！”突然有人大喝一声，所有的眼睛都紧张的盯着他，只见他挠挠头，嘿嘿的笑道“我赌的少了，20 亿轻松就能过了，我再加 5 亿”，他跑去白板边上把自己的赌注擦去，写上 25，接下来有人写上 28，有人写上 30，有人跑到微博上开下盘口，同事们纷纷转载下注。接下来的这 24 个小时，战时指挥部的工程师们都不能休息，他们盯着网站的各种监控指标，适时的调整机器和增减功能。顶住第一波高峰之后，这些人开始忙里偷闲的给自己买东 西，大家互相交流着哪家买的移动硬盘靠谱，哪家衣服适合自己的女朋友，不时的有人哀嚎宝贝被人抢了、信用卡额度不够了。同时，旁边白板上的赌注越下越大。
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012022511094742.jpg" alt="" /></p>
　　11 月 11 日，这个棍子最多的日子被网民自我调侃的变成了一个节日 —— “光棍节”。而淘宝网又用疯狂的折扣促销给它赋予了另外一个意义 —— “购物狂欢节”。2011 年 11 月 11 日这一天，淘宝商城与淘宝网交易额之和突破 52 亿，这个数字是“购物天堂”香港一天零售总额 8.5 亿的 6 倍。

网民感受到的是疯抢的喜悦，而网站的技术人员感受到的却是“压力山大”。就如同你家办酒席，宴请左邻右舍，这个办起来容易。倘若宴请十里八乡所 有的人，吃饭的人自然开心，但却不是一般人家能够办得起来的。能办得起来如此盛宴者，需要强大的财力物力、组织能力、技术实力（例如做这么多菜，你的炒锅 一定要是“分布式的”、“可复制的”、“可扩展的”，洗菜切菜要有“工作流引擎”，上菜的路径要用图论来计算出来，甚至连厨房的下水道都要重新设计）。

淘宝能够举办如此盛宴，网站的技术实力可见一斑。淘宝网拥有全国最大的 Hadoop 分布式计算集群之一，日新增数据 50TB，有 40PB 海量数据存储。分布在全国各地 80 多个节点的 CDN 网络，支持的流量超过 800Gbps。淘宝的搜索引擎能够对数十亿的商品数据进行实时搜索，另外还拥有自主研发的文件存储系统和缓存系统，以及 Java 中间件和消息中间件系统，这一切组成了一个庞大的电子商务操作系统。另外从商业数据上来看，Amazon 的财报显示 2011 年完成了大约 480 亿美金的交易额，eBay 2011 年财报全年完成了大约 600 亿美金的交易额（不包括其独立的汽车交易平台）。不管从交易额、商品数量、同比增速等指标上看，淘宝网均远超于此，是目前全球最大的电子商务平台。（由于 淘宝非上市公司，未公布2011年业绩，以上内容来自淘宝网技术副总裁<a href="http://weibo.com/u/1419403675" target="_blank">@_行癫</a> 的微博）

以上这些技术数据可能已经让一些同学产生不适的感觉，为了让更多的人读懂这本书，我们从技术的角度来看，小美访问淘宝网的时候，网站上发生了什么事情。参考资料：《<a href="http://kb.cnblogs.com/page/132716/" target="_blank">技术普及帖：你刚才在淘宝上买了一件东西</a>》，来自南京邮电大学孙放同学。

为了有个更直观的对比，我们说一个同行，他在 2011 年光棍节之前做促销，流量上去之后，达到 12Gbps（他们有这么大的流量，老板很高兴，在微博上面说了这个数据），这时候流量达到了极限，网站几乎挂掉，用户无法下订单。而淘宝网光棍节当天网 络的流量最高达到 800多Gbps，带给各家银行和快递公司的流量也让他们压力山大，如临大敌（后来，他们以能够撑住淘宝带来的流量为荣而到处宣传）。另外如果你在网上购 买过火车票的话，更能体会到网站能支持多大的流量有多重要。但这不是一朝一夕做出来的，也不是有钱就能办到的。

以上对比的这些网站，也许读者很容易就猜到是哪一家，这里拿出来作对比，绝对没有嘲笑人家的意思，采用通常的网站技术方案，能做到这种程度已经 不错了。任何网站的发展都不是一蹴而就的，在什么样的阶段采用什么样的技术。在发展的过程中网站会遇到各种各样的问题和业务带来的压力，正是这些原因才推 动着技术的进步和发展，而技术的发展又会反过来促进业务的更大提升。二者互为因果，相互促进。如今淘宝网的流量已经是全球排名第12、国内排名第3（美国 的 eBay 全球排名23，国内前两名是百度和腾讯）。淘宝网的系统也从使用一台服务器，到采用万台以上的服务器。本书就为大家描述淘宝网在整个发展过程中，所有的主 动和被动的技术变革的前因后果，这由很多有趣的故事组成。

正如同很多人或组织成功了以后，就会为自己的出身编造一个美丽的传说。淘宝网的出身，网上也有非常多的传说，下面我们就从它的出生开始讲起。

<strong>　　<a name="c2"></a>二、个人网站</strong>

2003 年 4 月 7 日，马云，在杭州，成立了一个神秘的组织。他叫来十位员工，要他们签了一份协议，这份协议要求他们立刻离开阿里巴巴，去做一个神秘的项目。这个项目要求绝 对保密，老马戏称“连说梦话被老婆听到都不行，谁要是透漏出去，我将追杀到天涯海角”。这份协议是英文版的，匆忙之间，大多数人根本来不及看懂，但出于对 老马的信任，都卷起铺盖离开了阿里巴巴。

他们去了一个神秘的据点 —— 湖畔花园小区的一套未装修的房子里，房子的主人是马云。这伙人刚进去的时候，马云给他们布置了一个任务，就是在最短的时间内做出一个个人对个人（C2C） 的商品交易的网站。现在出一个问题考考读者，看你适不适合做淘宝的创业团队。亲，要是让你来做，你怎么做？

在说出这个答案之前，容我先卖个关子，介绍一下这个创业团队的成员：三个开发工程师（虚竹、三丰、多隆）、一个UED（二当家）、三个运营（小 宝、阿珂、破天）、一个经理（财神）、还有就是马云和他的秘书。当时对整个项目组来说压力最大的就是时间，怎么在最短的时间内把一个从来就没有的网站从零 开始建立起来？了解淘宝历史的人知道淘宝是在 2003 年 5 月 10 日上线的，这之间只有一个月。要是你在这个团队里，你怎么做？我们的答案就是：买一个来。

买一个网站显然比做一个网站要省事一些，但是他们的梦想可不是做一个小网站而已，要做大，就不是随便买个就行的，要有比较低的维护成本，要能够 方便的扩展和二次开发。那接下来就是第二个问题：买一个什么样的网站？答案是：轻量一点的，简单一点的，于是买了这样一个架构的网 站：LAMP(Linux+Apache+MySQL+PHP)。这个直到现在还是一个很常用的网站架构模型。这种架构的优点是：无需编译，发布快 速，PHP功能强大，能做从页面渲染到数据访问所有的事情，而且用到的技术都是开源的，免费。

当时我们是从一个美国人那里买来的一个网站系统，这个系统的名字叫做 PHPAuction（他们的官方网站 http://www.phpauction.net，这个名字很直白，一眼就看出来这个系统是用什么语言做的、 是干什么用的），PHPAuction有好几个版本，我们买的是最高版的，功能比较多，而且最重要的是对方提供了源代码。最高版比较贵，花了我们 2000 美金（貌似现在降价了，只要 946 美元）。买来之后不是直接就能用的，需要很多本地化的修改，例如页面模板改的漂亮一点，页头页脚加上自己的站点简介等，其中最有技术含量的是对数据库进行 了一个修改。原来是从一个数据库进行所有的读写操作，拿过来之后多隆把它给拆分成一个主库、两个从库，读写分离。这么做的好处有几点：存储容量增加了，有 了备份，使得安全性增加了，读写分离使得读写效率提升了。这样整个系统的架构就如下图所示：
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012022511225985.jpg" alt="" /></p>
　　其中 Pear DB 是一个 PHP 模块，负责数据访问层。另外也用开源的论坛系统 PHPBB（http://www.phpbbchina.com ）搭建了一个小的论坛社区，虚竹负责机器采购、配置、架设等，三丰和多隆负责编码，他 们把交易系统和论坛系统的用户信息打通，给运营人员开发出后台管理（admin系统）的功能，把交易类型从只有拍卖这一种增加为拍卖、一口价、求购商品、 海报商品（意思是还没推出的商品，先挂个海报出来）这四种。（PHPAuction 只有拍卖的交易，Auction 即拍卖的意思。@_行癫在微博中提到：今天 eBay 所有交易中拍卖交易仍然占了 40%，而在中国，此种模式在淘宝几乎从一开始就未能占据优势，如今在主流的交易中几乎可以忽略不计。背后的原因一直令人费解。我大致可以给出其中一种解 释，eBay 基本在发达国家展开业务，制造业外包后，电子商务的基本群体大多只能表现为零散的个体间交易。）

在经历了另外一些有趣的事情之后（这些有趣的事情包括“淘宝”这个名字的由来，<a href="http://www.neweekly.com.cn/index/newsview.php?id=1263" target="_blank">员工花名的由来</a>等等，由于本书主要描述技术方面的故事，对这些有兴趣的可以去网上找），网站开始上线运行了。
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012022511260456.jpg" alt="" /></p>
　　在接下来的大半年时间里，这个网站迅速显示出了它的生机。这里有必要提一下当时的市场环境，非典（SARS）的肆虐使得大家都不敢出门，尤其是 去商场之类人多的地方。另外在神州大地上最早出现的 C2C 网站易趣也正忙的不亦乐乎，2002 年 3 月，eBay 以 3000 万美元收购了易趣公司 33% 的股份，2003 年 6 月以 1.5 亿美元收购了易趣公司剩余 67% 的股份。当时淘宝网允许买卖双方留下联系方式，允许同城交易，整个操作过程简单轻松。而 eBay 为了收取交易佣金，是禁止这么做的，这必然增加了交易过程的难度。而且 eBay 为了全球统一，把易趣原来的系统替换成了美国 eBay 的系统，用户体验一下子全变了，操作起来非常麻烦，这等于是把积累的用户拱手送给了淘宝。为了不引起 eBay 的注意，淘宝网在 2003 年里一直声称自己是一个“个人网站”。由于这个创业团队强大的市场开拓和运营能力，淘宝网发展的非常迅猛，2003 年底就吸引了注册用户XXX，最高每日 31 万PV，从 5 月到年底成交额 4000 万。这没有引起 eBay 的注意，却引起了阿里巴巴内部很多员工的注意，他们觉得这个网站以后会成为阿里巴巴强劲的对手。甚至有人在内网发帖，忠告管理层要警惕这个刚刚起步的网 站，但管理层似乎无动于衷。（这个团队的保密工作做的真好）

在市场和运营的后方，淘宝网的技术团队也在快速的做着系统的改进和创新。这里还有个有趣的故事，eBay 和易趣早期都有员工在论坛上响应用户的需求，eBay 的论坛用粉红色背景来区分员工的发言，易趣的员工在论坛上昵称都选各种豆豆，例如黄豆豆、蚕豆豆等。淘宝在讨论运营策略的时候提到这个问题，要求所有的员 工都去论坛上回答用户的问题。最早回答问题的任务落在小宝头上，那我们用什么名字好呢？“淘淘”？“宝宝”？小宝都不满意，太女性化了。讨论了很久之后， 小宝灵光乍现，干脆取个名字叫“小宝”吧，小宝带七个老婆来开店，迎接各位客官，很有故事性。于是很多武侠小说中的人物开始在论坛中行侠仗义，这些昵称下 面标志着“淘宝店小二”，他们回答着各种各样的问题，快速响应着用户的各种需求。如果是技术上能解决的，几个人商量一下，马上就开发、测试、发布上线。反 过来对比一下，易趣被 eBay 收购之后，系统更换成了全球通用的版本，响应用户的一个需求需要层层审批，反应速度自然慢了下来。

当时淘宝第一个版本的系统里面已经包含了商品发布、管理、搜索、商品详情、出价购买、评价投诉、我的淘宝这些功能（现在主流程中也是这些模块。 在 2003 年 10 月增加了一个功能节点：“安全交易”，这个是支付宝的雏形）。随着用户需求和流量的不断增长，系统上面做了很多的日常改进，服务器由最初的一台变成了三 台，一台负责发送 email、一台负责运行数据库、一台负责运行 Web App。过一段时间之后，商品搜索的功能占用数据库资源太大了（用like搜索的，很慢），又从阿里巴巴中文站搬过来他们的搜索引擎 iSearch，起初 iSearch 索引的文件放在硬盘上，随着数据量的增长，又采购了 NetApp 服务器放置 iSearch。

如此快节奏的工作，其实大家都累得不行，有人就提议大家随时随地的锻炼身体，可是外面 SARS 横行，在一个一百多方的房子里，怎么锻炼呢？高挑美女阿珂提议大家练习提臀操，这个建议遭到男士的一致反对，后来虚竹就教大家练习倒立，这个大家都能接 受。于是这个倒立的传统一直延续至今，和花名文化、武侠文化一并传承了下来。

随着访问量和数据量的飞速上涨，问题很快就出来了，第一个问题出现在数据库上。MySQL 当时是第 4 版的，我们用的是默认的存储引擎 MyISAM，这种类型读数据的时候会把表锁住（我们知道 Oracle 在写数据的时候会有行锁，读数据的时候是没有的），尤其是主库往从库上面写数据的时候，会对主库产生大量的读操作，使得主库性能急剧下降。这样在高访问量 的时候，数据库撑不住了。另外，当年的 MySQL 不比如今的 MySQL，在数据的容量和安全性方面也有很多先天的不足（和 Oracle 相比）。

<a name="c3"></a>三、<strong>Oracle/支付宝/旺旺</strong>

淘宝网作为个人网站发展的时间其实并不长，由于它太引人注目了，马云在 2003 年 7 月就宣布了这个是阿里巴巴旗下的网站，随后在市场上展开了很成功的运作。最著名的就是利用中小网站来做广告，突围 eBay 在门户网站上对淘宝的广告封锁。上网比较早的人应该还记得那些在右下角的弹窗和网站腰封上一闪一闪的广告。市场部那位到处花钱买广告的家伙，太能花钱了， 一出手就是几百万，他被我们称为“大少爷”。

“大少爷”们做的广告，带来的就是迅速上涨的流量和交易量。在 2003 年底，MySQL 已经撑不住了，技术的替代方案非常简单，就是换成 Oracle。换 Oracle 的原因除了它容量大、稳定、安全、性能高之外，还有人才方面的原因。在 2003 年的时候，阿里巴巴已经有一支很强大的 DBA 团队了，有冯春培、汪海（七公）这样的人物，后来还有冯大辉（@fenng）、陈吉平（拖雷）。这样的人物牛到什么程度呢？Oracle 给全球的技术专家颁发一些头衔，其中最高级别的叫 ACE（就是扑克牌的“尖儿”，够大的吧），被授予这个头衔的人目前全球也只有 300 多名（名单在这里： <a href="http://apex.oracle.com/pls/otn/f?p=19297:3" target="_blank">http://apex.oracle.com/pls/otn/f?p=19297:3</a> ），当年全球只有十几名。有如此强大的技术后盾，把 MySQL 换成 Oracle 是顺理成章的事情。

但更换数据库不是只换个库就可以的，访问方式，SQL 语法都要跟着变，最重要的一点是，Oracle 并发访问能力之所以如此强大，有一个关键性的设计 —— 连接池。但对于 PHP 语言来说它是放在 Apache 上的，每一个请求都会对数据库产生一个连接，它没有连接池这种功能（Java 语言有 Servlet 容器，可以存放连接池）。那如何是好呢？这帮人打探到 eBay 在 PHP 下面用了一个连接池的工具，是 BEA 卖给他们的。我们知道 BEA 的东西都很贵，我们买不起，于是多隆在网上寻寻觅觅，找到一个开源的连接池代理服务 SQLRelay（ <a href="http://sourceforge.jp/projects/freshmeat_sqlrelay/" target="_blank">http://sourceforge.jp/projects/freshmeat_sqlrelay</a> ），这个东西能够提供连接池的功能，多隆对它进行了一些功能改进之后就拿来用了。这样系统的架构就变成了如下的样子：
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201202/2012022510245823.jpg" alt="" /></p>
　　数据一开始是放在本地的，DBA 们对 Oracle 做调优的工作，也对 SQL 进行调优。后来数据量变大了，本地存储不行了。买了 NAS（Network Attached Storage：网络附属存储），NetApp 的 NAS 存储作为了数据库的存储设备，加上 Oracle RAC（Real Application Clusters，实时应用集群）来实现负载均衡。七公说这实际上是走了一段弯路，NAS 的 NFS（Network File System）协议传输的延迟很严重，但那时侯不懂。后来采购了 Dell 和 EMC 合作的 SAN 低端存储，性能一下子提升了 10 几倍，这才比较稳定了。再往后来数据量更大了，存储的节点一拆二、二拆四，RAC 又出问题了。这才踏上了购买小型机的道路。在那段不稳定的时间里，七公曾经在机房住了 5 天 5 夜。

替换完数据库，时间到了 2004 年春天，俗话说“春宵一刻值千金”，但这些人的春宵却不太好过了。他们在把数据的连接放在 SQLRelay 之后就噩梦不断，这个代理服务经常会死锁，如同之前的 MySQL 死锁一样。虽然多隆做了很多修改，但当时那个版本内部处理的逻辑不对，问题很多，唯一解决的办法就是“重启”它的服务。这在白天还好，连接上机房的服务 器，把进程杀掉，然后开启就可以了，但是最痛苦的是它在晚上也要死掉，于是工程师们不得不 24 小时开着手机，一旦收到“ SQLRelay 进程挂起”的短信，就从春梦中醒来，打开电脑，连上机房，重启服务。后来干脆每天睡觉之前先重启一下。做这事最多的据说是三丰，他现在是淘宝网的总裁。现 在我们知道，任何牛B的人物，都有一段苦B的经历。

微博上有人说“好的架构是进化来的，不是设计来的”。的确如此，其实还可以再加上一句“好的功能也是进化来的，不是设计来的”。在架构的进化过 程中，业务的进化也非常迅猛。最早的时候，买家打钱给卖家都是通过银行转账汇款，有些骗子收了钱却不发货，这是一个很严重的问题。然后这伙人研究了 PayPal 的支付方式，发现也不能解决问题。后来这几个聪明的脑袋又想到了“担保交易”这种第三方托管资金的办法。于是在 2003 年 10 月，淘宝网上面上线了一个功能，叫做“安全交易”，卖家选择支持这种功能的话，买家会把钱交给淘宝网，等他收到货之后，淘宝网再把钱给卖家。这就是现在的 支付宝，在前两天（2012.2.21）年会上，支付宝公布 2011 年的交易笔数已经是 PayPal 的两倍。这个划时代的创新，其实就是在不断的思索过程中的一个灵光乍现。

当时开发“安全交易”功能的是茅十八和他的徒弟苗人凤（茅十八开发到一半去上海读 MBA 去了，苗人凤现在是支付宝的首席业务架构师），开发跟银行网关对接的功能的是多隆。当时多数银行的网站已经支持在线支付了，但多隆告诉我，他们的网关五花 八门，用什么技术的都有，必须一家一家去接。而且他们不保证用户付钱了就一定扣款成功、不保证扣款成功了就一定通知淘宝、不保证通知淘宝了就一定能通知 到、不保证通知到了就不重复通知。这害苦了苗人凤，他必须每天手工核对账单，对不齐的话就一定是有人的钱找不到地方了，少一分钱都睡不着觉。另外他为了测 试这些功能，去杭州所有的银行都办理了一张银行卡。一堆银行卡摆在桌子上，不知道的人还以为这个家伙一定很有钱，其实里面都只是十块八块的。现在我们再一 次知道，任何牛B的人物，都必须有一段苦B的经历。

有人说淘宝打败易趣（eBay 中国）是靠免费，其实这只是原因之一。如果说和易趣过招第一招是免费的话，这让用户没有门槛就愿意来，那第二招就是“安全支付”，这让用户放心付款，不必 担心被骗。在武侠小说中真正的高手飞花摘叶即可伤人，他们不会局限于一招两招，一旦出手，连绵不绝。而淘宝的第三招就是“旺旺”，让用户在线沟通。其实淘 宝旺旺也不是自己生出来的，是从阿里巴巴的“贸易通”复制过来的。从 2004 年 3 月开始，“叮咚、叮咚”这个经典的声音就回荡在所有淘宝买家和卖家的耳边，“亲，包邮不？”，“亲，把零头去掉行不？”，这亲切的砍价声造就了后来的“淘 宝体”。有人说中国人就是爱砍价，虽然笔者体会不到砍价成功后有多少成就感，但每次我去菜市场，看到大妈们砍价砍得天昏地暗，那满足的劲头堪比捡到了钱， 我就深刻的理解了淘宝旺旺在交易过程中的价值。我猜 eBay 也体会不到砍价的乐趣，他们一直不允许买卖双方在线聊天，收购了 skype 之后也没有用到电子商务中去。

旺旺在推出来没多久，就惹了一个法律方面的麻烦。有个做雪饼的厂家找上门来，说我们侵权了，他们家的雪饼很好吃，牛奶也做得不错，我们都很喜 欢。然后我们就在旺旺的前面加了两个字，叫做“淘宝旺旺”。在那个野蛮生长的阶段，其实很多产品都是想到什么就做什么，例如我们还搭建过一个聊天室，但似 乎淘宝网不是一个闲聊的地方，这个聊天室门可罗雀，一段时间后就关闭掉了。

SQLRelay 的问题搞得三丰他们很难睡个囫囵觉，那一年开半年会的时候，公司特地给三丰颁了一个奖项，对他表示深切的安慰。但不能总这样啊，于是，2004 年的上半年开始，整个网站就开始了一个脱胎换骨的手术。

<strong>　　四、<a name="p4"></a>淘宝技术发展（Java时代：脱胎换骨）</strong>

我的师父黄裳@岳旭强曾经说过，“好的架构图充满美感”，一个架构好不好，从审美的角度就能看得出来。后来我看了很多系统的架构，发现这个言论基本成立。那么反观淘宝前面的两个版本的架构，你看哪个比较美？
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201204/2012040311224715.jpg" alt="" /></p>
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201204/2012040311231311.jpg" alt="" /></p>
　　显然第一个比较好看，后面那个显得头重脚轻，这也注定了它不是一个稳定的版本，只存活了不到半年的时间。2004 年初，SQL Relay 的问题解决不了，数据库必须要用 Oracle，那从哪里动刀？只有换开发语言了。换什么语言好呢？Java。Java 是当时最成熟的网站开发语言，它有比较良好的企业开发框架，被世界上主流的大规模网站普遍采用，另外有 Java 开发经验的人才也比较多，后续维护成本会比较低。

到 2004 年上半年，淘宝网已经运行了一年的时间，这一年积累了大量的用户，也快速的开发了很多功能，当时这个网站已经很庞大了，而且新的需求还在源源不断的过来。 把一个庞大的网站的开发语言换掉，无异于脱胎换骨，在换的过程中还不能拖慢业务的发展，这无异于边换边跑，对时间和技术能力的要求都非常高。做这样的手 术，需要请第一流的专家来主刀。现在再考一下读者，如果你在这个创业团队里面，请什么样的人来做这事？我们的答案是请 Sun 的人。没错，就是创造 Java 语言的那家公司，世界上没有比他们更懂 Java 的了。除此之外，还有一个不为人知的原因，……（此处和谐掉 200 字，完整版见 aliway）

这帮 Sun 的工程师的确很强大，在笔者 2004 年底来淘宝的时候，他们还在，有幸跟他们共事了几个月。现在摆在他们面前的问题是用什么办法把一个庞大的网站从 PHP 语言迁移到 Java？而且要求在迁移的过程中，不停止服务，原来系统的 bugfix 和功能改进不受影响。亲，你要是架构师，你怎么做？有人的答案是写一个翻译器，如同把中文翻译成英文一样，自动翻译。我只能说你这个想法太超前了，换个说 法就是“too simple, sometimes naive”。当时没有，现在也没有人能做到。他们的大致方案是给业务分模块，一个模块一个模块的替换。如用户模块，老的 member.taobao.com 继续维护，不添加新功能，新的功能先在新的模块上开发，跟老的共用一个数据库，开发完毕之后放到不同的应用集群上，另开个域名 member1.taobao.com，同时替换老的功能，替换一个，把老的模块上的功能关闭一个，逐渐的把用户引导到 member1.taobao.com，等所有功能都替换完毕之后，关闭 member.taobao.com。后来很长时间里面都是在用 member1 这样奇怪的域名，两年后有另外一家互联网公司开始做电子商务了，我们发现他们的域名也叫 member1.xx.com、auction1.xx.com……

说了开发模式，再说说用到的 Java MVC 框架，当时的 Struts 1.x 是用的比较多的框架，但是用过 WebWork 和 Struts 2 的同学可能知道，Struts 1.x 在多人协作方面有很多致命的弱点，由于没有一个轻量框架作为基础，因此很难扩展，这样架构师对于基础功能和全局功能的控制就很难做到。而阿里巴巴的 18 个创始人之中，有个架构师，在 Jakarta Turbine 的基础上，做了很多扩展，打造了一个阿里巴巴自己用的 MVC 框架 WebX （<a href="http://www.openwebx.org/docs/Webx3_Guide_Book.html">http://www.openwebx.org/docs/Webx3_Guide_Book.html</a>）， 这个框架易于扩展，方便组件化开发，它的页面模板支持 JSP 和 Velocity 等、持久层支持 iBATIS 和 Hibernate 等、控制层可以用 EJB 和 Spring（Spring 是后来才有的）。项目组选择了这个强大的框架，这个框架如果当时开源了，也许就没有 WebWork 和 Struts 2 什么事了。另外，当时 Sun 在全世界大力推广他们的 EJB，虽然淘宝的架构师认为这个东东用不到，但他们还是极力坚持。在经历了很多次的技术讨论、争论和争吵之后，这个系统的架构就变成了下图的样子：
<p style="text-align: center;"><span style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201204/2012040311284641.jpg" alt="" /> </span></p>
　　Java 应用服务器是 Weblogic，MVC 框架是 WebX、控制层用了 EJB、持久层是 iBATIS，另外为了缓解数据库的压力，商品查询和店铺查询放在搜索引擎上面。这个架构图是不是好看了一点了，亲？

这帮 Sun 的工程师开发完淘宝的网站之后，又做了一个很牛的网站，叫“支付宝”。

其实在任何时候，开发语言本身都不是系统的瓶颈，业务带来的压力更多的是压到了数据和存储上。上面一篇也说到，MySQL 撑不住了之后换 Oracle，Oracle 的存储一开始在本机上，后来在 NAS 上，NAS 撑不住了用 EMC 的 SAN 存储，再然后 Oracle 的 RAC 撑不住了，数据的存储方面就不得不考虑使用小型机了。在 2004 年的夏天，DBA 七公、测试工程师郭芙和架构师行癫，踏上了去北京测试小型机的道路。他们带着小型机回来的时候，我们像欢迎领袖一样的欢迎他们，因为那个是我们最值钱的设 备了，价格表上的数字吓死人。小型机买回来之后我们争相合影，然后 Oracle 就跑在了小型机上，存储方面从 EMC 低端 cx 存储到 Sun oem hds 高端存储，再到 EMC dmx 高端存储，一级一级的往上跳。

到现在为止，我们已经用上了 IBM 的小型机、Oracle 的数据库、EMC 的存储，这些东西都是很贵的，那些年可以说是花钱如流水啊。有人说过“钱能解决的问题，就不是问题”，但随着淘宝网的发展，在不久以后，钱已经解决不了我 们的问题了。花钱买豪华的配置，也许能支持 1 亿 PV 的网站，但淘宝网的发展实在是太快了，到了 10 亿怎么办？到了百亿怎么办？在 N 年以后，我们不得不创造技术，解决这些只有世界顶尖的网站才会遇到的问题。后来我们在开源软件的基础上进行自主研发，一步一步的把 IOE（IBM 小型机、Oracle、EMC 存储）这几个“神器”都去掉了。这就如同在《西游记》里面，妖怪们拿到神仙的兵器会非常厉害，连猴子都能够打败，但最牛的神仙是不用这些神器的，他们挥一 挥衣袖、翻一下手掌就威力无比。去 IOE 这一部分会在最后一个章节里面讲，这里先埋个千里伏笔。

欲知后事如何，且听下回分解。

<a name="p5"></a><strong>五、淘宝技术发展（Java时代：坚若磐石）</strong>

已经有读者在迫不及待的问怎么去掉了 IOE，别急，在去掉 IOE 之前还有很长的路要走。行癫他们买回来小型机之后，我们用上了 Oracle，七公带着一帮 DBA 在优化 SQL 和存储，行癫带着几个架构师在研究数据库的扩展性。Oracle 本身是一个封闭的系统，用 Oracle 怎么做扩展？用现在一个时髦的说法就是做“分库分表”。

我们知道一台 Oracle 的处理能力是有上限的，它的连接池有数量限制，查询速度跟容量成反比。简单的说，在数据量上亿、查询量上亿的时候，就到它的极限了。要突破这种极限，最简 单的方式就是多用几个 Oracle 数据库。但一个封闭的系统做扩展，不像分布式系统那样轻松。我们把用户的信息按照 ID 来放到两个数据库里面（DB1/DB2），把商品的信息跟着卖家放在两个对应的数据库里面，把商品类目等通用信息放在第三个库里面(DBcommon)。 这么做的目的除了增加了数据库的容量之外，还有一个就是做容灾，万一一个数据库挂了，整个网站上还有一半的数据能操作。

数据库这么分了之后，应用程序有麻烦了，如果我是一个买家，买的商品有 DB1 的也有 DB2 的，要查看“我已买到的宝贝”的时候，应用程序怎么办？必须到两个数据库里面分别查询出来对应的商品。要按时间排序怎么办？两个库里面“我已买到的宝贝” 全部查出来在应用程序里面做合并。还有分页怎么处理？关键字查询怎么处理？这些东西交给程序员来做的话会很悲催，于是行癫在淘宝的第一个架构上的作品就来 解决了这个问题，他写了一个数据库路由的框架 DBRoute，这个框架在淘宝的 Oracle 时代一直在使用。后来随着业务的发展，这种分库的第二个目的 —— 容灾的效果就没有达到。像评价、投诉、举报、收藏、我的淘宝等很多地方，都必须同时连接 DB1 和 DB2，哪个库挂了都会导致整个网站挂掉。

上一篇说过，采用 EJB 其实是和 Sun 的工程师妥协的结果，在他们走了之后，EJB 也逐渐被冷落了下来。在 2005、2006年的时候，Spring 大放异彩，正好利用 Spring 的反射（IoC）模式替代了 EJB 的工厂模式，给整个系统精简了很多代码。

上一篇还说过，为了减少数据库的压力，提高搜索的效率，我们引入了搜索引擎。随着数据量的继续增长，到了 2005 年，商品数有 1663 万，PV 有 8931 万，注册会员有 1390 万，这给数据和存储带来的压力依然山大，数据量大，性能就慢。亲，还有什么办法能提升系统的性能？一定还有招数可以用，这就是缓存和 CDN（内容分发网络）。

你可以想象，九千万的访问量，有多少是在商品详情页面？访问这个页面的时候，数据全都是只读的（全部从数据库里面读出来，不写入数据库），如果 把这些读操作从数据库里面移到内存里，数据库将会多么的感激涕零。在那个时候我们的架构师多隆大神，找到了一个基于 Berkeley DB 的开源的缓存系统，把很多不太变动的只读信息放了进去。其实最初这个缓存系统还比较弱，我们并没有把整个商品详情都放在里面，一开始把卖家的信息放里面， 然后把商品属性放里面，商品详情这个字段太大，放进去受不了。说到商品详情，这个字段比较恐怖，有人统计过，淘宝商品详情打印出来平均有 5 米长，在系统里面其实放在哪里都不招人待见。笔者清楚的记得，我来淘宝之后担任项目经理做的第一个项目就是把商品详情从商品表里面给移出来。这个字段太大 了，查询商品信息的时候很多都不需要查看详情，它跟商品的价格、运费这些放在一个表里面，拖慢了整个表的查询速度。在 2005 年的时候，我把商品详情放在数据库的另外一张表里面，再往后这个大字段被从数据库里面请了出来，这也让数据库再一次感激涕零。

到现在为止，整个商品详情的页面都在缓存里面了，眼尖的读者可能会发现现在的商品详情不全是“只读”的信息了，这个页面上有个信息叫“浏览 量”，这个数字每刷新一次页面就要“写入”数据库一次，这种高频度实时更新的数据能用缓存吗？如果不用缓存，一天几十亿的写入，数据库会怎么样？一定会挂 掉。那怎么办？亲……先不回答你（下图不是广告，让你看看浏览量这个数据在哪里）
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201204/2012040311503357.jpg" alt="" /></p>
　　CDN 这个工作相对比较独立，跟别的系统一样，一开始我们也是采用的商用系统。后来随着流量的增加，商用的系统已经撑不住了，LVS 的创始人章文嵩博士带人搭建了淘宝自己的 CDN 网络。在本文的引言中我说过淘宝的 CDN 系统支撑了 800Gbps 以上的流量，作为对比我们可以看一下国内专业做 CDN 的上市公司 ChinaCache 的介绍 —— “ChinaCache……是中国第一的专业 CDN 服务提供商，向客户提供全方位网络内容快速分布解决方案。作为首家获信产部许可的 CDN 服务提供商，目前 ChinaCache 在全国 50 多个大中城市拥有近 300 个节点，全网处理能力超过 500Gbps，其 CDN 网络覆盖中国电信、中国网通、中国移动、中国联通、中国铁通和中国教育科研网等各大运营商。” —— 这样你可以看得出淘宝在 CDN 上面的实力，这在全世界都是数一数二的。另外因为 CDN 需要大量的服务器，要消耗很多能源（消耗多少？在前两年我们算过一笔帐，淘宝上产生一个交易，消耗的电足以煮熟 4 个鸡蛋）。这两年章文嵩的团队又在研究低功耗的服务器，在绿色计算领域也做了很多开创性的工作。淘宝 CDN 的发展需要专门一个章节来讲，想先睹为快的可以看一下笔者<a href="http://qing.weibo.com/1866752224/6f4460e033000jme.html" target="_blank">对章文嵩的专访</a>。

回想起刚用缓存那段时间，笔者还是个小菜鸟，有一个经典的错误常常犯，就是数据库的内容更新的时候，忘记通知缓存系统，结果在测试的时候就发现 我改过的数据怎么在页面上没变化呢。后来做了一些页面上的代码，修改 CSS 和 JS 的时候，用户本地缓存的信息没有更新，页面上也会乱掉，在论坛上被人说的时候，我告诉他用 Ctrl+F5 刷新页面，然后赶紧修改脚本文件的名称，重新发布页面。学会用 Ctrl+F5 的会员对我佩服的五体投地，我却惭愧的无地自容。

有些技术的发展是顺其自然的，有些却是突如其来的。到 2007 年的时候，我们已经有几百台应用服务器了，这上面的 Java 应用服务器是 WebLogic，而 WebLogic 是非常贵的，比这些服务器本身都贵。有一段时间多隆研究了一下 JBoss，说我们换掉 WebLogic 吧，于是又省下了不少银两。那一年，老马举办了第一届的“网侠大会”，会上来的大侠中有一位是上文提到的章文嵩，还有一位曾经在 JBoss 团队工作，我们也把这位大侠留下了，这样我们用起 JBoss 更加有底气了。

这些杂七杂八的修改，我们对<strong>数据分库、放弃 EJB、引入 Spring、加入缓存、加入 CDN、采用开源的 JBoss</strong>，看起来没有章法可循，其实都是围绕着提高容量、提高性能、节约成本来做的，由于这些不算大的版本变迁，我们姑且叫它 2.1 版吧，这个版本从构图上来看有 3 只脚，是不是稳定了很多？

架构图如下：
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201204/2012040311562659.jpg" alt="" /></p>
　　<a name="p6"></a><strong>六、淘宝技术发展（Java时代：创造技术-TFS）</strong>

在讲淘宝文件系统 TFS 之前，先回顾一下上面几个版本。1.0 版的 PHP 系统运行了将近一年的时间（2003.05~2004.01）；后来数据库变成 Oracle 之后（2004.01~2004.05，叫 1.1 版本吧），不到半年就把开发语言转换为 Java 系统了（2004.02~2005.03，叫2.0版本）；进行分库、加入缓存、CDN之后我们叫它 2.1 版本（2004.10~2007.01）。这中间有些时间的重合，因为很多架构的演化并没有明显的时间点，它是逐步进化而来的。

在描述 2.1 版本的时候我写的副标题是“坚若磐石”，这个“坚若磐石”是因为这个版本终于稳定下来了，在这个版本的系统上，淘宝网运行了两年多的时间。这期间有很多优 秀的人才加入，也开发了很多优秀的产品，例如支付宝认证系统、招财进宝项目、淘宝旅行、淘宝彩票、淘宝论坛等等。甚至在团购网站风起云涌之前，淘宝网在 2006 年就推出了团购的功能，只是淘宝网最初的团购功能是买家发起的，达到卖家指定的数量之后，享受比一口价更低的价格，这个功能看起来是结合了淘宝一口价和荷 兰拍的另一种交易模式，但不幸没有支撑下去。

在这些产品和功能的最底层，其实还是商品的管理和交易的管理这两大功能。这两大功能在 2.1 版本里面都有很大的变化。商品的管理起初是要求卖家选择 7 天到期还是 14 天到期，到期之后就要下架，必须重新发布才能上架，上架之后就变成了新的商品信息（ID变过了）。另外如果这个期间内成交了，之后再有新货，必须发布一个 新的商品信息。这么做有几个原因，一是参照拍卖商品的时间设置，要在某日期前结束挂牌；二是搜索引擎不知道同样的商品哪个排前面，那就把挂牌时间长的排前 面，这样就必须在某个时间把老的商品下架掉，不然它老排在前面；第三是成交信息和商品 ID 关联，这个商品如果多次编辑还是同一个 ID 的话，成交记录里面的商品信息会变来变去；还有一个不为人知的原因，我们的存储有限，不能让所有的商品老存放在主库里面。这种处理方式简单粗暴，但还算是 公平。不过这样很多需求都无法满足，例如同样的商品，我上一次销售的时候很多好评都没法在下一个商品上体现出来；再例如我买过的商品结束后只看到交易的信 息，不知道卖家还有没有再卖了。后来基于这些需求，我们在 2006 年下半年把商品和交易拆开。一个商家的一种商品有个唯一的 ID，上下架都是同一个商品。那么如果卖家改价格、库存什么的话，已成交的信息怎么处理？那就在买家每交易一次的时候，都记录下商品的快照信息，有多少次 交易就有多少个快照。这样买卖双方比较爽了，给系统带来了什么？存储的成本大幅度上升了！

存储的成本高到什么程度呢？数据库方面提到过用了 IOE，一套下来就是千万级别的，那几套下来就是⋯⋯。另外淘宝网还有很多文件需要存储，我们有哪些文件呢？最主要的就是图片、商品描述、交易快照，一个 商品要包含几张图片和一长串的描述信息，而每一张图片都要生成几张规格不同的缩略图。在 2010 年，淘宝网的后端系统上保存着 286 亿个图片文件。图片在交易系统中非常重要，俗话说“一张好图胜千言”、“无图无真相”，淘宝网的商品照片，尤其是热门商品，图片的访问流量是非常大的。淘 宝网整体流量中，图片的访问流量要占到 90% 以上。且这些图片平均大小为 17.45 KB，小于 8K 的图片占整体图片数量 61%，占整体系统容量的 11%。这么多的图片数据、这么大的访问流量，给淘宝网的系统带来了巨大的挑战。众所周知，对于大多数系统来说，最头疼的就是大规模的小文件存储与读取， 因为磁头需要频繁的寻道和换道，因此在读取上容易带来较长的延时。在大量高并发访问量的情况下，简直就是系统的噩梦。我们该怎么办？

同样的套路，在某个规模以下，采用现有的商业解决方案，达到某种规模之后，商业的解决方案无法满足，只有自己创造解决方案了。对于淘宝的图片存 储来说，转折点在 2007 年。这之前，一直采用的商用存储系统，应用 NetApp 公司的文件存储系统。随着淘宝网的图片文件数量以每年 2 倍(即原来 3 倍)的速度增长，淘宝网后端 NetApp 公司的存储系统也从低端到高端不断迁移，直至 2006 年，即使是 NetApp 公司最高端的产品也不能满足淘宝网存储的要求。从 2006 年开始，淘宝网决定自己开发一套针对海量小文件存储的文件系统，用于解决自身图片存储的难题。这标志着淘宝网从使用技术到了创造技术的阶段。

2007年之前的图片存储架构如下图：
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012042521361474.png" alt="" width="630" /></p>
章文嵩博士总结了几点商用存储系统的局限和不足:

首先是商用的存储系统没有对小文件存储和读取的环境进行有针对性的优化；其次，文件数量大，网络存储设备无法支撑；另外，整个系统所连接的服务 器也越来越多，网络连接数已经到达了网络存储设备的极限。此外，商用存储系统扩容成本高，10T的存储容量需要几百万，而且存在单点故障，容灾和安全性无 法得到很好的保证。

谈到在商用系统和自主研发之间的经济效益对比，章文嵩博士列举了以下几点经验：

1. 商用软件很难满足大规模系统的应用需求，无论存储还是 CDN 还是负载均衡，因为在厂商实验室端，很难实现如此大的数据规模测试。

2. 研发过程中，将开源和自主开发相结合，会有更好的可控性，系统出问题了，完全可以从底层解决问题，系统扩展性也更高。
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012042521381649.png" alt="" /></p>
　　3. 在一定规模效应基础上，研发的投入都是值得的。上图是一个自主研发和购买商用系统的投入产出比对比，实际上，在上图的交叉点左边，购买商用系统都是更加实 际和经济性更好的选择，只有在规模超过交叉点的情况下，自主研发才能收到较好的经济效果。实际上，规模化达到如此程度的公司其实并不多，不过淘宝网已经远 远超过了交叉点。

4. 自主研发的系统可在软件和硬件多个层次不断的优化。

历史总是惊人的巧合，在我们准备研发文件存储系统的时候，Google 走在了前面，2007 年他们公布了 GFS（ Google File System ）的设计论文，这给我们带来了很多借鉴的思路。随后我们开发出了适合淘宝使用的图片存储系统TFS（Taobao File System）。3年之后，我们发现历史的巧合比我们想象中还要神奇，几乎跟我们同时，中国的另外一家互联网公司也开发了他们的文件存储系统，甚至取的名 字都一样 —— TFS，太神奇了！（猜猜是哪家？）

2007 年 6 月，TFS 正式上线运营。在生产环境中应用的集群规模达到了 200 台 PC Server(146G*6 SAS 15K Raid5)，文件数量达到上亿级别；系统部署存储容量：140TB；实际使用存储容量： 50TB；单台支持随机IOPS200+，流量 3MBps。

要讲 TFS 的系统架构，首先要描述清楚业务需求，淘宝对图片存储的需求大概可以描述如下：

文件比较小；并发量高；读操作远大于写操作；访问随机；没有文件修改的操作；要求存储成本低；能容灾能备份。应对这种需求，显然要用分布式存储 系统；由于文件大小比较统一，可以采用专有文件系统；并发量高，读写随机性强，需要更少的 IO 操作；考虑到成本和备份，需要用廉价的存储设备；考虑到容灾，需要能平滑扩容。

参照 GFS 并做了适度的优化之后，TFS 1.0 版的架构图如下：
<p style="text-align: center;"><img src="http://pic001.cnblogs.com/images/2012/1/2012042521422296.jpg" alt="" /></p>
从上面架构图上看：集群由一对 Name Server 和多台 Data Serve r构成，Name Server 的两台服务器互为双机，就是集群文件系统中管理节点的概念。

在这个架构中：
• 每个 Data Server 运行在一台普通的 Linux 主机上
• 以 block 文件的形式存放数据文件(一般64M一个block )
• block 存多份保证数据安全
• 利用 ext3 文件系统存放数据文件
• 磁盘 raid5 做数据冗余
• 文件名内置元数据信息，用户自己保存 TFS 文件名与实际文件的对照关系 – 使得元数据量特别小。

淘宝 TFS 文件系统在核心设计上最大的取巧的地方就在，传统的集群系统里面元数据只有 1 份，通常由管理节点来管理，因而很容易成为瓶颈。而对于淘宝网的用户来说，图片文件究竟用什么名字来保存实际上用户并不关心，因此TFS 在设计规划上考虑在图片的保存文件名上暗藏了一些元数据信息，例如图片的大小、时间、访问频次等等信息，包括所在的逻辑块号。而在元数据上，实际上保存的 信息很少，因此元数据结构非常简单。仅仅只需要一个 fileID，能够准确定位文件在什么地方。

由于大量的文件信息都隐藏在文件名中，整个系统完全抛弃了传统的目录树结构，因为目录树开销最大。拿掉后，整个集群的高可扩展性极大提高。实际 上，这一设计理念和目前业界的“对象存储”较为类似，淘宝网 TFS 文件系统已经更新到 1.3 版本，在生产系统的性能已经得到验证，且不断得到了完善和优化，淘宝网目前在对象存储领域的研究已经走在前列。

在 TFS 上线之前，淘宝网每个商品只允许上传一张图片，大小限定在 120K 之内，在商品详情里面的图片必须使用外站的服务。那时侯发布一件商品确实非常麻烦，笔者曾经想卖一台二手电脑，先把照片上传到 Google 相册，在发布到淘宝网之后发现 Google 相册被墙了，我的图片别人看不到，当时郁闷的不行。TFS 上线后，商品展示图片开放到 5 张，商品描述里面的图片也可以使用淘宝的图片服务，到现在为止，淘宝网给每个用户提供了 1G 的图片空间，这下大家都满足了。技术和业务就是这么互相用力的推动着，业务满足不了的时候，技术必须创新，技术创新之后，业务有了更大的发展空间。

1.3 版本的架构见阿里味（阿里巴巴内网）⋯⋯

<a name="p7"></a><strong>七、淘宝技术发展（分布式时代：服务化）</strong>

在系统发展的过程中，架构师的眼光至关重要，作为程序员，把功能实现即可，但作为架构师，要考虑系统的扩展性、重用性，这种敏锐的感觉，有人说 是一种代码洁癖。淘宝早期有几个架构师具备了这种感觉。一指开发的 Webx 是一个扩展性很强的框架，行癫在这个框架上插入了数据分库路由的模块、session 框架等等。在做淘宝后台系统的时候，同样需要这几个模块，行癫指导我把这些模块单独打成了 jar 包。另外在做淘宝机票、彩票系统的时候，页面端也有很多东西需要复用，最直观的是页头和页脚，一开始我们每个系统里面复制了一份过去，但奇妙的是，那段时 间页脚要经常修改，例如把“雅虎中国”改成“中国雅虎”，过一段时间又加了一个“口碑网”，再过一段时间变成了“雅虎口碑”，最后又变成了“中国雅虎”， 每个系统都改一遍，折腾啊。后来我就把这部分 velocity 模版单独拿出来了，做成了公用的模块。

上面这些都是比较小的复用模块，到 2006 年我们做了一个商品类目属性的改造，在类目里面引入属性的概念。项目的代号叫做“泰山”，如同它的名字，这是一个举足轻重的项目，这个改变是一个划时代的 创新。在这之前的三年时间内，商品的分类都是按照树状的一级一级的节点来分的，随着商品数量的增长，类目也变得越来越深，越来越复杂，这带给买家的就是查 找一件商品要逐级类目点开，找商品之前要懂商品的分类。而淘宝运营部门管理类目的小二也发现一个很严重的问题 —— 例如男装里面有T恤、T恤下面有耐克、耐克有纯棉的，女装里面也有T恤、T恤下面还是有耐克、耐克下面依然有纯棉的，那是先分男女装再分款式再分品牌再分 材质呢？还是先分品牌再分款式再分材质再分男女呢？晕倒了。这时候，一位大侠出来了 —— 一灯，他说品牌、款式、材质这种东东可以叫做“属性”，属性是类似 tag 的一个概念，与类目相比更加离散，更加灵活，这样也缩减了类目的深度。这个思想的提出，一举解决了分类的难题！从系统的角度来看，我们建立了“属性”这样 一个数据结构，由于除了类目的子节点有属性，父节点也有可能有属性，于是类目属性合起来也是一个结构化的数据对象。这个做出来之后我们把它独立出来作为一 个服务，叫做 catserver（category server）。跟类目属性密切关联的商品搜索功能，独立出来，叫做 hesper（金星），catserver 和 hesper 供淘宝的前后台系统调用。

现在淘宝的商品类目属性已经是地球上最大的了，几乎没有什么类目的商品在淘宝上找不到（除了违禁的），但最初类目属性改造完之后，我们很缺属性 数据，尤其是数码类的最缺。那从哪里弄这些数据呢亲？我们跟“中关村在线”合作，拿到了很多数据，那个时候，很多商品属性信息的后边标注着：“来自中关村 在线”。有了类目属性，给运营的工作带来很大的便利，我们知道淘宝的运营主要就是类目的运营，什么季节推什么商品，都要在类目属性上面做调整，让买家更容 易找到。例如夏天我要用户在女装一级类目下就标出来材质是不是蕾丝的、是不是纯棉的，冬天却要把羽绒衣调到女装一级类目下，流行什么就要把什么商品往更高 级的类目调整。这样类目和属性要经常调整，随之而来的问题就显现了 —— 调整到哪个类目，那类商品的卖家就要编辑一次自己的商品，随着商品量的增长，卖家的工作量越来越大，然后我们就发现卖家受不了啦。到了 2008 年，我们研究了超市里面前后台商品的分类，发现超市前台商品可以随季节和关联来调整摆放场景（例如著名的啤酒和尿布的关联），后台仓库里面要按照自然类目 来存储，二者密切关联却又相互分开。然后我们就把前后台类目分开了，这样卖家发布商品选择的是自然类目和属性，淘宝前台展示的是根据运营需要而摆放的商品 的类目和属性。改造后的类目属性服务取名叫做 forest（森林，跟类目属性有点神似。catserver 还在，提供卖家授权、品牌服务、关键词等相关的服务）。类目属性的服务化，是淘宝在系统服务化方面做的第一个探索。

虽然个别架构师具备了代码洁癖，但淘宝前台系统的业务量和代码量还是爆炸式的增长了起来。业务方总在后面催，开发人员不够了就继续招人，招来的 人根本看不懂原来的业务，只好摸索着在“合适的地方”加一些“合适的代码”，看看运行起来像那么回事，就发布上线了。在这样的恶性循环中，系统越来越臃 肿，业务的耦合性越来越高，开发的效率越来越低。借用当时比较流行的一句话“写一段代码，编译一下能通过，半个小时就过去了；编译一下没通过，半天就过去 了。”在这种情况下，系统出错的概率也逐步增长，常常是你改了商品相关的某些代码，发现交易出问题了，甚至你改了论坛上的某些代码，旺旺出问题了。这让开 发人员苦不堪言，而业务方还认为这帮人干活越来越慢了。

大概是在 2007 年底的时候，研发部空降了一位从硅谷来的高管，空闻大师。空闻是一位温厚的长者，他告诉我们一切要以稳定为中心，所有影响系统稳定的因素都要解决掉。例如 每做一个日常修改，都必须整个系统回归测试一遍；多个日常修改如果放在一个版本里面，要是一个功能没有测试通过，整个系统都不能发布。我们把这个叫做“火 车模型”，任何一个乘客没有上车，都不许发车。这样做的最直接后果就是火车一直晚点，新功能上线更慢了，我们能明显的感觉到业务方的不满，空闻的压力肯定 非常大。当时我都不理解这种一刀切的做法，为了稳定牺牲了发展的速度，这跟某 Party 的“稳定压倒一切”有什么分别？

但是到现在回过头来看看，其实我们并没有理解背后的思路。正是在这种要求下，我们不得不开始改变一些东西，例如把回归测试日常化，每天晚上都跑 一遍整个系统的回归。还有就是在这种要求下，我们不得不对这个超级复杂的系统做肢解和重构，其中复用性最高的一个模块 —— 用户信息模块开始拆分出来了，我们叫它 UIC（user information center）。在 UIC 里面，它只处理最基础的用户信息操作，例如getUserById、getUserByName等等。

在另外一个方面，还有两个新兴的业务，也对系统基础功能的拆分提出了要求。在那个时候，我们做了淘宝旅行（trip.taobao.com）和 淘宝彩票（caipiao.taobao.com）两个新业务，这两个新业务在商品的展示和交易的流程上都跟主站的业务不一样，机票是按照航班的信息展示 的，彩票是按照双色球、数字和足球的赛程来展示的。但用到的会员的功能和交易的功能是跟主站差不多的，当时做的时候就很纠结，在主站里面做的话，会有一大 半跟主站无关的东西，重新做一个的话，会有很多重复建设。最终我们决定不再给主站添乱了，就另起炉灶做了两个新的业务系统。从查询商品、购买商品、评价反 馈、查看订单这一整个流程都重新写了一套出来。现在在“我的淘宝”里面查看交易记录的时候，还能发现“已买到的宝贝”里面把机票和彩票另外列出来了，他们 没有加入到普通的订单里面去。在当时如果已经把会员、交易、商品、评价这些模块拆分出来，就不用什么都重做一遍了。
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201210/2012101308271834.jpg" alt="" width="130" height="139" /></p>
　　到 2008 年初，整个主站系统（有了机票、彩票系统之后，把原来的系统叫做主站）的容量已经到了瓶颈，商品数在一亿以上，PV 在 2.5 亿以上，会员数超过了五千万。这个时候 Oracle 的连接池数量都不够用了，数据库的容量到了极限，上层系统再增加机器也无法继续扩容了，我们只有把底层的基础服务继续拆分，从底层开始扩容，上层才能扩 展，这才能容纳以后三五年的增长。

于是那一年我们专门启动了一个更大的项目，把交易这个核心业务模块也拆分出来了。原来的淘宝交易除了跟商品管理耦合在一起，也在支付宝和淘宝之 间跳来跳去，跟支付宝耦合在一起，系统复杂，用户体验也很不好。我们把交易的底层业务拆出来叫交易中心TC（trade center），所谓底层业务是例如创建订单、减库存、修改订单状态等原子型的操作；交易的上层业务叫交易管理TM（trade manager），例如拍下一件普通商品要对订单、库存、物流进行操作，拍下虚拟商品不需要对物流进行操作，这些在TM里面完成。这个项目取了一个很没有 创意的名字 —— “千岛湖”，这帮开发人员取这个名字的目的是想在开发完毕之后，去千岛湖玩一圈，后来他们如愿以偿了。这个时候还有一个项目也在搞，就是淘宝商城，之前拆 分出来的那些基础服务，给商城的快速构建，提供了良好的基础。

类目属性、用户中心、交易中心，随着这些模块逐步的拆分和服务化改造，我们在系统架构方面也积累了不少的经验。到 2008 年底干脆做了一个更大的项目，把淘宝所有的业务都模块化，这是继 2004 年从 LAMP 架构到 Java 架构之后的第二次脱胎换骨。这个项目取了一个很霸气的名字，叫“五彩石”（女娲炼石补天，用的石头）。这个系统重构的工作非常惊险，有人称之为“给一架高 速飞行的飞机换发动机”。

五彩石项目发布之后，这帮工程师去三亚玩了几天。他们把淘宝的系统拆分成了如下架构：
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201210/2012101221210061.jpg" alt="" /></p>
　　其中 UIC 和 Forest 上文说过，TC、IC、SC分别是交易中心（Trade Center）、商品中心（Item Center）、店铺中心（Shop Center），这些中心级别的服务只提供原子级的业务逻辑，如根据ID查找商品、创建交易、减少库存等操作。再往上一层是业务系统TM（Trade Manager交易业务）、IM（Item Manager商品业务）、SM（Shop Manager，因为不好听，所以后来改名叫 SS：Shop System，店铺业务）、Detail（商品详情）。

拆分之后，系统之间的交互关系变得非常复杂，示意图如下：
<p style="text-align: center;"><img src="http://pic003.cnblogs.com/2012/1/201210/2012101221224180.jpg" alt="" /></p>
<p style="text-align: left;">　　系统这么拆分的话，好处显而易见，拆分之后每个系统可以单独部署，业务简单，方便扩容； 有大量可重用的模块以便于开发新的业务；能够做到专人专事，让技术人员更加专注于某一个领域。这样要解决的问题也很明显，分拆之后，系统之间还是必须要打 交道的，越往底层的系统，调用它的客户方越多，这就要求底层的系统必须具有超大规模的容量和非常高的可用性。另外，拆分之后的系统如何通讯？这里需要两种 中间件系统，一种是实时调用的中间件（淘宝的HSF，高性能服务框架）、一种是异步消息通知的中间件（淘宝的Notify）。另外还有一个需要解决的问题 是用户在A系统登录了，到B系统的时候，用户的登录信息怎么保存？这又涉及到一个 Session 框架。再者，还有一个软件工程方面的问题，这么多层的一套系统，怎么去测试它？</p>
<p style="text-align: left;">转载原文：http://blog.sina.com.cn/s/blog_633219970100x9cc.html</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>117</wp:post_id>
		<wp:post_date>2014-07-03 15:22:32</wp:post_date>
		<wp:post_date_gmt>2014-07-03 07:22:32</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e6%b7%98%e5%ae%9d%e6%8a%80%e6%9c%af%e5%8f%91%e5%b1%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mysql"><![CDATA[MySQL]]></category>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="post_tag" nicename="%e5%88%86%e5%b8%83%e5%bc%8f"><![CDATA[分布式]]></category>
		<category domain="post_tag" nicename="%e5%a4%a7%e6%95%b0%e6%8d%ae"><![CDATA[大数据]]></category>
		<category domain="category" nicename="architecture"><![CDATA[架构&amp;框架]]></category>
		<category domain="post_tag" nicename="%e6%b7%98%e5%ae%9d"><![CDATA[淘宝]]></category>
		<category domain="post_tag" nicename="%e9%98%bf%e9%87%8c%e5%b7%b4%e5%b7%b4"><![CDATA[阿里巴巴]]></category>
	</item>
	<item>
				<title>粉丝经济：让信任成为交易通道</title>
		<link>http://localhost:81/wordpress/?p=128</link>
		<pubDate>Thu, 17 Jul 2014 09:53:23 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=128</guid>
		<description></description>
		<content:encoded><![CDATA[<div id="media" class="media" style="color: #222222;"><img src="http://mmbiz.qpic.cn/mmbiz/zQA07qfQ8IydMrMKgqZm3UnaYreOTvEMyCauBWNKgWbTia0jXXmD0w5xWakuHB1e6F3Tumr00AnsdLM1dGPuJDQ/0" alt="" /></div>
<div id="js_content" class="text" style="color: #3e3e3e;">

1年多前孕峰逃出北京猫在一南方小镇上搞自媒体。一位CEO告诫“这很危险”。他说，关注互联网，要在北京，否则容易被淘汰。其逻辑有3层。

1层。人的原动力来自目标，目标则来自视野。视野够了才可能有与众不同的目标。不在核心城市，视野容易丧失。

2层。人是社会化动物，95%的知识和能力来自社会环境。先进的方法论来自周围人的感知，再自己反思。

3层。互联网上的沟通，本质上替代不了面对面交流。50封Email比不上一个面对面的能感受音容笑貌的聊天的启发大。

如上3层，有一个铁的事实为证：就算是互联网的创业，中心也在硅谷，而不是哪里都行。

孕峰远离北京的自媒体试验快2年，大都在东莞、悉尼、大理闲游。即使去北京也是拜师学艺，极少见人、吃饭、混圈子、开会。

试验下来的判断是，远离北京做自媒体问题不大，至少对孕峰而言完全可行。逻辑也有3层。

1层。信息的流通渠道由之前的面对面接触，也就是物理的渠道，变成互联网时代的人际网络，也就是信任的通道。

没互联网，得当面沟通。见面是瓶颈，地理位置是瓶颈。新闻发布会是其产物。有互联网，不用见面，地理位置不再是瓶颈。你是否信任我，成了瓶颈。话不投机半句多，有缘千里网上逢。越有价值的信息，越如此。

2层。在社会化网络上随机、随性、随时发生的交流，大大提升效率，大大激发灵感的滋生。微信朋友圈、微信群、微博，就像无形的咖啡馆，彼此相望、相交，但不打扰。所有人在这闲扯、演讲、激辩、启发。其宽度、丰富度，不是几个人的面对面交流能比拟。尤其当专业人士在微信群里对信任的朋友们说的哪怕一言半语，价值尤其大。

3层。当地理位置是交流瓶颈的年代，信息稀缺。互联网后，信息爆炸，现在稀缺的，是从海量信息里抽取、整合出一个独特、新颖的逻辑的能力。处于北上广核心城市的记者们时时处处在漩涡中，相对压抑了思考力的进化。反之在僻静偏远小镇上的闲人，倒能“大梦谁先觉，平生我自知”。

这句话来自喻国明：“一切原创的东西，都是独立思考的产物；一切有价值的反思，都是在保持距离中完成的。喧闹和紧密可以产生激情，但却无法产生智慧。”

这3层逻辑里，信任是整个链条转起来的驱动。

孕峰参与发起的涛峰私董会也验证这个趋势。1，加入的140位私董里，90%与孕峰没见过面，靠的只是信任，信任的来源是读过的文章和由此生出的判断，于是对这些文章的其它读者也生出了信任。2，140人群里随机、随性、随时进行的同段位的有信任的直接的交流，让每个人获益。

信任是粉丝关系的本质。交易不再通过传统的通道，而通过达人与粉丝之间的信任的通道流动，就是所谓的粉丝经济。

媒体没有粉丝是可怕的。媒体传递信息、观点、知识，天职是改变受众所思所想，所爱所恨。思想和爱恨被影响被塑造而后生出来的信任，共同经历过变化而共同成长后生出来的信任，“粉丝”的根基在于此。做媒体若没粉丝，就表示没影响力，没灵魂，行将就木。

做产品没有粉丝也是一样。产品没有被赋予内涵，没有被媒体化，没有给予过力量，就不可能被信任。

传统媒体的套现方式脱胎于物理世界的“便利”性。进地铁口时顺道买了瓶水，水的品牌和质量并非最重要，最重要是“地铁口”这个位置。这个交易发生的背景是“便利”。

传统媒体的广告与此神似。你看到一篇文章或一个电视剧，附带扫了一眼跟在后面的广告。也出于“便利”。

粉丝经济的套现方式必然升级。因“便利性”而掏钱只是勉为其难，没有溢价。粉丝掏钱将是出于内心的信任，而非任何物理世界或者传统因素的“方便”。比如逻辑思维卖书，不告诉你书名，先给钱再快递，这相当不便利、不传统，但有了信任，便利算个P。比如呛口小辣椒推荐时装，小姑娘们也知道推荐中有些是广告，但挡不住信任，就算是广告，那也是时尚教母背书的东西，不会差。

地铁口的便利店的生意还会做下去，贴在文章或电视剧末位的广告也还会被看到，但只能挣到搬运工的钱，不能享受到信任的溢价。

你是否信，这个世界上最有价值的信息一定是通过信任的管道流动的。而不会委屈于其它任何的载体。

几个推论。

1、帮助有粉丝的媒体把“信任”合理变现，是未来传媒业最大的机会之一。这需要有强大商业资源和运营能力的第三方。

2、但凡跟流量以及传统广告相关的传媒形态，无论包装成什么，都不具有生命力。流量过时了，信任为上；覆盖面过时了，亲密为上；传播面过时了，影响为上；广告过时了，交易为上。

3、传统搜索引擎不在“粉丝经济”的范畴。算法推给你的答案，你是否“信任”，你们之间是否会建立联系？可能在未来，我们有能力分辨真假好坏的信息，会借助搜索引擎，比如你想搜一下天气或者某个数据或者某个网站。我们不能分辨真假好坏的信息，会借助基于信任的人际链条的推荐，比如要找个靠谱的中医。传统搜索引擎建立在冷冰冰的字节的分析上，尚未纳入热乎乎的信任的能量。

4、现在人常说“口碑”。对应于之前的“品牌”。品牌是电影明星告诉你的东西，一对多的辐射，广告预算一停，就开始下滑；口碑是身边人告诉你的东西，多对多的传播，只要产品好，就停不下来。品牌和口碑都诉诸于信任，但口碑有生命力。口碑是粉丝经济的润滑剂。

5、信任是生活和商业的润滑剂。没信任，就比如大集市，喧嚣、砍价、欺诈、一锤子买卖。有信任，就比如俱乐部，静谧、默契、平等、长久。

当互联网把物理世界的限制冲破后，基于“信任”的模式开始在生活和商业的领地中长驱直入。

<img src="http://mmbiz.qpic.cn/mmbiz/zQA07qfQ8IydMrMKgqZm3UnaYreOTvEMNTKVPHbCDBFeOwlQpRdUR8KEC57FtOhibeWlmfjc5kVBHYUSCKPdvfA/0" alt="" data-size="300,640" data-src="http://mmbiz.qpic.cn/mmbiz/zQA07qfQ8IydMrMKgqZm3UnaYreOTvEMNTKVPHbCDBFeOwlQpRdUR8KEC57FtOhibeWlmfjc5kVBHYUSCKPdvfA/0" />

</div>
<p id="js_toobar" class="page-toolbar" style="color: #222222;"> （转载自孕峰）</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>128</wp:post_id>
		<wp:post_date>2014-07-17 17:53:23</wp:post_date>
		<wp:post_date_gmt>2014-07-17 09:53:23</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%b2%89%e4%b8%9d%e7%bb%8f%e6%b5%8e%ef%bc%9a%e8%ae%a9%e4%bf%a1%e4%bb%bb%e6%88%90%e4%b8%ba%e4%ba%a4%e6%98%93%e9%80%9a%e9%81%93</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e7%b2%89%e4%b8%9d%e7%bb%8f%e6%b5%8e"><![CDATA[粉丝经济]]></category>
		<category domain="category" nicename="self-media"><![CDATA[自媒体]]></category>
		<category domain="post_tag" nicename="%e8%87%aa%e5%aa%92%e4%bd%93"><![CDATA[自媒体]]></category>
	</item>
	<item>
				<title>Python教程01 - 输入与输出</title>
		<link>http://localhost:81/wordpress/?p=131</link>
		<pubDate>Thu, 17 Jul 2014 14:34:35 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=131</guid>
		<description></description>
		<content:encoded><![CDATA[<h3 id="-" style="font-weight: bold; color: #333333;">输出</h3>
<p style="color: #333333;">用<strong>print</strong>加上字符串，就可以向屏幕上输出指定的文字。比如输出<strong>'hello, world'</strong>，用代码实现如下：</p>

<pre lang="python" line="1" escaped="true">&gt;&gt;&gt; print 'hello, world'
</pre>
<p style="color: #333333;"><strong>print</strong>语句也可以跟上多个字符串，用逗号“,”隔开，就可以连成一串输出：</p>

<pre lang="python" line="1" escaped="true">&gt;&gt;&gt; print 'The quick brown fox', 'jumps over', 'the lazy dog'
The quick brown fox jumps over the lazy dog
</pre>
<p style="color: #333333;"><span style="color: #ff0000;"><strong>print</strong></span>会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：</p>
<p style="color: #333333;"><img src="http://www.liaoxuefeng.com/files/attachments/001387105931284e8f62577e11647c899505d8eb8d09c7d000/0" alt="print-howto" /></p>
<p style="color: #333333;"><strong>print</strong>也可以打印整数，或者计算结果：</p>

<pre style="color: #333333;"><code style="color: inherit;">&gt;&gt;&gt; print 300
300
&gt;&gt;&gt; print 100 + 200
300
</code></pre>
<p style="color: #333333;">因此，我们可以把计算<strong><span style="color: #ff0000;">100 + 200</span></strong>的结果打印得更漂亮一点：</p>

<pre lang="python" line="1" escaped="true">&gt;&gt;&gt; print '100 + 200 =', 100 + 200
100 + 200 = 300
</pre>
<p style="color: #333333;">注意，对于<strong><span style="color: #ff0000;">100 + 200</span></strong>，Python解释器自动计算出结果<strong><span style="color: #ff0000;">300</span></strong>，但是，'100 + 200 ='是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。</p>

<h3 id="-" style="font-weight: bold; color: #333333;">输入</h3>
<p style="color: #333333;">现在，你已经可以用<strong><span style="color: #ff0000;">print</span></strong>输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个<strong><span style="color: #ff0000;">raw_input</span></strong>，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：</p>

<pre lang="python" line="1" escaped="true">&gt;&gt;&gt; name = raw_input()
Michael
</pre>
<p style="color: #333333;">当你输入<strong><span style="color: #ff0000;">name = raw_input()</span></strong>并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。</p>
<p style="color: #333333;">输入完成后，不会有任何提示，Python交互式命令行又回到<code style="color: #dd1144;">&gt;&gt;&gt;</code>状态了。那我们刚才输入的内容到哪去了？答案是存放到<strong><span style="color: #ff0000;">name</span></strong>变量里了。可以直接输入<strong><span style="color: #ff0000;">name</span></strong>查看变量内容：</p>

<pre style="color: #333333;"><code style="color: inherit;">&gt;&gt;&gt; name
'Michael'
</code></pre>
<p style="color: #333333;"><strong>什么是变量？
</strong></p>
<p style="color: #333333;">在这里就不详细说了，比较好理解的一个概念。在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，<strong>name</strong>作为一个变量就是一个字符串。</p>
<p style="color: #333333;">要打印出<strong><span style="color: #ff0000;">name</span></strong>变量的内容，除了直接写<strong><span style="color: #ff0000;">name</span></strong>然后按回车外，还可以用<strong><span style="color: #ff0000;">print</span></strong>语句：</p>

<pre lang="python" line="1" escaped="true">&gt;&gt;&gt; print name
Michael
</pre>
<p style="color: #333333;">有了输入和输出，我们就可以把上次打印<strong><span style="color: #ff0000;">'hello, world'</span></strong>的程序改成有点意义的程序了：</p>

<pre lang="python" line="1" escaped="true">name = raw_input()
print 'hello,', name
</pre>
<p style="color: #333333;">运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入<code style="color: #dd1144;">name</code>变量中；第二行代码会根据用户的名字向用户说<code style="color: #dd1144;">hello</code>，比如输入<strong><span style="color: #ff0000;">Michael</span></strong>：</p>

<pre lang="python" line="1" escaped="true">C:\Workspace&gt; python hello.py
Michael
hello, Michael
</pre>
<p style="color: #333333;">但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，<strong><span style="color: #ff0000;">raw_input</span></strong>可以让你显示一个字符串来提示用户，于是我们把代码改成：</p>

<pre lang="python" line="1" escaped="true">name = raw_input('please enter your name: ')
print 'hello,', name
</pre>
<p style="color: #333333;">再次运行这个程序，你会发现，程序一运行，会首先打印出<strong><span style="color: #ff0000;">please enter your name:</span></strong>，这样，用户就可以根据提示，输入名字后，得到<code style="color: #dd1144;">hello, xxx</code>的输出：</p>

<pre lang="python" line="1" escaped="true">C:\Workspace&gt; python hello.py
please enter your name: Michael
hello, Michael
</pre>
<p style="color: #333333;">每次运行该程序，根据用户输入的不同，输出结果也会不同。</p>
<p style="color: #333333;">在命令行下，输入和输出就是这么简单。</p>

<h3 id="-" style="font-weight: bold; color: #333333;">小结</h3>
<p style="color: #333333;">任何计算机程序都是为了执行一个特定的任务，有了输入，用户才能告诉计算机程序所需的信息，有了输出，程序运行后才能告诉用户任务的结果。</p>
<p style="color: #333333;">输入是Input，输出是Output，因此，我们把输入输出统称为Input/Output，或者简写为IO。</p>
<p style="color: #333333;"><strong><span style="color: #ff0000;">raw_input</span></strong>和<strong><span style="color: #ff0000;">print</span></strong>是在命令行下面最基本的输入和输出，但是，用户也可以通过其他更高级的图形界面完成输入和输出，比如，在网页上的一个文本框输入自己的名字，点击“确定”后在网页上看到输出信息。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date>2014-07-17 22:34:35</wp:post_date>
		<wp:post_date_gmt>2014-07-17 14:34:35</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>python%e6%95%99%e7%a8%8b01-%e8%be%93%e5%85%a5%e4%b8%8e%e8%be%93%e5%87%ba</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="post_tag" nicename="python"><![CDATA[Python]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
	</item>
	<item>
				<title>Python教程02 – 基础</title>
		<link>http://localhost:81/wordpress/?p=134</link>
		<pubDate>Thu, 17 Jul 2014 14:43:21 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=134</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="color: #333333;">Python的语法比较简单，采用缩进方式，写出来的代码就像下面的样子：</p>

<pre lang="python" line="1" escaped="true"># print absolute value of an integer:
a = 100
if a &gt;= 0:
    print a
else:
    print -a
</pre>
<p style="color: #333333;">以<code style="color: #dd1144;">#</code>开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。</p>
<p style="color: #333333;">缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用<span style="color: red;">4个空格</span>的缩进。</p>
<p style="color: #333333;">缩进的另一个好处是强迫你写出缩进较少的代码，你会倾向于把一段很长的代码拆分成若干函数，从而得到缩进较少的代码。</p>
<p style="color: #333333;">缩进的坏处就是“复制－粘贴”功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。此外，IDE很难像格式化Java代码那样格式化Python代码。</p>
<p style="color: #333333;">最后，请务必注意，Python程序是<span style="color: red;">大小写敏感</span>的，如果写错了大小写，程序会报错。</p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>134</wp:post_id>
		<wp:post_date>2014-07-17 22:43:21</wp:post_date>
		<wp:post_date_gmt>2014-07-17 14:43:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>python%e6%95%99%e7%a8%8b02-%e5%9f%ba%e7%a1%80</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="python"><![CDATA[Python]]></category>
		<category domain="post_tag" nicename="python"><![CDATA[Python]]></category>
	</item>
	<item>
				<title>MWA 框架 01 - 概述</title>
		<link>http://localhost:81/wordpress/?p=142</link>
		<pubDate>Thu, 01 Jan 1970 00:00:00 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=142</guid>
		<description></description>
		<content:encoded><![CDATA[目录结构：

01. MWA 概述 （简单介绍Oracle Mobile Application 与MWA开发框架的overview）

02. MWA/MSCA 整体架构介绍

03. MWA Server基本配置与命令（启动服务，关闭服务等）

04.]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>142</wp:post_id>
		<wp:post_date>2014-07-25 18:39:47</wp:post_date>
		<wp:post_date_gmt>0000-00-00 00:00:00</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name></wp:post_name>
		<wp:status>draft</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
	</item>
	<item>
				<title>How to create a Category Set and Assign Items to Categories ?</title>
		<link>http://localhost:81/wordpress/?p=144</link>
		<pubDate>Wed, 30 Jul 2014 02:33:47 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=144</guid>
		<description></description>
		<content:encoded><![CDATA[<span style="color: #000000;">Categories are the method by which the items in inventory can be separated logically and functionally for planning, purchasing and other activities.</span><span class="Apple-style-span" style="color: #000000;">You can use categories and category sets to group your items for various reports and programs. A category is a logical classification of items that have similar characteristics. A category set is a distinct grouping scheme and consists of categories. The flexibility of category sets allows you to report and inquire on items in a way that best suits your needs. This article will describe how to create categories and category set in oracle inventory.</span>
<p style="color: #202020;"><span class="Apple-style-span" style="color: #000000;">Suppose we need a category called ‘INV_COLORS’. We can define multiple colors in this category and then assign this category to an item.</span></p>
<p style="color: #202020;"><span class="Apple-style-span" style="color: #000000;">Example:</span></p>

<ol style="color: #202020;">
	<li>Item1 —- Black</li>
	<li>Item2 —- Red</li>
	<li>Item3 —- Green</li>
	<li>Item4 —- Orange</li>
</ol>
<p style="color: #202020;"><strong><span class="Apple-style-span" style="color: #000000;">1] First we need to create a value set to hold these colors.</span></strong></p>
<p style="color: #202020;"><em><strong><span class="Apple-style-span" style="color: #000000;">Navigation &gt; Setup: Flexfields: Validation: Sets</span></strong></em></p>
<p style="color: #202020;"><span class="Apple-style-span" style="color: #000000;">Validation type Select: Independent</span></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/1-value-set.jpg" target="_blank"><img class="aligncenter  wp-image-1853" title="1-Value Set" src="http://myoraclecafe.com/wp-content/uploads/2011/07/1-value-set.jpg" alt="" width="581" height="313" /></a></p>
<p style="color: #202020;"><strong><span class="Apple-style-span" style="color: #000000;">2] Next we need to enter our values in the INVENTORY_COLOR valueset</span></strong></p>
<p style="color: #202020;"><span style="color: #000000;"><span style="color: #ff0000;">RED</span>, <span style="color: #008000;">GREEN</span>, <span style="color: #0000ff;">BLUE</span>, BLACK, and <span style="color: #ff6600;">ORANGE</span></span></p>
<p style="color: #202020;"><em><strong><span style="color: #000000;">Navigation -&gt; Setup: Flexfields: Validation: Values</span></strong></em></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/2-value-set-values.jpg" target="_blank"><img class="aligncenter  wp-image-1854" title="2-Value Set Values" src="http://myoraclecafe.com/wp-content/uploads/2011/07/2-value-set-values.jpg" alt="" width="581" height="388" /></a></p>
<p style="color: #202020;"><span style="color: #000000;">Save and close the Screen.</span></p>
<p style="color: #202020;"><strong><span style="color: #000000;">3] Now we need to create a KFF Structure</span></strong></p>
<p style="color: #202020;"><em><strong><span style="color: #000000;">Navigation Setup: Flexfields: Key: Segments</span></strong></em></p>
<p style="color: #202020;"><span class="Apple-style-span" style="color: #000000;">Create the structure name: In the “Code” field enter INV_COLORS</span></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/3-create-kff.jpg" target="_blank"><img class="aligncenter  wp-image-1855" title="3-Create KFF" src="http://myoraclecafe.com/wp-content/uploads/2011/07/3-create-kff.jpg" alt="" width="581" height="353" /></a></p>
<p style="color: #202020;"><strong><span class="Apple-style-span" style="color: #000000;">4] Click on the “Segments” button.</span></strong></p>

<ul style="color: #202020;">
	<li><span class="Apple-style-span" style="color: #000000;">Enter the “Number” field: 10</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Enter the Name field: Color</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Enter the “Window Prompt”: Color (This value will appear on the screen)</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Enter the “Column” field: Segment1 (you can choose any column)</span></li>
</ul>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/4-create-segments.jpg" target="_blank"><img class="aligncenter  wp-image-1856" title="4-Create segments" src="http://myoraclecafe.com/wp-content/uploads/2011/07/4-create-segments.jpg" alt="" width="581" height="313" /></a></p>
<p style="color: #202020;"><span style="color: #000000;">Save and exit the form.</span></p>
<p style="color: #202020;"><strong><span style="color: #000000;">5] Check the Freeze flex field Definition, the following warning will appear.</span></strong></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/5-freeze-kff.jpg" target="_blank"><img class="aligncenter  wp-image-1857" title="5-Freeze KFF" src="http://myoraclecafe.com/wp-content/uploads/2011/07/5-freeze-kff.jpg" alt="" width="581" height="349" /></a></p>
<p style="color: #202020;"><span style="color: #000000;">Click OK.</span></p>
<p style="color: #202020;"><strong><span class="Apple-style-span" style="color: #000000;">6] The “Compile” button is now available to be selected. </span><span class="Apple-style-span" style="color: #000000;">Click on the compile button.</span></strong></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/6-compile-kff.jpg" target="_blank"><img class="aligncenter  wp-image-1858" title="6-Compile KFF" src="http://myoraclecafe.com/wp-content/uploads/2011/07/6-compile-kff.jpg" alt="" width="581" height="351" /></a></p>
<p style="color: #202020;"><span class="Apple-style-span" style="color: #000000;">Click Ok</span></p>
<p style="color: #202020;"><span style="color: #000000;">Close the form.</span></p>
<p style="color: #202020;"><strong><span style="color: #000000;">7] Go to View -&gt; Request and Verify that the new Category flexfield compiled successfully.</span></strong></p>
<p style="color: #202020;"><strong><span class="Apple-style-span" style="color: #000000;">8] The new structure is ready for use. Now let’s create a category.</span></strong></p>
<p style="color: #202020;"><em><strong><span class="Apple-style-span" style="color: #000000;">Navigation : Setup: Items: Categories: Category Codes</span></strong></em></p>

<ul style="color: #202020;">
	<li><span class="Apple-style-span" style="color: #000000;">Enter the structure name: INV_COLORES</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Enter the category: BLACK</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">(Note the form does not provide an LOV for the categories. You will need to use edit symbol at the top of the page or “ e “ to bring up the lov)</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Enter the description.</span></li>
</ul>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/7-setting-up-a-category.jpg" target="_blank"><img class="aligncenter  wp-image-1859" title="7-Setting up a category" src="http://myoraclecafe.com/wp-content/uploads/2011/07/7-setting-up-a-category.jpg" alt="" width="581" height="411" /></a></p>
<p style="color: #202020;"><strong><span style="color: #000000;">9] Next we create our category set.</span></strong></p>
<p style="color: #202020;"><em><strong><span style="color: #000000;">Navigation Setup: Items: Categories: Category Sets</span></strong></em></p>

<ul style="color: #202020;">
	<li><span class="Apple-style-span" style="color: #000000;">Fill in the category set Name: INV_COLORS_SET</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">The description: Inventory color set</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">The Flex Structure: INV_COLORS</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">The Controlled: Org Level</span></li>
	<li><span class="Apple-style-span" style="color: #000000;">Default Category: BLACK</span></li>
</ul>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/8-create-a-category-set.jpg" target="_blank"><img class="aligncenter size-full wp-image-1851" title="8-Create a Category Set" src="http://myoraclecafe.com/wp-content/uploads/2011/07/8-create-a-category-set.jpg" alt="" width="521" height="490" /></a></p>
<p style="color: #202020;"><strong><span style="color: #000000;">10] After creating the category set, we can assign it to any items.</span></strong></p>
<p style="color: #202020;"><a style="color: #0080ff;" href="http://myoraclecafe.com/wp-content/uploads/2011/07/9-category-assinment.jpg" target="_blank"><img class="aligncenter size-full wp-image-1852" title="9-Category Assinment" src="http://myoraclecafe.com/wp-content/uploads/2011/07/9-category-assinment.jpg" alt="" width="484" height="407" /></a></p>
<p style="color: #202020;"><span style="color: #000000;">There are few category APIs that will be discussed in upcoming posts. Till then GOOD BYE………!! Have a nice day!</span></p>
<p style="color: #202020;"><span style="color: #000000;"><strong>Reference: How to create a Category Set and Assign Items to Categories [MOS ID 423551.1]</strong></span></p>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>144</wp:post_id>
		<wp:post_date>2014-07-30 10:33:47</wp:post_date>
		<wp:post_date_gmt>2014-07-30 02:33:47</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>how-to-create-a-category-set-and-assign-items-to-categories</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="category"><![CDATA[Category]]></category>
		<category domain="post_tag" nicename="ebs-2"><![CDATA[EBS]]></category>
		<category domain="category" nicename="inv"><![CDATA[INV]]></category>
		<category domain="post_tag" nicename="inventory"><![CDATA[Inventory]]></category>
	</item>
	<item>
				<title>一千行MySQL学习笔记</title>
		<link>http://localhost:81/wordpress/?p=155</link>
		<pubDate>Wed, 30 Jul 2014 07:40:01 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=155</guid>
		<description></description>
		<content:encoded><![CDATA[<pre lang="sql" line="1" escaped="true">/* 启动MySQL */
net start mysql

/* 连接与断开服务器 */
mysql -h 地址 -P 端口 -u 用户名 -p 密码

/* 跳过权限验证登录MySQL */
mysqld --skip-grant-tables
-- 修改root密码
密码加密函数password()
update mysql.user set password=password('root');

SHOW PROCESSLIST -- 显示哪些线程正在运行
SHOW VARIABLES -- 

/* 数据库操作 */ ------------------
-- 查看当前数据库
    select database();
-- 显示当前时间、用户名、数据库版本
    select now(), user(), version();
-- 创建库
    create database[ if not exists] 数据库名 数据库选项
    数据库选项：
        CHARACTER SET charset_name
        COLLATE collation_name
-- 查看已有库
    show databases[ like 'pattern']
-- 查看当前库信息
    show create database 数据库名
-- 修改库的选项信息
    alter database 库名 选项信息
-- 删除库
    drop database[ if exists] 数据库名
        同时删除该数据库相关的目录及其目录内容

/* 表的操作 */ ------------------
-- 创建表
    create [temporary] table[ if not exists] [库名.]表名 ( 表的结构定义 )[ 表选项]
        每个字段必须有数据类型
        最后一个字段后不能有逗号
        temporary 临时表，会话结束时表自动消失
        对于字段的定义：
            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT 'string']
-- 表选项
    -- 字符集
        CHARSET = charset_name
        如果表没有设定，则使用数据库字符集
    -- 存储引擎
        ENGINE = engine_name    
        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同
        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive
        不同的引擎在保存表的结构和数据时采用不同的方式
        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引
        InnoDB表文件含义：.frm表定义，表空间数据和日志文件
        SHOW ENGINES -- 显示存储引擎的状态信息
        SHOW ENGINE 引擎名 {LOGS|STATUS} -- 显示存储引擎的日志或状态信息
    -- 数据文件目录
        DATA DIRECTORY = '目录'
    -- 索引文件目录
        INDEX DIRECTORY = '目录'
    -- 表注释
        COMMENT = 'string'
    -- 分区选项
        PARTITION BY ... (详细见手册)
-- 查看所有表
    SHOW TABLES[ LIKE 'pattern']
    SHOW TABLES FROM 表名
-- 查看表机构
    SHOW CREATE TABLE 表名    （信息更详细）
    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE 'PATTERN']
    SHOW TABLE STATUS [FROM db_name] [LIKE 'pattern']
-- 修改表
    -- 修改表本身的选项
        ALTER TABLE 表名 表的选项
        EG:    ALTER TABLE 表名 ENGINE=MYISAM;
    -- 对表进行重命名
        RENAME TABLE 原表名 TO 新表名
        RENAME TABLE 原表名 TO 库名.表名    （可将表移动到另一个数据库）
        -- RENAME可以交换两个表名
    -- 修改表的字段机构
        ALTER TABLE 表名 操作名
        -- 操作名
            ADD[ COLUMN] 字段名        -- 增加字段
                AFTER 字段名            -- 表示增加在该字段名后面
                FIRST                -- 表示增加在第一个
            ADD PRIMARY KEY(字段名)    -- 创建主键
            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引
            ADD INDEX [索引名] (字段名)    -- 创建普通索引
            ADD 
            DROP[ COLUMN] 字段名        -- 删除字段
            MODIFY[ COLUMN] 字段名 字段属性        -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)
            CHANGE[ COLUMN] 原字段名 新字段名 字段属性        -- 支持对字段名修改
            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)
            DROP INDEX 索引名    -- 删除索引
            DROP FOREIGN KEY 外键    -- 删除外键

-- 删除表
    DROP TABLE[ IF EXISTS] 表名 ...
-- 清空表数据
    TRUNCATE [TABLE] 表名
-- 复制表结构
    CREATE TABLE 表名 LIKE 要复制的表名
-- 复制表结构和数据
    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名
-- 检查表是否有错误
    CHECK TABLE tbl_name [, tbl_name] ... [option] ...
-- 优化表
    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...
-- 修复表
    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]
-- 分析表
    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...



/* 数据操作 */ ------------------
-- 增
    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]
        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。
        -- 可同时插入多条数据记录！
        REPLACE 与 INSERT 完全一样，可互换。
    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]
-- 查
    SELECT 字段列表 FROM 表名[ 其他子句]
        -- 可来自多个表的多个字段
        -- 其他子句可以不使用
        -- 字段列表可以用*代替，表示所有字段
-- 删
    DELETE FROM 表名[ 删除条件子句]
        没有条件子句，则会删除全部
-- 改
    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]

/* 字符集编码 */ ------------------
-- MySQL、数据库、表、字段均可设置编码
-- 数据编码与客户端编码不需一致
SHOW VARIABLES LIKE 'character_set_%'    -- 查看所有字符集编码项
    character_set_client        客户端向服务器发送数据时使用的编码
    character_set_results        服务器端将结果返回给客户端所使用的编码
    character_set_connection    连接层编码
SET 变量名 = 变量值
    set character_set_client = gbk;
    set character_set_results = gbk;
    set character_set_connection = gbk;
SET NAMES GBK;    -- 相当于完成以上三个设置
-- 校对集
    校对集用以排序
    SHOW CHARACTER SET [LIKE 'pattern']/SHOW CHARSET [LIKE 'pattern']    查看所有字符集
    SHOW COLLATION [LIKE 'pattern']        查看所有校对集
    charset 字符集编码        设置字符集编码
    collate 校对集编码        设置校对集编码

/* 数据类型（列类型） */ ------------------
1. 数值类型
-- a. 整型 ----------
    类型            字节        范围（有符号位）
    tinyint        1字节    -128 ~ 127        无符号位：0 ~ 255
    smallint    2字节    -32768 ~ 32767
    mediumint    3字节    -8388608 ~ 8388607
    int            4字节
    bigint        8字节

    int(M)    M表示总位数
    - 默认存在符号位，unsigned 属性修改
    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改
        例：int(5)    插入一个数'123'，补填后为'00123'
    - 在满足要求的情况下，越小越好。
    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。

-- b. 浮点型 ----------
    类型                字节        范围
    float(单精度)        4字节
    double(双精度)    8字节
    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。
        不同于整型，前后均会补填0.
    定义浮点型时，需指定总位数和小数位数。
        float(M, D)        double(M, D)
        M表示总位数，D表示小数位数。
        M和D的大小会决定浮点数的范围。不同于整型的固定范围。
        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。
        支持科学计数法表示。
        浮点数表示近似值。

-- c. 定点数 ----------
    decimal    -- 可变长度
    decimal(M, D)    M也表示总位数，D表示小数位数。
    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。
    将浮点数转换为字符串来保存，每9位数字保存为4个字节。

2. 字符串类型
-- a. char, varchar ----------
    char    定长字符串，速度快，但浪费空间
    varchar    变长字符串，速度慢，但节省空间
    M表示能存储的最大长度，此长度是字符数，非字节数。
    不同的编码，所占用的空间不同。
    char,最多255个字符，与编码无关。
    varchar,最多65535字符，与编码有关。
    一条有效记录最大不能超过65535个字节。
        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符
    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。
    varchar 的最大有效长度由最大行大小和使用的字符集确定。
    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。
    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3

-- b. blob, text ----------
    blob 二进制字符串（字节字符串）
        tinyblob, blob, mediumblob, longblob
    text 非二进制字符串（字符字符串）
        tinytext, text, mediumtext, longtext
    text 在定义时，不需要定义长度，也不会计算总长度。
    text 类型在定义时，不可给default值

-- c. binary, varbinary ----------
    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。
    char, varchar, text 对应 binary, varbinary, blob.

3. 日期时间类型
    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。
    datetime    8字节    日期及时间        1000-01-01 00:00:00 到 9999-12-31 23:59:59
    date        3字节    日期            1000-01-01 到 9999-12-31
    timestamp    4字节    时间戳        19700101000000 到 2038-01-19 03:14:07
    time        3字节    时间            -838:59:59 到 838:59:59
    year        1字节    年份            1901 - 2155
    
datetime    “YYYY-MM-DD hh:mm:ss”
timestamp    “YY-MM-DD hh:mm:ss”
            “YYYYMMDDhhmmss”
            “YYMMDDhhmmss”
            YYYYMMDDhhmmss
            YYMMDDhhmmss
date        “YYYY-MM-DD”
            “YY-MM-DD”
            “YYYYMMDD”
            “YYMMDD”
            YYYYMMDD
            YYMMDD
time        “hh:mm:ss”
            “hhmmss”
            hhmmss
year        “YYYY”
            “YY”
            YYYY
            YY

4. 枚举和集合
-- 枚举(enum) ----------
enum(val1, val2, val3...)
    在已知的值中进行单选。最大数量为65535.
    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。
    表现为字符串类型，存储却是整型。
    NULL值的索引是NULL。
    空字符串错误值的索引值是0。

-- 集合（set） ----------
set(val1, val2, val3...)
    create table tab ( gender set('男', '女', '无') );
    insert into tab values ('男, 女');
    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。
    当创建表时，SET成员值的尾部空格将自动被删除。

/* 选择类型 */
-- PHP角度
1. 功能满足
2. 存储空间尽量小，处理效率更高
3. 考虑兼容问题

-- IP存储 ----------
1. 只需存储，可用字符串
2. 如果需计算，查找等，可存储为4个字节的无符号int，即unsigned
    1) PHP函数转换
        ip2long可转换为整型，但会出现携带符号问题。需格式化为无符号的整型。
        利用sprintf函数格式化字符串
        sprintf("%u", ip2long('192.168.3.134'));
        然后用long2ip将整型转回IP字符串
    2) MySQL函数转换(无符号整型，UNSIGNED)
        INET_ATON('127.0.0.1') 将IP转为整型
        INET_NTOA(2130706433) 将整型转为IP
        



/* 列属性（列约束） */ ------------------
1. 主键
    - 能唯一标识记录的字段，可以作为主键。
    - 一个表只能有一个主键。
    - 主键具有唯一性。
    - 声明字段时，用 primary key 标识。
        也可以在字段列表之后声明
            例：create table tab ( id int, stu varchar(10), primary key (id));
    - 主键字段的值不能为null。
    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。
        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));

2. unique 唯一索引（唯一约束）
    使得某字段的值也不能重复。
    
3. null 约束
    null不是数据类型，是列的一个属性。
    表示当前列是否可以为null，表示什么都没有。
    null, 允许为空。默认。
    not null, 不允许为空。
    insert into tab values (null, 'val');
        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null
    
4. default 默认值属性
    当前字段的默认值。
    insert into tab values (default, 'val');    -- 此时表示强制使用默认值。
    create table tab ( add_time timestamp default current_timestamp );
        -- 表示将当前时间的时间戳设为默认值。
        current_date, current_time

5. auto_increment 自动增长约束
    自动增长必须为索引（主键或unique）
    只能存在一个字段为自动增长。
    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;

6. comment 注释
    例：create table tab ( id int ) comment '注释内容';

7. foreign key 外键约束
    用于限制主表与从表数据完整性。
    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);
        -- 将表t1的t1_id外键关联到表t2的id字段。
        -- 每个外键都有一个名字，可以通过 constraint 指定

    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。

    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。

    MySQL中，可以对InnoDB引擎使用外键约束：
    语法：
    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]
    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。

    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。
    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：
    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。
    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。
    3. restrict，拒绝父表删除和更新。

    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。


/* 建表规范 */ ------------------
    -- Normal Format, NF
        - 每个表保存一个实体信息
        - 每个具有一个ID字段作为主键
        - ID主键 + 原子表
    -- 1NF, 第一范式
        字段不能再分，就满足第一范式。
    -- 2NF, 第二范式
        满足第一范式的前提下，不能出现部分依赖。
        消除符合主键就可以避免部分依赖。增加单列关键字。
    -- 3NF, 第三范式
        满足第二范式的前提下，不能出现传递依赖。
        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。
        将一个实体信息的数据放在一个表内实现。


/* select */ ------------------

select [all|distinct] select_expr from -&gt; where -&gt; group by [合计函数] -&gt; having -&gt; order by -&gt; limit

a. select_expr
    -- 可以用 * 表示所有字段。
        select * from tb;
    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）
        select stu, 29+25, now() from tb;
    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。
        - 使用 as 关键字，也可省略 as.
        select stu+10 as add10 from tb;

b. from 子句
    用于标识查询来源。
    -- 可以为表起别名。使用as关键字。
        select * from tb1 as tt, tb2 as bb;
    -- from子句后，可以同时出现多个表。
        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。
        select * from tb1, tb2;

c. where 子句
    -- 从from获得的数据源中进行筛选。
    -- 整型1表示真，0表示假。
    -- 表达式由运算符和运算数组成。
        -- 运算数：变量（字段）、值、函数返回值
        -- 运算符：
            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||, 
            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor
            is/is not 加上ture/false/unknown，检验某个值的真假
            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较

d. group by 子句, 分组子句
    group by 字段/别名 [排序方式]
    分组后会进行排序。升序：ASC，降序：DESC
    
    以下[合计函数]需配合 group by 使用：
    count 返回不同的非NULL值数目    count(*)、count(字段)
    sum 求和
    max 求最大值
    min 求最小值
    avg 求平均值
    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。

e. having 子句，条件子句
    与 where 功能、用法相同，执行时机不同。
    where 在开始时执行检测数据，对原数据进行过滤。
    having 对筛选出的结果再次进行过滤。
    having 字段必须是查询出来的，where 字段必须是数据表存在的。
    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。
    where 不可以使用合计函数。一般需用合计函数才会用 having
    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。

f. order by 子句，排序子句
    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...
    升序：ASC，降序：DESC
    支持多个字段的排序。

g. limit 子句，限制结果数量子句
    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。
    limit 起始位置, 获取条数
    省略第一个参数，表示从索引0开始。limit 获取条数

h. distinct, all 选项
    distinct 去除重复记录
    默认为 all, 全部记录


/* UNION */ ------------------
    将多个select查询的结果组合成一个结果集合。
    SELECT ... UNION [ALL|DISTINCT] SELECT ...
    默认 DISTINCT 方式，即所有返回的行都是唯一的
    建议，对每个SELECT查询加上小括号包裹。
    ORDER BY 排序时，需加上 LIMIT 进行结合。
    需要各select查询的字段数量一样。
    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。


/* 子查询 */ ------------------
    - 子查询需用括号包裹。
-- from型
    from后要求是一个表，必须给子查询结果取个别名。
    - 简化每个查询内的条件。
    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。
    - 子查询返回一个表，表型子查询。
    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;
-- where型
    - 子查询返回一个值，标量子查询。
    - 不需要给子查询取别名。
    - where子查询内的表，不能直接用以更新。
    select * from tb where money = (select max(money) from tb);
    -- 列子查询
        如果子查询结果返回的是一列。
        使用 in 或 not in 完成查询
        exists 和 not exists 条件
            如果子查询返回数据，则返回1或0。常用于判断条件。
            select column1 from t1 where exists (select * from t2);
    -- 行子查询
        查询条件是一个行。
        select * from t1 where (id, gender) in (select id, gender from t2);
        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)
        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。

    -- 特殊运算符
    != all()    相当于 not in
    = some()    相当于 in。any 是 some 的别名
    != some()    不等同于 not in，不等于其中某一个。
    all, some 可以配合其他运算符一起使用。


/* 连接查询(join) */ ------------------
    将多个表的字段进行连接，可以指定连接条件。
-- 内连接(inner join)
    - 默认就是内连接，可省略inner。
    - 只有数据存在时才能发送连接。即连接结果不能出现空行。
    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）
    也可用where表示连接条件。
    还有 using, 但需字段名相同。 using(字段名)

    -- 交叉连接 cross join
        即，没有条件的内连接。
        select * from tb1 cross join tb2;
-- 外连接(outer join)
    - 如果数据不存在，也会出现在连接结果中。
    -- 左外连接 left join
        如果数据不存在，左表记录会出现，而右表为null填充
    -- 右外连接 right join
        如果数据不存在，右表记录会出现，而左表为null填充
-- 自然连接(natural join)
    自动判断连接条件完成连接。
    相当于省略了using，会自动查找相同字段名。
    natural join
    natural left join
    natural right join

select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;

/* 导入导出 */ ------------------
select * into outfile 文件地址 [控制格式] from 表名;    -- 导出表数据
load data [local] infile 文件地址 [replace|ignore] into table 表名 [控制格式];    -- 导入数据
    生成的数据默认的分隔符是制表符
    local未指定，则数据文件必须在服务器上
    replace 和 ignore 关键词控制对现有的唯一键记录的重复的处理
-- 控制格式
fields    控制字段格式
默认：fields terminated by '\t' enclosed by '' escaped by '\\'
    terminated by 'string'    -- 终止
    enclosed by 'char'        -- 包裹
    escaped by 'char'        -- 转义
    -- 示例：
        SELECT a,b,a+b INTO OUTFILE '/tmp/result.text'
        FIELDS TERMINATED BY ',' OPTIONALLY ENCLOSED BY '"'
        LINES TERMINATED BY '\n'
        FROM test_table;
lines    控制行格式
默认：lines terminated by '\n'
    terminated by 'string'    -- 终止
    
/* insert */ ------------------
select语句获得的数据可以用insert插入。

可以省略对列的指定，要求 values () 括号内，提供给了按照列顺序出现的所有字段的值。
    或者使用set语法。
    insert into tbl_name set field=value,...；

可以一次性使用多个值，采用(), (), ();的形式。
    insert into tbl_name values (), (), ();

可以在列值指定时，使用表达式。
    insert into tbl_name values (field_value, 10+10, now());
可以使用一个特殊值 default，表示该列使用默认值。
    insert into tbl_name values (field_value, default);

可以通过一个查询的结果，作为需要插入的值。
    insert into tbl_name select ...;

可以指定在插入的值出现主键（或唯一索引）冲突时，更新其他非主键列的信息。
    insert into tbl_name values/set/select on duplicate key update 字段=值, …;

/* delete */ ------------------
DELETE FROM tbl_name [WHERE where_definition] [ORDER BY ...] [LIMIT row_count]

按照条件删除

指定删除的最多记录数。Limit

可以通过排序条件删除。order by + limit

支持多表删除，使用类似连接语法。
delete from 需要删除数据多表1，表2 using 表连接操作 条件。

/* truncate */ ------------------
TRUNCATE [TABLE] tbl_name
清空数据
删除重建表

区别：
1，truncate 是删除表再创建，delete 是逐条删除
2，truncate 重置auto_increment的值。而delete不会
3，truncate 不知道删除了几条，而delete知道。
4，当被用于带分区的表时，truncate 会保留分区


/* 备份与还原 */ ------------------
备份，将数据的结构与表内数据保存起来。
利用 mysqldump 指令完成。

-- 导出
1. 导出一张表
　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)
2. 导出多张表
　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)
3. 导出所有表
　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)
4. 导出一个库 
　　mysqldump -u用户名 -p密码 -B 库名 &gt; 文件名(D:/a.sql)

可以-w携带备份条件

-- 导入
1. 在登录mysql的情况下：
　　source  备份文件
2. 在不登录的情况下
　　mysql -u用户名 -p密码 库名 &lt; 备份文件


/* 视图 */ ------------------
什么是视图：
    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。
    视图具有表结构文件，但不存在数据文件。
    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。
    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。

-- 创建视图
CREATE [OR REPLACE] [ALGORITHM = {UNDEFINED | MERGE | TEMPTABLE}] VIEW view_name [(column_list)] AS select_statement
    - 视图名必须唯一，同时不能与表重名。
    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。
    - 可以指定视图执行的算法，通过ALGORITHM指定。
    - column_list如果存在，则数目必须等于SELECT语句检索的列数

-- 查看结构
    SHOW CREATE VIEW view_name 

-- 删除视图
    - 删除视图后，数据依然存在。
    - 可同时删除多个视图。
    DROP VIEW [IF EXISTS] view_name ...

-- 修改视图结构
    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。
    ALTER VIEW view_name [(column_list)] AS select_statement

-- 视图作用
    1. 简化业务逻辑
    2. 对客户端隐藏真实的表结构

-- 视图算法(ALGORITHM)
    MERGE        合并
        将视图的查询语句，与外部查询需要先合并再执行！
    TEMPTABLE    临时表
        将视图执行完毕后，形成临时表，再做外层查询！
    UNDEFINED    未定义(默认)，指的是MySQL自主去选择相应的算法。



/* 事务(transaction) */ ------------------
事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。 
    - 支持连续SQL的集体成功或集体撤销。
    - 事务是数据库在数据晚自习方面的一个功能。
    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。
    - InnoDB被称为事务安全型引擎。

-- 事务开启
    START TRANSACTION; 或者 BEGIN;
    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。
-- 事务提交
    COMMIT;
-- 事务回滚
    ROLLBACK;
    如果部分操作发生问题，映射到事务开启前。

-- 事务的特性
    1. 原子性（Atomicity）
        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
    2. 一致性（Consistency）
        事务前后数据的完整性必须保持一致。
        - 事务开始和结束时，外部数据一致
        - 在整个事务过程中，操作是连续的
    3. 隔离性（Isolation）
        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。
    4. 持久性（Durability）
        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。

-- 事务的实现
    1. 要求是事务支持的表类型
    2. 执行一组相关的操作前开启事务
    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。

-- 事务的原理
    利用InnoDB的自动提交(autocommit)特性完成。
    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。
    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。

-- 注意
    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。
    2. 事务不能被嵌套

-- 保存点
    SAVEPOINT 保存点名称 -- 设置一个事务保存点
    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点
    RELEASE SAVEPOINT 保存点名称 -- 删除保存点

-- InnoDB自动提交特性设置
    SET autocommit = 0|1;    0表示关闭自动提交，1表示开启自动提交。
    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。
    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，
        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)
        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)


/* 锁表 */
表锁定只用于防止其它客户端进行不正当地读取和写入
MyISAM 支持表锁，InnoDB 支持行锁
-- 锁定
    LOCK TABLES tbl_name [AS alias]
-- 解锁
    UNLOCK TABLES


/* 触发器 */ ------------------
    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象
    监听：记录的增加、修改、删除。

-- 创建触发器
CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt
    参数：
    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。
    trigger_event指明了激活触发程序的语句的类型
        INSERT：将新行插入表时激活触发程序
        UPDATE：更改某一行时激活触发程序
        DELETE：从表中删除某一行时激活触发程序
    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。
    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构

-- 删除
DROP TRIGGER [schema_name.]trigger_name

可以使用old和new代替旧的和新的数据
    更新操作，更新前是old，更新后是new.
    删除操作，只有old.
    增加操作，只有new.

-- 注意
    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。


-- 字符连接函数
concat(str1[, str2,...])

-- 分支语句
if 条件 then
    执行语句
elseif 条件 then
    执行语句
else
    执行语句
end if;

-- 修改最外层语句结束符
delimiter 自定义结束符号
    SQL语句
自定义结束符号

delimiter ;        -- 修改回原来的分号

-- 语句块包裹
begin
    语句块
end

-- 特殊的执行
1. 只要添加记录，就会触发程序。
2. Insert into on duplicate key update 语法会触发：
    如果没有重复记录，会触发 before insert, after insert;
    如果有重复记录并更新，会触发 before insert, before update, after update;
    如果有重复记录但是没有发生更新，则触发 before insert, before update
3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert


/* SQL编程 */ ------------------

--// 局部变量 ----------
-- 变量声明
    declare var_name[,...] type [default value] 
    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。 

-- 赋值
    使用 set 和 select into 语句为变量赋值。

    - 注意：在函数内是可以使用全局变量（用户自定义的变量）


--// 全局变量 ----------
-- 定义、赋值
set 语句可以定义并为变量赋值。
set @var = value;
也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。
还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。
select @var:=20;
select @v1:=id, @v2=name from t1 limit 1;
select * from tbl_name where @var:=30;

select into 可以将表中查询获得的数据赋给变量。
    -| select max(height) into @max_height from tb;

-- 自定义变量名
为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。
@var=10;

    - 变量被定义后，在整个会话周期都有效（登录到退出）


--// 控制结构 ----------
-- if语句
if search_condition then 
    statement_list    
[elseif search_condition then
    statement_list]
...
[else
    statement_list]
end if;

-- case语句
CASE value WHEN [compare-value] THEN result
[WHEN [compare-value] THEN result ...]
[ELSE result]
END


-- while循环
[begin_label:] while search_condition do
    statement_list
end while [end_label];

- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。

    -- 退出循环
        退出整个循环 leave
        退出当前循环 iterate
        通过退出的标签决定退出哪个循环


--// 内置函数 ----------
-- 数值函数
abs(x)            -- 绝对值 abs(-10.9) = 10
format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46
ceil(x)            -- 向上取整 ceil(10.1) = 11
floor(x)        -- 向下取整 floor (10.1) = 10
round(x)        -- 四舍五入去整
mod(m, n)        -- m%n m mod n 求余 10%3=1
pi()            -- 获得圆周率
pow(m, n)        -- m^n
sqrt(x)            -- 算术平方根
rand()            -- 随机数
truncate(x, d)    -- 截取d位小数

-- 时间日期函数
now(), current_timestamp();     -- 当前日期时间
current_date();                    -- 当前日期
current_time();                    -- 当前时间
date('yyyy-mm-dd hh:ii:ss');    -- 获取日期部分
time('yyyy-mm-dd hh:ii:ss');    -- 获取时间部分
date_format('yyyy-mm-dd hh:ii:ss', '%d %y %a %d %m %b %j');    -- 格式化时间
unix_timestamp();                -- 获得unix时间戳
from_unixtime();                -- 从时间戳获得时间

-- 字符串函数
length(string)            -- string长度，字节
char_length(string)        -- string的字符个数
substring(str, position [,length])        -- 从str的position开始,取length个字符
replace(str ,search_str ,replace_str)    -- 在str中用replace_str替换search_str
instr(string ,substring)    -- 返回substring首次在string中出现的位置
concat(string [,...])    -- 连接字串
charset(str)            -- 返回字串字符集
lcase(string)            -- 转换成小写
left(string, length)    -- 从string2中的左边起取length个字符
load_file(file_name)    -- 从文件读取内容
locate(substring, string [,start_position])    -- 同instr,但可指定开始位置
lpad(string, length, pad)    -- 重复用pad加在string开头,直到字串长度为length
ltrim(string)            -- 去除前端空格
repeat(string, count)    -- 重复count次
rpad(string, length, pad)    --在str后用pad补充,直到长度为length
rtrim(string)            -- 去除后端空格
strcmp(string1 ,string2)    -- 逐字符比较两字串大小

-- 流程函数
case when [condition] then result [when [condition] then result ...] [else result] end   多分支
if(expr1,expr2,expr3)  双分支。

-- 聚合函数
count()
sum();
max();
min();
avg();
group_concat()

-- 其他常用函数
md5();
default();


--// 存储函数，自定义函数 ----------
-- 新建
    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型
        函数体

    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。
    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。
    - 参数部分，由"参数名"和"参数类型"组成。多个参数用逗号隔开。
    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。
    - 多条语句应该使用 begin...end 语句块包含。
    - 一定要有 return 返回值语句。

-- 删除
    DROP FUNCTION [IF EXISTS] function_name;

-- 查看
    SHOW FUNCTION STATUS LIKE 'partten'
    SHOW CREATE FUNCTION function_name;

-- 修改
    ALTER FUNCTION function_name 函数选项


--// 存储过程，自定义功能 ----------
-- 定义
存储存储过程 是一段代码（过程），存储在数据库中的sql组成。
一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。
而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。

-- 创建
CREATE PROCEDURE sp_name (参数列表)
    过程体

参数列表：不同于函数的参数列表，需要指明参数类型
IN，表示输入型
OUT，表示输出型
INOUT，表示混合型

注意，没有返回值。


/* 存储过程 */ ------------------
存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。
调用：CALL 过程名
-- 注意
- 没有返回值。
- 只能单独调用，不可夹杂在其他语句中

-- 参数
IN|OUT|INOUT 参数名 数据类型
IN        输入：在调用过程中，将数据输入到过程体内部的参数
OUT        输出：在调用过程中，将过程体处理完的结果返回到客户端
INOUT    输入输出：既可输入，也可输出

-- 语法
CREATE PROCEDURE 过程名 (参数列表)
BEGIN
    过程体
END


/* 用户和权限管理 */ ------------------
用户信息表：mysql.user
-- 刷新权限
FLUSH PRIVILEGES
-- 增加用户
CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)
    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。
    - 只能创建用户，不能赋予权限。
    - 用户名，注意引号：如 'user_name'@'192.168.1.1'
    - 密码也需引号，纯数字密码也要加引号
    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD
-- 重命名用户
RENAME USER old_user TO new_user
-- 设置密码
SET PASSWORD = PASSWORD('密码')    -- 为当前用户设置密码
SET PASSWORD FOR 用户名 = PASSWORD('密码')    -- 为指定用户设置密码
-- 删除用户
DROP USER 用户名
-- 分配权限/添加用户
GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] 'password']
    - all privileges 表示所有权限
    - *.* 表示所有库的所有表
    - 库名.表名 表示某库下面的某表
-- 查看权限
SHOW GRANTS FOR 用户名
    -- 查看当前用户权限
    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();
-- 撤消权限
REVOKE 权限列表 ON 表名 FROM 用户名
REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名    -- 撤销所有权限
-- 权限层级
-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。
全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user
    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。
数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host
    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。
表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv
    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。
列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv
    当使用REVOKE时，您必须指定与被授权列相同的列。
-- 权限列表
ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限
ALTER    -- 允许使用ALTER TABLE
ALTER ROUTINE    -- 更改或取消已存储的子程序
CREATE    -- 允许使用CREATE TABLE
CREATE ROUTINE    -- 创建已存储的子程序
CREATE TEMPORARY TABLES        -- 允许使用CREATE TEMPORARY TABLE
CREATE USER        -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。
CREATE VIEW        -- 允许使用CREATE VIEW
DELETE    -- 允许使用DELETE
DROP    -- 允许使用DROP TABLE
EXECUTE        -- 允许用户运行已存储的子程序
FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE
INDEX     -- 允许使用CREATE INDEX和DROP INDEX
INSERT    -- 允许使用INSERT
LOCK TABLES        -- 允许对您拥有SELECT权限的表使用LOCK TABLES
PROCESS     -- 允许使用SHOW FULL PROCESSLIST
REFERENCES    -- 未被实施
RELOAD    -- 允许使用FLUSH
REPLICATION CLIENT    -- 允许用户询问从属服务器或主服务器的地址
REPLICATION SLAVE    -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）
SELECT    -- 允许使用SELECT
SHOW DATABASES    -- 显示所有数据库
SHOW VIEW    -- 允许使用SHOW CREATE VIEW
SHUTDOWN    -- 允许使用mysqladmin shutdown
SUPER    -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。
UPDATE    -- 允许使用UPDATE
USAGE    -- “无权限”的同义词
GRANT OPTION    -- 允许授予权限


/* 表维护 */
-- 分析和存储表的关键字分布
ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...
-- 检查一个或多个表是否有错误
CHECK TABLE tbl_name [, tbl_name] ... [option] ...
option = {QUICK | FAST | MEDIUM | EXTENDED | CHANGED}
-- 整理数据文件的碎片
OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...


/* 杂项 */ ------------------
1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！
2. 每个库目录存在一个保存当前数据库的选项文件db.opt。
3. 注释：
    单行注释 # 注释内容
    多行注释 /* 注释内容 */
    单行注释 -- 注释内容        (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)
4. 模式通配符：
    _    任意单个字符
    %    任意多个字符，甚至包括零字符
    单引号需要进行转义 \'
5. CMD命令行内的语句结束符可以为 ";", "\G", "\g"，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。
6. SQL对大小写不敏感
7. 清除已有语句：\c
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>155</wp:post_id>
		<wp:post_date>2014-07-30 15:40:01</wp:post_date>
		<wp:post_date_gmt>2014-07-30 07:40:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%b8%80%e5%8d%83%e8%a1%8cmysql%e5%ad%a6%e4%b9%a0%e7%ac%94%e8%ae%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mysql"><![CDATA[MySQL]]></category>
		<category domain="category" nicename="mysql"><![CDATA[MySQL]]></category>
	</item>
	<item>
				<title>对TCP/IP网络协议的深入浅出归纳</title>
		<link>http://localhost:81/wordpress/?p=157</link>
		<pubDate>Wed, 30 Jul 2014 07:54:34 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=157</guid>
		<description></description>
		<content:encoded><![CDATA[<div class="postTitle" style="font-weight: bold; color: #4b4b4b;">
<p style="font-weight: bold; color: #666666;">对TCP/IP网络协议的深入浅出归纳</p>

</div>
<div id="cnblogs_post_body" style="color: #4b4b4b;">
<div id="article_content" class="article_content">

 前段时间做了一个开发，涉及到网络编程，开发过程比较顺利，但任务完成后始终觉得有一些疑惑。主要是因为对网络协议不太熟悉，对一些概念也没弄清楚。后来 我花了一些时间去了解这些网络协议，现在对TCP/IP网络协议有了初步的认识，在这里总结出来，可以梳理一下我对网络协议的理解，加深印象.

话说两台电脑要通讯就必须遵守共同的规则，就好比两个人要沟通就必须使用共同的语言一样。一个只懂英语的人，和一个只懂中文的人由于没有共同的语言（规则）就没办法沟通。两台电脑之间进行通讯所共同遵守的规则，就是网络协议。

那么谁来制定这个网络协议？

国际标准化组织(ISO)定义了网络协议的基本框架，被称为OSI模型。要制定通讯规则，内容会很多，比如要考虑A电脑如何找到B电脑，A电脑在发送信息 给B电脑时是否需要B电脑进行反馈，A电脑传送给B电脑的数据的格式又是怎样的？内容太多太杂，所以OSI模型将这些通讯标准进行层次划分，每一层次解决 一个类别的问题，这样就使得标准的制定没那么复杂。OSI模型制定的七层标准模型，分别是：应用层，表示层，会话层，传输层，网络层，数据链路层，物理 层。

虽然国际标准化组织制定了这样一个网络协议的模型，但是实际上互联网通讯使用的网络协议是TCP/IP网络协议。

TCP/IP 是一个协议族，也是按照层次划分。共四层：应用层，传输层，互连网络层，网络接口层。 那么TCP/IP协议和OSI模型有什么区别呢？OSI网络协议模型，是一个参考模型，而TCP/IP协议是事实上的标准。TCP/IP协议参考了OSI 模型，但是并没有严格按照OSI规定的七层去划分标准，而只划分了四层，个人觉得这样会更简单点，当划分太多层次时，你很难区分某个协议是属于哪个层次 的。TCP/IP协议和OSI模型也并不冲突，TCP/IP协议中的应用层协议，就对应于OSI中的应用层，表示层，会话层。就像以前有工业部和信息产业 部，现在实行大部制后只有工业和信息化部一个部门，但是这个部门还是要做以前两个部门一样多的事情，本质上没有多大的差别。TCP/IP中有两个重要的协 议，传输层的TCP协议和互连网络层的IP协议，因此就拿这两个协议做代表，来命名整个协议族了，在说TCP/IP协议时，是指整个协议族。

TCP/IP协议分为四个层次，但我们并不需要了解所有层次的协议，我觉得主要关注应用层和传输层的协议就可以了。拿寄送邮件举例， A寄邮件给B，A关心的是用什么格式写什么内容给B（应用层内容），是寄挂号信还是寄平信（传输层内容），但是A是不会去关注邮件传送过程中采用了那条路 线，邮递员是如何把信件递送到B手里的（互连网络层，网络接口层）。

先说传输层，传输层有多个协议，但最主要的是TCP和UDP协议。两则的区别在于TCP协议需要接收方反馈，UDP协议不需要接收方反馈。TCP就像挂号 信，A电脑发信息给B电脑后，需要得到B电脑的反馈，这样A电脑就能知道B电脑是否已经收到信息。UDP就像平信，A电脑发信息给B电脑后，B电脑并不给 A电脑发聩，A电脑发送信息出去后并不知道B电脑是否已经收到。 因此，TCP传输比UDP传送更可靠，但是TCP传输的效率就不如UDP了。至于，在传送过程中具体选择哪种传送方式，需要具体问题具体分析。在不可靠的 网络传送过程中一般选择TCP传送方式。在讲求效率，或者不在乎传送失误的情况下可以选择UDP方式来提高传输速率。

应用层的协议有很多，每一个协议代表一种类型的服务。HTTP协议，万维网服务。FTP协议，文件传送服务。POP3，邮件服务，SOAP协议webService服务。

在理解TCP/IP协议的过程中，我遇到了三个困惑。

1.什么是socket?

以前有听说过socket编程这种说法，也有的说套接字编程。我在搜索关于socket的资料时，发现有的说socket是指一个连接，有的说 socket是一指一个端点。拿打电话做比喻，A电话机和B电话机正在通话，那么socket是指的A和B之间的连接线呢，还是指电话机（端点）？

我现在的理解是，socket就是一个连接中的一个端点，一次通讯（连接）a,b端都会有一个socket。一个socket对应一个连接。

2.http协议属于应用层还是传输层？

http 超文本传送协议，听上去像是传输层的协议一样。但事实上大家都知道http和ftp一样都是属于应用层的协议，我先前很纳闷的是，既然是应用层的协议，怎 么就取这样一个误导人的名称啊。在对TCP/IP协议还不熟悉的时候，这很容易让人误解和纳闷的。后来，我在wiki上发现这么一段话：

http中文译名问题
HTTP 在中国大陆被翻译为“超文本传输协议”，因为“transfer”在中文里有“传输”的含意。但依据 HTTP 定制者之一的 Roy Fielding博士的论文[1]（6.5.3节），作者专门强调“transfer”表示的是“（表述状态的）转移” （Representational State Transfer），而不是“传输”（transport）。故其中文译名“超文本传输协议”恰恰引种反映了这种误解。更符合原义的译名应该为“超文本转 移协议”。

这段话解除了我的疑惑。那么http协议当然是应用层的协议。

3.SOAP可以使用HTTP协议进行传输吗？

在了解SOAP协议的过程中，看到介绍说soap可以通过tcp,udp,http协议来传送。这也是让人困惑的描述。一看这句话，就会感觉http怎么 和tcp,udp协议并列了呢？难道http还是属于传输层的协议？再加上http中文译名的问题，名字听上去像传输层，初学者又要开始头大了。

事实上，http是应用层的协议，这一点可以毫无怀疑。那么现在新的问题来了。soap和http都是应用层协议，怎么说soap能用http协议来传输呢？应用层的协议可以用应用层的协议传送吗？

我查阅了资料，是这样一回事情，soap将信息进行XML的序列化后，再用http协议的方式再打包进行传送，传送的方式还是tcp或者udp。做个比喻 就好理解了。tcp 和 udp 都是公路，暂且把tcp认为是一般公路，udp高速公路，soap和http就都是汽车，那么soap和http都可以在tcp和udp上跑。说soap 可以通过http来传送，实际就是说soap是小轿车，http是装轿车的卡车，把soap的信息装到http里面，然后再运输，当然走的道路还是tcp 或udp。

说soap可以通过http协议来传输，这句话不太准确，比较准确第说法是：soap信息可以通过http协议包装后通过tcp或udp传输。

</div>
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>157</wp:post_id>
		<wp:post_date>2014-07-30 15:54:34</wp:post_date>
		<wp:post_date_gmt>2014-07-30 07:54:34</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%af%b9tcpip%e7%bd%91%e7%bb%9c%e5%8d%8f%e8%ae%ae%e7%9a%84%e6%b7%b1%e5%85%a5%e6%b5%85%e5%87%ba%e5%bd%92%e7%ba%b3</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="ip"><![CDATA[IP]]></category>
		<category domain="post_tag" nicename="socket"><![CDATA[SOCKET]]></category>
		<category domain="post_tag" nicename="tcp"><![CDATA[TCP]]></category>
		<category domain="category" nicename="architecture"><![CDATA[架构&amp;框架]]></category>
	</item>
	<item>
				<title>开始写文章！</title>
		<link>http://localhost:81/wordpress/?p=165</link>
		<pubDate>Fri, 29 Aug 2014 05:38:21 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=165</guid>
		<description></description>
		<content:encoded><![CDATA[<div>对任何一个想成自明星的人来说，写文章是一个基础功夫。
但是，万事开头难，一个从来都不怎么写文章的人要想动笔写，真的是不容易，怕写不好，不知道怎么写，以及各种各样的顾虑。今天通哥来给大家分享一下我是如何喜欢上写文章的，也许能够给你一些启发。

提到写文章，还要从写作文开始。

在小时候，写作文对我们每个学生而言都是痛苦的事情，记得从小学三年级开始，初了写作文之外，老师还要求学生写周记，并且要上交检查。可是从来没写过啊，怎么写呢？

模仿
模仿是学习的开始！

于是看看高年级同学写的，看看其他同学写的，发现全部都是在瞎编好人好事，不是下学回家扶老奶奶过马路了，就是马路边捡了一分钱交给警察叔叔了，反正不知道为啥，所有的同学的周记都是在学雷锋，无聊至极又不知怎么办，每次写周记都痛苦不堪的去探索雷锋在自己身上附体。

于是在三年级的时候，我们班还发生了几篇有趣的周记：
1、有一个同学写到放学回家路上，看到一个人在打架，后来两位阿姨在把这场架拉开。  当时老师就问那位同学：“一个人怎么打架？难道学习周伯通左右手互搏么？就算自我搏击的话，需要两个人去拉架么？”

2、另外一个同学更牛，因为没啥写就只能抄袭，于是在家里找了一本书，看到有一篇文章不太长，适合当作周记，于是就抄完教给老师。老师看了之后，火冒三丈。直接问这位同学："你这文章找一个大学教授都写不来，你有这么大的才能么？  原来这位同学直接抄了一篇文言文，他自己还不知道怎么回事。“

小学三年级期末考试，我的语文只考了42分，从此之后，我对文科就一直不感冒，到了初中之后，对理科一直学的津津有味，幻想着超越爱因斯坦。

到高一的时候，我们的班主任教我们语文，要求所有的同学都必须写日记，天天晚自习检查。于是我就对日记产生了恐惧，不知道写什么，只能到处抄袭散文和诗歌，全当练习硬笔书法来应付。

有一天体育课，我和几个同学一起逃课去爬山玩，很愉快的玩了半个下午。到了第二天下午放学后，其他同学都先去吃饭了，我懒的和别人挤，就一个人继续呆在教室里。

这个时候无意间发现前一排一个女同学的课桌上放了一个日记本，我就顺手拿了过来，然后随便翻了一页，刚好那页写的就是我们那天下午去玩的整个流水账，写的还挺长，足足有三页，我看了觉得非常有意思。

她还特别提到，爬山的时候，遇到比较难爬的险要之处，我总是第一个爬上去，然后一个一个把他们拉上去。甚至还写到，当时我拉她手的时候，她感觉我有点局促。于是我就回忆昨天爬上的经历，我拉她上去的时候我局促么？想了半天也想不起来，虽然我们天天在教室里打闹着玩，我还从来没有对她有什么特别的喜欢，她为什么有这样的感觉呢？没有想明白，于是又把她的日记放了回去。

不过，这件事儿对我产生了两个影响：
1、我开始觉得这位女同学挺与众不同的，开始对她有了些好感。
2、我知道日记怎么写了，就写流水账，把每天的无聊经历写一写，过一段回头来看一看也会挺有意思。

接下来的日子，我喜欢上了写日记，因为当我开始有意识记录生活的时候，我就开始有意识的观察生活，留意生活中的各种各样的细节，和大家之间的点点滴滴，于是逐渐学会了思考，开始反省自己，改变自己。

到了现在，我还清晰的嫉妒我高中时候无数个无聊时刻的场景，回忆起来，那时候的环境、光线、声音就像电影一样在脑海重现。特别是我坐在教室最后一排的窗边，观察窗外的变化，我写了许多窗外，每次都不太一样。还有就是无数的白日梦，科幻的，穿越的，写实的等等。

也是从那时候起，我开始观察和思考人和环境的关系，决定用自己总结的方法改变自己。

到了高二，我对自己说，不能在压抑下去了，放弃学习，好好玩一年，到了高三再学习。放下了心理负担之后，心理就彻底自由了，最直接的表现就是对待作文的态度。

上高中之后，我只有第一篇作文比老师表扬过，之后一直都是很低的分数，满分40分，我从来都是20分左右。每次写作文，不知道要撕掉多少页作业本的纸，不断改，总是觉得不行。

高二之后，因为我无所谓学习成绩了，也就无所谓老师的评价了，并且我开始追求自我的个性和与众不同，所以作文我也开始不按照传统的思路来玩了。

高二一般都先学写论文，论文一般都是这样的：老师提供一个故事素材，然后让大家来写。
写的框架是这样：
第一段：缩写素材
第二段：正面论述
第三段：反面论述
第四段：总结

第一次的论文，老师为了降低写作难度，给的题材非常简单，只有不到100个字，几乎不用缩写。

于是呢？
我就恶搞，刻意迎合论文的形式主义。

怎么做呢?
我把题材缩写成了文言文，整个文章也是学着文言文的强调瞎写了一番。

其实呢，我文言文学的特别烂，文言文考试的题从来都不会做的。不过这篇文章的结果另外非常意外。老师给我打了37分，并且在课堂上当作所有的同学的面夸我这篇文章写的半文半白很有文采！

被老师一夸，肯定就非常兴奋了，人一兴奋起来，灵感就井喷了。

第二次的作文是命题作文《学会感谢》

一般同学还是老套路，感谢老师，感谢父母，感谢朋友等等。

我感谢什么呢？

1、感谢迟到
早上迟到了，我就不用上早操了，因为早操是在土操场跑的，灰尘半天，比今天的雾霾都厉害，根本不是在锻炼身体，才是充当吸尘器。我在睡懒觉起来，一路上吹着小风，哼着小曲，悠闲的散步到学校，还避开了上早操，太享受了，就算被班主任批评一顿也值了。

2、感谢犯错
每次晚自习，我一犯错都被老师赶出教室了，别的同学被老师赶出来之后，都是凑没哭脸的。而我被赶出来之后，觉得太享受了。因为教室在乱糟糟热烘烘非常难受。出来之后，看看星星看看月亮吹吹风凉快一下非常舒服。

3、感谢老师讲的烂
因为老师讲课烂，讲不到五分钟，我就趴下睡觉梦周公了，在梦中，遇到了小龙女，然后一番故事，把东邪西毒南帝北丐中神通都写出来了，然后突然被下课铃声叫醒，哈喇子在桌子上流淌成河.......


我肆无忌惮什么都写，好在那位语文老师非常开明，觉得我的作文写的太与众不同了，非常有意思，所以又是给我打了个高分，只是略微批评了一下我，不能总去写负面事。

第三次作文的话题是以水为话题，写一篇作文。我就写了《一瓶矿泉水》，写的就是一瓶矿泉水在不同环境中的不同价值，从而来总结一个人在不同环境中的不同价值，最后得到了老师给的满分。

从这篇三篇作文之后，我彻底的把自己给解放了，每次作文课，都是灵感无限，写到把自己忘掉的境界，非常的享受，后来我还把我的这个写作文的方法教了好几个同学，把他们的性格都给改变了。</div>
<div>
关键有几点：
<span style="color: #ff0000;">1、不要去迎合规矩，与众不同是必须的。
2、不在乎别人看法，自己写的爽最重要。</span>

带给我的改变是：
1、自我觉醒：不再庸庸碌碌混混僵僵的去过每一天，开始主动给每一天寻找乐子。我那时候常说的一句话就是：<span style="color: #ff0000;">没事不能憋着，活着必须乐呵。无聊找聊，没乐找乐。</span>

2、观察世界：从写日记开始，就开始尝试着把自己抽离出来，像一个局外人一样去从各个角度去观察自己，观察周围的人和事，然后有了许多思考和总结，接着就是改变自己，逐步把自己变成理想的自己。

那一年，我就是靠每天多做一个俯卧撑，每天写日记反省自己改变自己，一年时间，把我自己从一个瘦弱内向的人，变成了一个强壮又外向的人，充满正能量，充满个性，吸引了非常多的朋友，拜托了环境的压抑，甚至开始影响周围的同学。

到了高三后，我想学习都学不进去了，几乎每天都是听音乐看课外书随时随地写随笔，写了好多本。

大学只上了一年，几乎每上过课，天天是看课外书上网聊天和做网站，除了偶尔给朋友写信，几乎很少在写作文和文章。慢慢的，过去写文章的感觉就没了。

离开大学后，开始在互联网圈混，进入了一个IT写作社区，发现非常多的人文章写的很空洞，竟然还有不少网站和传统媒体约稿，我就开始要求自己重新开始写文章。

从2002年开始，我开始写互联网相关的评论和文章。尽管文笔奇烂无比，错别字和名句层出不穷，我依然很大胆的写，文字只是工具，比文笔重要的是观点和思想，我的早起的每篇文章都很个性，要么犀利、要么新意、要么争议、要么实用。到了2003年，我的系列文章已经在业内非常的火爆，然后各种各样的机遇就出现了。

最后建议新手们别再顾虑了，想怎么写就怎么写，夸赞谩骂乱说瞎写发神经都没有问题，写吧，一定有人欣赏你。
再次强调：<span style="color: #ff0000;">只要你敢写，就有人敢看！</span>
<span style="color: #ff0000;">行动之后，你才知道写文章的收获有多大，绝对超出你的想象！</span></div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>165</wp:post_id>
		<wp:post_date>2014-08-29 13:38:21</wp:post_date>
		<wp:post_date_gmt>2014-08-29 05:38:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%bc%80%e5%a7%8b%e5%86%99%e6%96%87%e7%ab%a0%ef%bc%81</wp:post_name>
		<wp:status>private</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
	</item>
	<item>
				<title>140903 有点混乱，但是坚持就不会有问题！</title>
		<link>http://localhost:81/wordpress/?p=167</link>
		<pubDate>Wed, 03 Sep 2014 11:02:58 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=167</guid>
		<description></description>
		<content:encoded><![CDATA[好吧，一直说想记录下生活，无论写得怎么样，把心里想的写下来就行了。但发现写的时候还是会觉得好多事情都很难表达，可能是太久没写这些流水账的东西了，看来还是要多写写。。

这几天压力貌似还挺大，感觉应该是这几个月压力都不小，但这些压力很多时候都不是来自工作，而是来自于自己，来自于自己的内心，而内心则恰恰是来自于生活，而生活则源于习惯。

可能自己很想走出这样的瓶颈，但有时候却真的无能为力，即便知道应该怎么做，即便知道这样的一些情绪和想法是不对的。可能更多的是应该让自己去坚持吧，而坚持现在看来是一件很有挑战性的事情，这是目前横担在眼前的坎，必须得跨过去！

我知道自己内心有很多想法，也有很多计划，但慢慢地，总觉得有点越来越不自信的感觉，这是必须要解决的问题。不能一直这样下去。

其实想想这几天的思维挺混乱的，有时候说了一大堆，也不知道说了啥，而且记忆也不好，别人的话也很难听得进去，可能也跟睡眠有关，早睡早起的习惯一定要养成，而且必须是强制性地养成，我很希望可以坚持下来，必须保持每天都有精神，要不然，思维太缓慢。

今天开完会的一个非常强烈的感觉是，必须要更加努力才行了，别人思维，能力，常识各方面都在自己之尚，而且还如此努力，我一定得加把劲了。

当然方向一定要明确，立足于工作，把自己负责的领域，擅长的领域一定要精通。不要给自己任何的借口，记住，你是要做大事的人，而做大事的人，如果连一些事情都坚持不了，如何成功呢？所以，就算压力也好，状态不好也好，该努力的还是要努力！

计划已经有了，方向也已经有了，就看怎么去坚持。累的时候多体息，一定要让生活回到自己可以control的节奏！

好了，虽然胡乱说了一通，但起码自己所想的，会有一个清晰的认识。慢慢积累吧，每天都进步一点点，这就足够了！

在一个强人如林的地方，要获得别人的认可和尊重，只能是自己成为强人！]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>167</wp:post_id>
		<wp:post_date>2014-09-03 19:02:58</wp:post_date>
		<wp:post_date_gmt>2014-09-03 11:02:58</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>140903-%e6%9c%89%e7%82%b9%e6%b7%b7%e4%b9%b1%ef%bc%8c%e4%bd%86%e6%98%af%e5%9d%9a%e6%8c%81%e5%b0%b1%e4%b8%8d%e4%bc%9a%e6%9c%89%e9%97%ae%e9%a2%98%ef%bc%81</wp:post_name>
		<wp:status>private</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
	</item>
	<item>
				<title>小米营销的一点思考--营销与产品--</title>
		<link>http://localhost:81/wordpress/?p=169</link>
		<pubDate>Tue, 16 Sep 2014 12:53:53 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=169</guid>
		<description></description>
		<content:encoded><![CDATA[一直认为，小米的成功更多的是属于营销的成功，而不是他们产品的成功。这一点的差别是很大的。

营销在当前的国内大环境确实是快速成功的关键，但小米在没有把一款产品做到极致，并且真正意义上考虑用户体验的情况下就快速地扩张，这本身就有了极大的风险。

小米的文化以及中国的国情决定了他们不能像苹果那样去思考产品，研究产品，做到真正意义上的产品体验。如果小米在战略上没有快速转变，那么他们所占据的市场便会很有限，特别是在手机行业及相关领域越来越饱和的情况下。小米可以稳定地赚到钱，迅速提高估值，但却无法让他们成为一家有影响力，有价值的公司。

但话说回来，也许雷军真的从没想过做一款有影响力的产品，一款高端市场的产品，或者说本来就不是以产品为导向，所以，对于什么都做，但却无法逃离低端文化的小米来说，可能他们的特点和价值也在于此，但在产品上任重则道远！

中国中高端手机的市场还是很大的，对于步步高等一直做高端市场产品的公司，真正做好产品，找到正确的切入点，可能还是会有相当大的机会的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>169</wp:post_id>
		<wp:post_date>2014-09-16 20:53:53</wp:post_date>
		<wp:post_date_gmt>2014-09-16 12:53:53</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e5%b0%8f%e7%b1%b3%e8%90%a5%e9%94%80%e7%9a%84%e4%b8%80%e7%82%b9%e6%80%9d%e8%80%83-%e8%90%a5%e9%94%80%e4%b8%8e%e4%ba%a7%e5%93%81</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
	</item>
	<item>
				<title>读书有感 --《老周自述-我的互联网方法论》-- 关于产品，体验，简单，免费的一些思考</title>
		<link>http://localhost:81/wordpress/?p=172</link>
		<pubDate>Tue, 16 Sep 2014 16:01:33 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=172</guid>
		<description></description>
		<content:encoded><![CDATA[<img class="alignleft size-full wp-image-173" src="http://bugalot.com/wp-content/uploads/2014/09/m_cfb0cf778861744387fb665ef0fa2ccb.jpg" alt="我的互联网方法论" width="226" height="270" />

每当想开始写点什么时，总会发现如何开头是件很烦又貌似有点难的事，于是就不管开头吧。

最近花了不少时间看了一些书，有的看了一半，有的能几个小时啃完，内容跟兴趣真的很重要，要不然这书比安眠药还有用！！

以前看书总会做点小笔记，有的就直接在书上画些标记，但发现还是得把一些看书的感觉和思考总结总结，这也是当时开这个博客的目的之一。好吧，就从老周这本觉得挺不错的书开始吧。稍稍有点词穷，就不写那么多.-.-!

周鸿祎这本书当时刚出没几天就果断买来看了，因为我的第一感觉是“流氓”写的书一般都不会太差，并且观点和价值观还很独特，哈哈！事实证明这本书也确实很不错，将近300页，断断续续几天看完，挺有感触，极力推荐。

书中体现的几个关键词：用户至上，体验为王，免费，颠覆式创新

围绕这几个关键词，这本书也能强烈感觉到老周的一些价值观，产品的思维，以及在360产品的思路。

当然，完全总结这本书，不可能也没必要，给我印象最深同时也深有感触的还是关于产品，方法论以及免费的看法。
<ul>
	<li><strong>简单</strong></li>
</ul>
说到简单，其实心里可能都会说，这个谁都知道啊，就是把产品做得足够傻瓜，或者专注于某个角度，把功能精简，让用户能够最快地熟悉产品，操作产品。但这里面，可能最容易被忽略的是用户的角度。”简单“的出发点应当是从用户的需求出发，以用户的感受，目标用户的习惯及行业深度去思考。说得有点概念化，这里面书中说到360的随身wifi这个产品，我觉得很好地说明了这一点：

可能直到看到这本书，我才真正明白随身wifi为什么能出现！这真的是一款专门为小白用户而做的产品。对于大部分IT从业人员来说，设置个wifi共享是件很容易的事，无论是在笔记本还是手机上。所以，我们（码农思维）一开始看到这样的产品便会有一种心里上自然地鄙视（-.-!! 好吧，用词不当），觉得完全是多余的产品。但是，对于很多很多人来说，笔记本电脑的网络都不能很好地设置（你想想有多少次被妹子深夜吵醒，就为了帮忙解决重启一下就能搞定的网络问题就能明白了$_$,纯属调侃，其实基友也有） ，你还指望他们会去设置一个wifi共享？ 所以，随身wifi的出现就不难理解了，插上即可用，不用任何设置。这也体现了现在的一种互联网产品的思维，对于一些用户来说，他们真正需要的是一种傻瓜式的产品，并且是越傻越好，不用思考的那种，能快速上手，不用花费一秒的时间去研究搜索（这里强调一秒）。而往往，我们（产品开发或者设计人员）会站在自己的角度去看待这些看似简单的问题，思维的一点点小转变可能也在于此！
<ul>
	<li><strong>免费</strong></li>
</ul>
以前看过《免费》（克里斯*安德森）这本经典的书，对免费（不关互联网，也包含传统行业）有了全新的认识。这个现在看来也已经不能算是商业的趋势，而是happening now的一种大势。太多成功案例验证了这一商业模式！

《免费》书中也有老周对免费的一小段看法：
<blockquote>免费是互联网的历史潮流，不可阻挡......用免费的产品和服务去吸引用户，然后再用增值服务或其他产品收费，已经成为互联网公司的普遍成长规律......表面的”免费“并不是真正的免费。</blockquote>
这些看法也跟他在书所阐述的一致。

【传统经济的本质，就是低买高卖。但互联网最激动人心的地方，在于你能给亿万用户提供非常好的产品免费用，最后你还能因此获得巨额的财富。这种模式在传统的商业世界中是无法解释的。】

免费既是商业模式，又是一种革命的手法，也是一种营销的手段，同时也是互联网的一种精神！

免费，英文词就是free。free也是互联网的重要精神，它有三层意思：

1） 免费，不用钱。不挣老百姓的钱，但免费可以带来最大的市场份额，可以带来忠诚的用户群，带来品牌的知名度与价值。

2） 自在，便利。无论是做软件还是做服务，都应该让人感到网络生活的自在、便利。

3） 自由。在互联网上，要放开了想去创新，想到了就去做，而不模仿他人。

要想真正理解免费，做到免费，不能用简单片面的看法。真正的免费要从成本出发。书上，有一个例子我觉得挺不错：
<blockquote>在互联网上，服务和产品都是数字化的，比如聊天、电子邮箱、搜索，都是一种虚拟服务。用的人不管有多少，它总的研发成本基本是固定的，而用的人越多，每个人分摊的成本就会越低。比如：一款软件（应用）是1000万元，当有100万用户使用的时候，每个用户分摊的成本是10元；当有1000万用户使用的时候，成本是1元；当有1亿用户时，分摊的成本是0.1元。这跟现实生活中的物理产品是截然不同的。</blockquote>
网易新闻客户端，看新闻都是免费的，其实网易提供这样的服务也投入了很多，包括服务器，请胖编，小编等也要钱，这些成本可以看作是固定的。如果，只有10万读者，那么，这样的成本平摊下来，肯定是不小的数目，但网易有将近1亿多的读者，这样的成本分摊下来就微乎其微了。

互联网真免费，盈利手段主要有两种：

1）广告。广告这种盈利方式很传统，也是最直接的。当用户数量上去了，广告的价值也直线上升。

2）增值服务。以前互联网的增值服务更多的在于提供基础服务外的一些特殊的非必须服务，这种服务面向少数人，这部分人有这样的需求，也愿意付费。比如360安全提供的在线即时人工诊断服务，QQ的会员及各种砖的增值服务。而现在，随着移动互联网及游戏行业的发展，增值服务就运用地更加广泛，也更加直接。网游都是可以免费玩的，但要买装备（有了高大上的装备才能当高富帅）就得花钱了，而对于一些沉迷的游戏玩家来说，那点钱真的不算什么。但对于游戏开发者来说，百万用户加起来的收入是相当惊人的，这也是常说游戏很赚钱，并且这几年发展很快的原因。

<strong>”关于硬件免费？" </strong>

我自己也相信这会是未来的一个趋势！
<blockquote>“在未来（至少在很短的一段时间内），我们所制造的一切几乎都将免费，包括冰箱、滑雪板、激光投影机、服装等。实现的前提，是这些东西整合在网络节点中，成为网络服务的载体。”

----凯文，凯利 《技术想要免费》</blockquote>
这样的预言不无道理，以今天互联网被免费如此颠覆来看，这样的一种趋势，看起来是必然的。相信通过上面的一些感想，真正理解这段话并不难。
<ul>
	<li><strong>做产品要有一颗粗糙的心</strong></li>
</ul>
这里只简单地记录几句，相信已经足够了：

1） 像小白一样思考。

2） 产品从某种角度来说，就是做艺术品，没有时光坚韧不拔的心态是很难成功的。但从另外的角度来说，艺术品可以只让少数人孤芳自赏，但产品要获得商业上的成功则需要大众的认同。

3） 快速开发，第一版本可以粗糙，小步快跑，循序渐进，不断试错，集小胜为大胜。

4） 在产品方向上，一定要先学会做减法，而不是做加法。要先找对一个点做到极致，否则你什么功能都做，最后都不突出，没有鲜明的卖点。
<ul>
	<li><strong>关于Apple Watch 等可穿戴设备</strong></li>
</ul>
正如老周在书中不看好智能手表，我对此也有相同的看法。

苹果手表app watch, 更多地是在消费他们积累起来的影响力（或者也可叫高大上的能力），很多人戴表并不是看时间，而更多地是彰显身份，或者当作一种装饰品，又或者追赶一种潮流。而app watch，又或者是google glass正是代表的这一种潮流。但普通用户会买单吗？如果是白菜价，相信会的。

智能手表或者智能穿戴设备，并没有解决用户的任何实质问题，所以，用户不买单也是很正常的事（大部分习惯装13的人也是有个度的）。
<ul>
	<li><strong>经典的一些语段</strong></li>
</ul>
<blockquote>1.用户与客户：用户就是那些你能长期提供一种服务，能长期让他感知你的存在，能长期跟你保持一种联系的人。你只有在互联网上积累了足够多的用户，才有能力把其中一些用户转成你的客户。</blockquote>
----我们心里总想做一款用户一直都会用的，但具体怎么做，不关想法以及产品体验足够好，我们本身的思维和价值观也是很重要的。
<blockquote>2.强需求与弱需求：弱需求拉动力非常有限，如果靠自然增长，增长速度一定会非常慢，产品独立很难做到，必须有一个强大的渠道，【如TC新闻门户，视频门户等】。而强需求产品可以自我发展成强大的渠道，【如QQ，微信等】。

3.做产品不要在乎绝对数，而是要关注相对的增长趋势。

4.在日常生活中体验无处不在，如果能够处处留心，把自己当成一个抱怨的用户之后，可以再上升一个层次，在抱怨的地方想想如何去改善用户体验。这也可以当作一种头脑体操。

5.当你真正去创新的时候，很多时候缺的不是智商，也不是情商，而是胆量。

6.香港年轻人没有什么前途，永远都是七八十岁的老家伙们给年轻人讲怎么做生意，年轻人永远没什么机会。【这个...*_*】</blockquote>
<ul>
	<li><strong>一个有趣也相当有用的产品体验思维</strong></li>
</ul>
当公司的电梯所有人都感觉很慢，并且不能再增加电梯，也不能换成调整的，在这种情况下应该怎么办？最后的答案是我们现在经常看到的，那就是：在等电梯的位置放置几面镜子，女同事等电梯时可以顺道梳妆一下，男同事也可以通过镜子偷看一下女生（-。-！），消除等待过程中心理上的焦虑。当然放置视频或平面广告也是一种能产生多种效果的方法。这种思维的关键是从用户心理出发。也说明发现用户感受，培养用户心理是很重要的。
<ul>
	<li><strong>书中提到的另外几本书</strong></li>
</ul>
《免费》

《乔布斯传》  ---- BTW，老周也是个十足的Jobs粉。  原来以前的嬉皮=现在屌丝

下面的这几本有空再看看^_^

《硅谷热》 ----硅谷不要看成东京-.-!

《创业者的窘境》

《创业者的解答》

《定位》

《商业秀》 -- 所有行业都是娱乐业（娱乐业最靠体验）]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>172</wp:post_id>
		<wp:post_date>2014-09-17 00:01:33</wp:post_date>
		<wp:post_date_gmt>2014-09-16 16:01:33</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e8%af%bb%e4%b9%a6%e6%9c%89%e6%84%9f-%e3%80%8a%e8%80%81%e5%91%a8%e8%87%aa%e8%bf%b0-%e6%88%91%e7%9a%84%e4%ba%92%e8%81%94%e7%bd%91%e6%96%b9%e6%b3%95%e8%ae%ba%e3%80%8b-%e5%85%b3%e4%ba%8e%e4%ba%a7</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e4%ba%a7%e5%93%81"><![CDATA[产品]]></category>
		<category domain="post_tag" nicename="%e5%85%8d%e8%b4%b9"><![CDATA[免费]]></category>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
		<category domain="post_tag" nicename="%e8%af%bb%e4%b9%a6"><![CDATA[读书]]></category>
	</item>
	<item>
				<title>理解矩阵</title>
		<link>http://localhost:81/wordpress/?p=180</link>
		<pubDate>Wed, 15 Oct 2014 09:15:25 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=180</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>“看君一篇网文，胜读两年线性代数”  -。-！！</strong>

作者连接：http://my.csdn.net/myan

前不久chensh出于不可告人的目的，要充当老师，教别人线性代数。于是我被揪住就线性代数中一些务虚性的问题与他讨论了几次。很明显，chensh觉得，要让自己在讲线性代数的时候不被那位强势的学生认为是神经病，还是比较难的事情。

可怜的chensh，谁让你趟这个地雷阵？！色令智昏啊！

线性代数课程，无论你从行列式入手还是直接从矩阵入手，从一开始就充斥着莫名其妙。比如说，在全国一般工科院系教学中应用最广泛的同济线性代数教材（现在到了第四版），一上来就介绍逆序数这个“前无古人，后无来者”的古怪概念，然后用逆序数给出行列式的一个极不直观的定义，接着是一些简直犯傻的行列式性质和习题——把这行乘一个系数加到另一行上，再把那一列减过来，折腾得那叫一个热闹，可就是压根看不出这个东西有嘛用。大多数像我一样资质平庸的学生到这里就有点犯晕：连这是个什么东西都模模糊糊的，就开始钻火圈表演了，这未免太“无厘头”了吧！于是开始有人逃课，更多的人开始抄作业。这下就中招了，因为其后的发展可以用一句峰回路转来形容，紧跟着这个无厘头的行列式的，是一个同样无厘头但是伟大的无以复加的家伙的出场——矩阵来了！多年之后，我才明白，当老师犯傻似地用中括号把一堆傻了吧叽的数括起来，并且不紧不慢地说：“这个东西叫做矩阵”的时候，我的数学生涯掀开了何等悲壮辛酸、惨绝人寰的一幕！自那以后，在几乎所有跟“学问”二字稍微沾点边的东西里，矩阵这个家伙从不缺席。对于我这个没能一次搞定线性代数的笨蛋来说，矩阵老大的不请自来每每搞得我灰头土脸，头破血流。长期以来，我在阅读中一见矩阵，就如同阿Q见到了假洋鬼子，揉揉额角就绕道走。

事实上，我并不是特例。一般工科学生初学线性代数，通常都会感到困难。这种情形在国内外皆然。瑞典数学家Lars Garding在其名著Encounter with Mathematics中说：“<strong>如果不熟悉线性代数的概念，要去学习自然科学，现在看来就和文盲差不多。</strong>”，然而<strong>“按照现行的国际标准，线性代数是通过公理化来表述的，它是第二代数学模型，...，这就带来了教学上的困难。”</strong>事实上，当我们开始学习线性代数的时候，不知不觉就进入了“第二代数学模型”的范畴当中，这意味着数学的表述方式和抽象性有了一次全面的进化，对于从小一直在“第一代数学模型”，即以实用为导向的、具体的数学模型中学习的我们来说，在没有并明确告知的情况下进行如此剧烈的paradigm shift，不感到困难才是奇怪的。

大部分工科学生，往往是在学习了一些后继课程，如数值分析、数学规划、矩阵论之后，才逐渐能够理解和熟练运用线性代数。即便如此，不少人即使能够很熟练地以线性代数为工具进行科研和应用工作，但对于很多这门课程的初学者提出的、看上去是很基础的问题却并不清楚。比如说：

<strong>* 矩阵究竟是什么东西？向量可以被认为是具有n个相互独立的性质（维度）的对象的表示，矩阵又是什么呢？我们如果认为矩阵是一组列（行）向量组成的新的复合向量的展开式，那么为什么这种展开式具有如此广泛的应用？特别是，为什么偏偏二维的展开式如此有用？如果矩阵中每一个元素又是一个向量，那么我们再展开一次，变成三维的立方阵，是不是更有用？</strong>

<strong>* 矩阵的乘法规则究竟为什么这样规定？为什么这样一种怪异的乘法规则却能够在实践中发挥如此巨大的功效？很多看上去似乎是完全不相关的问题，最后竟然都归结到矩阵的乘法，这难道不是很奇妙的事情？难道在矩阵乘法那看上去莫名其妙的规则下面，包含着世界的某些本质规律？如果是的话，这些本质规律是什么？</strong>

<strong>* 行列式究竟是一个什么东西？为什么会有如此怪异的计算规则？行列式与其对应方阵本质上是什么关系？为什么只有方阵才有对应的行列式，而一般矩阵就没有（不要觉得这个问题很蠢，如果必要，针对m x n矩阵定义行列式不是做不到的，之所以不做，是因为没有这个必要，但是为什么没有这个必要）？而且，行列式的计算规则，看上去跟矩阵的任何计算规则都没有直观的联系，为什么又在很多方面决定了矩阵的性质？难道这一切仅是巧合？</strong>

<strong>* 矩阵为什么可以分块计算？分块计算这件事情看上去是那么随意，为什么竟是可行的？</strong>

<strong>* 对于矩阵转置运算A<sup>T</sup>，有(AB)<sup>T</sup> = B<sup>T</sup>A<sup>T</sup>，对于矩阵求逆运算A<sup>-1</sup>，有(AB)<sup>-1</sup> = B<sup>-1</sup>A<sup>-1</sup>。两个看上去完全没有什么关系的运算，为什么有着类似的性质？这仅仅是巧合吗？</strong>

<strong>* 为什么说P<sup>-1</sup>AP得到的矩阵与A矩阵“相似”？这里的“相似”是什么意思？</strong>

<strong>* 特征值和特征向量的本质是什么？它们定义就让人很惊讶，因为Ax =λx，一个诺大的矩阵的效应，竟然不过相当于一个小小的数λ，确实有点奇妙。但何至于用“特征”甚至“本征”来界定？它们刻划的究竟是什么？</strong>

这样的一类问题，经常让使用线性代数已经很多年的人都感到为难。就好像大人面对小孩子的刨根问底，最后总会迫不得已地说“就这样吧，到此为止”一样，面对这样的问题，很多老手们最后也只能用：“就是这么规定的，你接受并且记住就好”来搪塞。然而，这样的问题如果不能获得回答，线性代数对于我们来说就是一个粗暴的、不讲道理的、莫名其妙的规则集合，我们会感到，自己并不是在学习一门学问，而是被不由分说地“抛到”一个强制的世界中，只是在考试的皮鞭挥舞之下被迫赶路，全然无法领略其中的美妙、和谐与统一。直到多年以后，我们已经发觉这门学问如此的有用，却仍然会非常迷惑：怎么这么凑巧？

我认为，这是我们的线性代数教学中直觉性丧失的后果。上述这些涉及到“如何能”、“怎么会”的问题，仅仅通过纯粹的数学证明来回答，是不能令提问者满意的。比如，如果你通过一般的证明方法论证了矩阵分块运算确实可行，那么这并不能够让提问者的疑惑得到解决。他们真正的困惑是：矩阵分块运算为什么竟然是可行的？究竟只是凑巧，还是说这是由矩阵这种对象的某种本质所必然决定的？如果是后者，那么矩阵的这些本质是什么？只要对上述那些问题稍加考虑，我们就会发现，所有这些问题都不是单纯依靠数学证明所能够解决的。像我们的教科书那样，凡事用数学证明，最后培养出来的学生，只能熟练地使用工具，却欠缺真正意义上的理解。

自从1930年代法国布尔巴基学派兴起以来，数学的公理化、系统性描述已经获得巨大的成功，这使得我们接受的数学教育在严谨性上大大提高。然而数学公理化的一个备受争议的副作用，就是一般数学教育中直觉性的丧失。数学家们似乎认为直觉性与抽象性是矛盾的，因此毫不犹豫地牺牲掉前者。然而包括我本人在内的很多人都对此表示怀疑，我们不认为直觉性与抽象性一定相互矛盾，特别是在数学教育中和数学教材中，帮助学生建立直觉，有助于它们理解那些抽象的概念，进而理解数学的本质。反之，如果一味注重形式上的严格性，学生就好像被迫进行钻火圈表演的小白鼠一样，变成枯燥的规则的奴隶。

对于线性代数的类似上述所提到的一些直觉性的问题，两年多来我断断续续地反复思考了四、五次，为此阅读了好几本国内外线性代数、数值分析、代数和数学通论性书籍，其中像前苏联的名著《数学：它的内容、方法和意义》、龚昇教授的《线性代数五讲》、前面提到的Encounter with Mathematics（《数学概观》）以及Thomas A. Garrity的《数学拾遗》都给我很大的启发。不过即使如此，我对这个主题的认识也经历了好几次自我否定。比如以前思考的一些结论曾经写在自己的blog里，但是现在看来，这些结论基本上都是错误的。因此打算把自己现在的有关理解比较完整地记录下来，一方面是因为我觉得现在的理解比较成熟了，可以拿出来与别人探讨，向别人请教。另一方面，如果以后再有进一步的认识，把现在的理解给推翻了，那现在写的这个snapshot也是很有意义的。

因为打算写得比较多，所以会分几次慢慢写。也不知道是不是有时间慢慢写完整，会不会中断，写着看吧。

--------------------------------------------------------------------------

今天先谈谈对线形空间和矩阵的几个核心概念的理解。这些东西大部分是凭着自己的理解写出来的，基本上不抄书，可能有错误的地方，希望能够被指出。但我希望做到直觉，也就是说能把数学背后说的实质问题说出来。

首先说说空间(space)，这个概念是现代数学的命根子之一，从拓扑空间开始，一步步往上加定义，可以形成很多空间。线形空间其实还是比较初级的，如果在里面定义了范数，就成了赋范线性空间。赋范线性空间满足完备性，就成了巴那赫空间；赋范线性空间中定义角度，就有了内积空间，内积空间再满足完备性，就得到希尔伯特空间。

总之，空间有很多种。你要是去看某种空间的数学定义，大致都是“存在一个集合，在这个集合上定义某某概念，然后满足某些性质”，就可以被称为空间。这未免有点奇怪，为什么要用“空间”来称呼一些这样的集合呢？大家将会看到，其实这是很有道理的。

我们一般人最熟悉的空间，毫无疑问就是我们生活在其中的（按照牛顿的绝对时空观）的三维空间，从数学上说，这是一个三维的欧几里德空间，我们先不管那么多，先看看我们熟悉的这样一个空间有些什么最基本的特点。仔细想想我们就会知道，这个三维的空间：1. 由很多（实际上是无穷多个）位置点组成；2. 这些点之间存在相对的关系；3. 可以在空间中定义长度、角度；4. <strong>这个空间可以容纳运动，这里我们所说的运动是从一个点到另一个点的移动（变换），而不是微积分意义上的“连续”性的运动，</strong>

上面的这些性质中，最最关键的是第4条。第1、2条只能说是空间的基础，不算是空间特有的性质，凡是讨论数学问题，都得有一个集合，大多数还得在这个集合上定义一些结构（关系），并不是说有了这些就算是空间。而第3条太特殊，其他的空间不需要具备，更不是关键的性质。只有第4条是空间的本质，也就是说，<strong>容纳运动是空间的本质特征。</strong>

认识到了这些，我们就可以把我们关于三维空间的认识扩展到其他的空间。<strong>事实上，不管是什么空间，都必须容纳和支持在其中发生的符合规则的运动（变换）。你会发现，在某种空间中往往会存在一种相对应的变换，比如拓扑空间中有拓扑变换，线性空间中有线性变换，仿射空间中有仿射变换，其实这些变换都只不过是对应空间中允许的运动形式而已。</strong>

因此只要知道<strong>，“空间”是容纳运动的一个对象集合，而变换则规定了对应空间的运动。</strong>

下面我们来看看线性空间。线性空间的定义任何一本书上都有，但是既然我们承认线性空间是个空间，那么有两个最基本的问题必须首先得到解决，那就是：

1. 空间是一个对象集合，线性空间也是空间，所以也是一个对象集合。那么线性空间是什么样的对象的集合？或者说，线性空间中的对象有什么共同点吗？

2. 线性空间中的运动如何表述的？也就是，线性变换是如何表示的？

我们先来回答第一个问题，回答这个问题的时候其实是不用拐弯抹角的，可以直截了当的给出答案。<strong>线性空间中的任何一个对象，通过选取基和坐标的办法，都可以表达为向量的形式。</strong>通常的向量空间我就不说了，举两个不那么平凡的例子：

L1. 最高次项不大于n次的多项式的全体构成一个线性空间，也就是说，这个线性空间中的每一个对象是一个多项式。如果我们以x<sup>0</sup>, x<sup>1</sup>, ..., x<sup>n</sup>为基，那么任何一个这样的多项式都可以表达为一组n+1维向量，其中的每一个分量a<sub>i</sub>其实就是多项式中x<sup>(i-1)</sup>项的系数。值得说明的是，基的选取有多种办法，只要所选取的那一组基线性无关就可以。这要用到后面提到的概念了，所以这里先不说，提一下而已。

L2. 闭区间[a, b]上的n阶连续可微函数的全体，构成一个线性空间。也就是说，这个线性空间的每一个对象是一个连续函数。对于其中任何一个连续函数，根据魏尔斯特拉斯定理，一定可以找到最高次项不大于n的多项式函数，使之与该连续函数的差为0，也就是说，完全相等。这样就把问题归结为L1了。后面就不用再重复了。

所以说，向量是很厉害的，只要你找到合适的基，用向量可以表示线性空间里任何一个对象。这里头大有文章，因为向量表面上只是一列数，但是其实由于它的有序性，所以除了这些数本身携带的信息之外，还可以在每个数的对应位置上携带信息。为什么在程序设计中数组最简单，却又威力无穷呢？根本原因就在于此。这是另一个问题了，这里就不说了。

下面来回答第二个问题，这个问题的回答会涉及到线性代数的一个最根本的问题。

线性空间中的运动，被称为线性变换。也就是说，你从线性空间中的一个点运动到任意的另外一个点，都可以通过一个线性变化来完成。那么，线性变换如何表示呢？<strong>很有意思，在线性空间中，当你选定一组基之后，不仅可以用一个向量来描述空间中的任何一个对象，而且可以用矩阵来描述该空间中的任何一个运动（变换）。而使某个对象发生对应运动的方法，就是用代表那个运动的矩阵，乘以代表那个对象的向量。</strong>

简而言之，<strong>在线性空间中选定基之后，向量刻画对象，矩阵刻画对象的运动，用矩阵与向量的乘法施加运动。</strong>

是的，矩阵的本质是运动的描述。如果以后有人问你矩阵是什么，那么你就可以响亮地告诉他，<strong>矩阵的本质是运动的描述</strong>。（chensh，说你呢！）

可是多么有意思啊，向量本身不是也可以看成是n x 1矩阵吗？这实在是很奇妙，<strong>一个空间中的对象和运动竟然可以用相类同的方式表示。</strong>能说这是巧合吗？如果是巧合的话，那可真是幸运的巧合！可以说，线性代数中大多数奇妙的性质，均与这个巧合有直接的关系。

接着理解矩阵。

上一篇里说“矩阵是运动的描述”，到现在为止，好像大家都还没什么意见。但是我相信早晚会有数学系出身的网友来拍板转。因为运动这个概念，在数学和物理里是跟微积分联系在一起的。我们学习微积分的时候，总会有人照本宣科地告诉你，初等数学是研究常量的数学，是研究静态的数学，高等数学是变量的数学，是研究运动的数学。大家口口相传，差不多人人都知道这句话。但是真知道这句话说的是什么意思的人，好像也不多。简而言之，在我们人类的经验里，运动是一个连续过程，从A点到B点，就算走得最快的光，也是需要一个时间来<strong>逐点</strong>地经过AB之间的路径，这就带来了连续性的概念。而连续这个事情，如果不定义极限的概念，根本就解释不了。古希腊人的数学非常强，但就是缺乏极限观念，所以解释不了运动，被芝诺的那些著名悖论（飞箭不动、飞毛腿阿喀琉斯跑不过乌龟等四个悖论）搞得死去活来。因为这篇文章不是讲微积分的，所以我就不多说了。有兴趣的读者可以去看看齐民友教授写的《重温微积分》。我就是读了这本书开头的部分，才明白“高等数学是研究运动的数学”这句话的道理。

不过在我这个《理解矩阵》的文章里，“运动”的概念不是微积分中的连续性的运动，而是瞬间发生的变化。比如这个时刻在A点，经过一个“运动”，一下子就“<strong>跃迁</strong>”到了B点，其中不需要经过A点与B点之间的任何一个点。这样的“运动”，或者说“跃迁”，是违反我们日常的经验的。不过了解一点量子物理常识的人，就会立刻指出，量子（例如电子）在不同的能量级轨道上跳跃，就是瞬间发生的，具有这样一种跃迁行为。所以说，自然界中并不是没有这种运动现象，只不过宏观上我们观察不到。但是不管怎么说，“运动”这个词用在这里，还是容易产生歧义的，说得更确切些，应该是“跃迁”。因此这句话可以改成：

“矩阵是线性空间里跃迁的描述”。

可是这样说又太物理，也就是说太具体，而不够数学，也就是说不够抽象。因此我们最后换用一个正牌的数学术语——<strong>变换</strong>，来描述这个事情。这样一说，大家就应该明白了，<strong>所谓变换，其实就是空间里从一个点（元素/对象）到另一个点（元素/对象）的跃迁</strong>。比如说，拓扑变换，就是在拓扑空间里从一个点到另一个点的跃迁。再比如说，仿射变换，就是在仿射空间里从一个点到另一个点的跃迁。附带说一下，这个仿射空间跟向量空间是亲兄弟。做计算机图形学的朋友都知道，尽管描述一个三维对象只需要三维向量，但所有的计算机图形学变换矩阵都是4 x 4的。说其原因，很多书上都写着“为了使用中方便”，这在我看来简直就是企图蒙混过关。真正的原因，是因为在计算机图形学里应用的图形变换，实际上是在仿射空间而不是向量空间中进行的。想想看，在向量空间里相一个向量平行移动以后仍是相同的那个向量，而现实世界等长的两个平行线段当然不能被认为同一个东西，所以计算机图形学的生存空间实际上是仿射空间。而仿射变换的矩阵表示根本就是4 x 4的。又扯远了，有兴趣的读者可以去看《计算机图形学——几何工具算法详解》。

一旦我们理解了“变换”这个概念，矩阵的定义就变成：

<strong>“矩阵是线性空间里的变换的描述。”</strong>

到这里为止，我们终于得到了一个看上去比较数学的定义。不过还要多说几句。教材上一般是这么说的，在一个线性空间V里的一个线性变换T，当选定一组基之后，就可以表示为矩阵。因此我们还要说清楚到底什么是线性变换，什么是基，什么叫选定一组基。线性变换的定义是很简单的，设有一种变换T，使得对于线性空间V中间任何两个不相同的对象x和y，以及任意实数a和b，有：
T(ax + by) = aT(x) + bT(y)，
那么就称T为线性变换。

定义都是这么写的，但是光看定义还得不到直觉的理解。线性变换究竟是一种什么样的变换？我们刚才说了，变换是从空间的一个点跃迁到另一个点，而线性变换，就是从一个线性空间V的某一个点跃迁到另一个线性空间W的另一个点的运动。这句话里蕴含着一层意思，就是说一个点不仅可以变换到同一个线性空间中的另一个点，而且可以变换到另一个线性空间中的另一个点去。不管你怎么变，只要变换前后都是线性空间中的对象，这个变换就一定是线性变换，也就一定可以用一个非奇异矩阵来描述。而你用一个非奇异矩阵去描述的一个变换，一定是一个线性变换。有的人可能要问，这里为什么要强调非奇异矩阵？所谓非奇异，只对方阵有意义，那么非方阵的情况怎么样？这个说起来就会比较冗长了，最后要把线性变换作为一种映射，并且讨论其映射性质，以及线性变换的核与像等概念才能彻底讲清楚。我觉得这个不算是重点，如果确实有时间的话，以后写一点。<strong>以下我们只探讨最常用、最有用的一种变换，就是在同一个线性空间之内的线性变换。也就是说，下面所说的矩阵，不作说明的话，就是方阵，而且是非奇异方阵。学习一门学问，最重要的是把握主干内容，迅速建立对于这门学问的整体概念，不必一开始就考虑所有的细枝末节和特殊情况，自乱阵脚。</strong>

接着往下说，什么是基呢？这个问题在后面还要大讲一番，这里只要<strong>把基看成是线性空间里的坐标系就可以了。</strong>注意是坐标系，不是坐标值，这两者可是一个“对立矛盾统一体”。这样一来，“选定一组基”就是说在线性空间里选定一个坐标系。就这意思。

好，最后我们把矩阵的定义完善如下：

<strong>“矩阵是线性空间中的线性变换的一个描述。在一个线性空间中，只要我们选定一组基，那么对于任何一个线性变换，都能够用一个确定的矩阵来加以描述。”</strong>

<strong>理解这句话的关键，在于把“线性变换”与“线性变换的一个描述”区别开。</strong>一个是那个对象，一个是对那个对象的表述。就好像我们熟悉的面向对象编程中，一个对象可以有多个引用，每个引用可以叫不同的名字，但都是指的同一个对象。如果还不形象，那就干脆来个很俗的类比。

比如有一头猪，你打算给它拍照片，只要你给照相机选定了一个镜头位置，那么就可以给这头猪拍一张照片。这个照片可以看成是这头猪的一个描述，但只是一个片面的的描述，因为换一个镜头位置给这头猪拍照，能得到一张不同的照片，也是这头猪的另一个片面的描述。所有这样照出来的照片都是这同一头猪的描述，但是又都不是这头猪本身。

<strong>同样的，对于一个线性变换，只要你选定一组基，那么就可以找到一个矩阵来描述这个线性变换。换一组基，就得到一个不同的矩阵。所有这些矩阵都是这同一个线性变换的描述，但又都不是线性变换本身。</strong>

但是这样的话，问题就来了如果你给我两张猪的照片，我怎么知道这两张照片上的是同一头猪呢？同样的，你给我两个矩阵，我怎么知道这两个矩阵是描述的同一个线性变换呢？如果是同一个线性变换的不同的矩阵描述，那就是本家兄弟了，见面不认识，岂不成了笑话。

好在，我们可以找到同一个线性变换的矩阵兄弟们的一个性质，那就是：

若矩阵A与B是同一个线性变换的两个不同的描述（之所以会不同，是因为选定了不同的基，也就是选定了不同的坐标系），则一定能找到一个非奇异矩阵P，使得A、B之间满足这样的关系：

A = P<sup>-1</sup>BP

线性代数稍微熟一点的读者一下就看出来，这就是相似矩阵的定义。没错，<strong>所谓相似矩阵，就是同一个线性变换的不同的描述矩阵。</strong>按照这个定义，同一头猪的不同角度的照片也可以成为相似照片。俗了一点，不过能让人明白。

而在上面式子里那个矩阵P，其实就是A矩阵所基于的基与B矩阵所基于的基这两组基之间的一个变换关系。关于这个结论，可以用一种非常直觉的方法来证明（而不是一般教科书上那种形式上的证明），如果有时间的话，我以后在blog里补充这个证明。

这个发现太重要了。<strong>原来一族相似矩阵都是同一个线性变换的描述啊！</strong>难怪这么重要！工科研究生课程中有矩阵论、矩阵分析等课程，其中讲了各种各样的相似变换，比如什么相似标准型，对角化之类的内容，都要求变换以后得到的那个矩阵与先前的那个矩阵式相似的，为什么这么要求？因为只有这样要求，才能保证变换前后的两个矩阵是描述同一个线性变换的。当然，同一个线性变换的不同矩阵描述，从实际运算性质来看并不是不分好环的。有些描述矩阵就比其他的矩阵性质好得多。这很容易理解，同一头猪的照片也有美丑之分嘛。所以矩阵的相似变换可以把一个比较丑的矩阵变成一个比较美的矩阵，而保证这两个矩阵都是描述了同一个线性变换。

这样一来，矩阵作为线性变换描述的一面，基本上说清楚了。但是，事情没有那么简单，或者说，线性代数还有比这更奇妙的性质，那就是，<strong>矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。</strong>

这个留在下一篇再写吧。

因为有别的事情要做，下一篇可能要过几天再写了。

这两篇文章发表于去年的4月。在第二部分结束的时候，我说：
“<strong>矩阵不仅可以作为线性变换的描述，而且可以作为一组基的描述。而 作为变换的矩阵，不但可以把线性空间中的一个点给变换到另一个点去，而且也能够把线性空间中的一个坐标系（基）表换到另一个坐标系（基）去。而且，变换点 与变换坐标系，具有异曲同工的效果。线性代数里最有趣的奥妙，就蕴含在其中。理解了这些内容，线性代数里很多定理和规则会变得更加清晰、直觉。</strong>

这个留在下一篇再写吧。

因为有别的事情要做，下一篇可能要过几天再写了。 ”

然而这一拖就是一年半。一年半以来，这两篇粗糙放肆的文章被到处转载，以至于在Google的搜索提示中，我的名字跟“矩阵”是一对关联词汇。这对于学生时代数学一直很差的我来说，实在是令人惶恐的事情。数学是何等辉煌精致的学问！代表着人类智慧的最高成就，是人与上帝对话的语言。而我实在连数学的门都还没进去，不要说谈什么理解，就是稍微难一些的题目我也很少能解开。我有什么资格去谈矩阵这样重要的一个数学概念呢？更何况，我的想法直观是直观，未见的是正确的啊，会不会误人子弟呢？因此，算了吧，到此为止吧，我这么想。
是时不时收到的来信逐渐改变了我的想法。

一年半以来，我收到过不下一百封直接的来信，要求我把后面的部分写出来。这些来信大部分是国内的网友和学生，也有少数来自正在国外深造的朋友，大部分是鼓励，有的是诚挚的请求，也有少数严厉斥责我不守承诺。不管是何种态度，这都表明他们对我这一点点小小的思考成果的鼓励，特别是对于我这种思维的视角和尝试的鼓励。他们在信中让我知道，尽管我的数学水平不高，但是我这种从普通人（而不是数学家）视角出发，强调对数学概念和规则的直觉理解的思路，对于很多人是有益的。也许这条路子在数学中绝非正道，也不会走得很远，但是无论如何，在一定的阶段，对一部分人来说，较之目前数学教材普遍采用的思路，这种方式可能更容易理解一些。既然是可能对一部分人有帮助的事情，那么我就不应该心存太多杂念，应该不断思考和总结下去。

所以，下面就是你们来信要求我写出来的东西。

首先来总结一下前面两部分的一些主要结论：

1. 首先有空间，空间可以容纳对象运动的。一种空间对应一类对象。
2. 有一种空间叫线性空间，线性空间是容纳向量对象运动的。
3. 运动是瞬时的，因此也被称为变换。
4. 矩阵是线性空间中运动（变换）的描述。
5. 矩阵与向量相乘，就是实施运动（变换）的过程。
6. 同一个变换，在不同的坐标系下表现为不同的矩阵，但是它们的本质是一样的，所以本征值相同。

下面让我们把视力集中到一点以改变我们以往看待矩阵的方式。我们知道，线性空间里的基本对象是向量，而向量是这么表示的：

[a<sub>1</sub>, a<sub>2</sub>, a<sub>3</sub>, ..., a<sub>n</sub>]

矩阵呢？矩阵是这么表示的：

a<sub>11</sub>, a<sub>12</sub>, a<sub>13</sub>, ..., a<sub>1n</sub>
a<sub>21</sub>, a<sub>22</sub>, a<sub>23</sub>, ..., a<sub>2n</sub>
...
a<sub>n1</sub>, a<sub>n2</sub>, a<sub>n3</sub>, ..., a<sub>nn</sub>

不用太聪明，我们就能看出来，矩阵是一组向量组成的。特别的，n维线性空间里的方阵是由n个n维向量组成的。我们在这里只讨论这个n阶的、非奇异的方阵，因为理解它就是理解矩阵的关键，它才是一般情况，而其他矩阵都是意外，都是不得不对付的讨厌状况，大可以放在一边。这里多一句嘴，学习东西要抓住主流，不要纠缠于旁支末节。很可惜我们的教材课本大多数都是把主线埋没在细节中的，搞得大家还没明白怎么回事就先被灌晕了。比如数学分析，明明最要紧的观念是说，一个对象可以表达为无穷多个合理选择的对象的线性和，这个概念是贯穿始终的，也是数学分析的精华。但是课本里自始至终不讲这句话，反正就是让你做吉米多维奇，掌握一大堆解偏题的技巧，记住各种特殊情况，两类间断点，怪异的可微和可积条件（谁还记得柯西条件、迪里赫莱条件...？），最后考试一过，一切忘光光。要我说，还不如反复强调这一个事情，把它深深刻在脑子里，别的东西忘了就忘了，真碰到问题了，再查数学手册嘛，何必因小失大呢？

言归正传。如果一组向量是彼此线性无关的话，那么它们就可以成为度量这个线性空间的一组基，从而事实上成为一个坐标系体系，其中每一个向量都躺在一根坐标轴上，并且成为那根坐标轴上的基本度量单位（长度1）。

现在到了关键的一步。看上去矩阵就是由一组向量组成的，而且如果矩阵非奇异的话（我说了，只考虑这种情况），那么组成这个矩阵的那一组向量也就是线性无关的了，也就可以成为度量线性空间的一个坐标系。结论：矩阵描述了一个坐标系。

“慢着！”，你嚷嚷起来了，“你这个骗子！你不是说过，矩阵就是运动吗？怎么这会矩阵又是坐标系了？”

嗯，所以我说到了关键的一步。我并没有骗人，之所以矩阵又是运动，又是坐标系，那是因为——

“运动等价于坐标系变换”。

对不起，这话其实不准确，我只是想让你印象深刻。准确的说法是：

“对象的变换等价于坐标系的变换”。

或者：

“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换。”

说白了就是：

“运动是相对的。”

让我们想想，达成同一个变换的结果，比如把点(1, 1)变到点(2, 3)去，你可以有两种做法。第一，坐标系不动，点动，把(1, 1)点挪到(2, 3)去。第二，点不动，变坐标系，让x轴的度量（单位向量）变成原来的1/2，让y轴的度量（单位向量）变成原先的1/3，这样点还是那个点，可是点的坐标就变成(2, 3)了。方式不同，结果一样。

从第一个方式来看，那就是我在《理解矩阵》1/2中说的，把矩阵看成是运动描述，矩阵与向量相乘就是使向量（点）运动的过程。在这个方式下，

Ma = b

的意思是：

“向量a经过矩阵M所描述的变换，变成了向量b。”

而从第二个方式来看，矩阵M描述了一个坐标系，姑且也称之为M。那么：

Ma = b

的意思是：

“有一个向量，它在坐标系M的度量下得到的度量结果向量为a，那么它在坐标系I的度量下，这个向量的度量结果是b。”

这里的I是指单位矩阵，就是主对角线是1，其他为零的矩阵。

而这两个方式本质上是等价的。

我希望你务必理解这一点，因为这是本篇的关键。

正因为是关键，所以我得再解释一下。

在M为坐标系的意义下，如果把M放在一个向量a的前面，形成Ma的样式，我们可以认为这是对向量a的一个环境声明。它相当于是说：

“注意了！这里有一个向量，它在坐标系M中度量，得到的度量结果可以表达为a。可是它在别的坐标系里度量的话，就会得到不同的结果。为了明确，我把M放在前面，让你明白，这是该向量在坐标系M中度量的结果。”

那么我们再看孤零零的向量b：

b

多看几遍，你没看出来吗？它其实不是b，它是：

Ib

也就是说：“在单位坐标系，也就是我们通常说的直角坐标系I中，有一个向量，度量的结果是b。”

而  Ma = Ib的意思就是说：

“在M坐标系里量出来的向量a，跟在I坐标系里量出来的向量b，其实根本就是一个向量啊！”

这哪里是什么乘法计算，根本就是身份识别嘛。

从这个意义上我们重新理解一下向量。向量这个东西客观存在，但是要把它表示出来，就要把它放在一个坐标系中去度量它，然后把度量的结果（向量在各个坐标轴上的投影值）按一定顺序列在一起，就成了我们平时所见的向量表示形式。你选择的坐标系（基）不同，得出来的向量的表示就不同。向量还是那个向量，选择的坐标系不同，其表示方式就不同。因此，按道理来说，每写出一个向量的表示，都应该声明一下这个表示是在哪个坐标系中度量出来的。表示的方式，就是 Ma，也就是说，有一个向量，在M矩阵表示的坐标系中度量出来的结果为a。我们平时说一个向量是[2 3 5 7]<sup>T</sup>，隐含着是说，这个向量在 I 坐标系中的度量结果是[2 3 5 7]<sup>T</sup>，因此，这个形式反而是一种简化了的特殊情况。

注意到，M矩阵表示出来的那个坐标系，由一组基组成，而那组基也是由向量组成的，同样存在这组向量是在哪个坐标系下度量而成的问题。也就是说，表述一个矩阵的一般方法，也应该要指明其所处的基准坐标系。所谓M，其实是 IM，也就是说，M中那组基的度量是在 I 坐标系中得出的。从这个视角来看，M×N也不是什么矩阵乘法了，而是声明了一个在M坐标系中量出的另一个坐标系N，其中M本身是在I坐标系中度量出来的。

回过头来说变换的问题。我刚才说，“固定坐标系下一个对象的变换等价于固定对象所处的坐标系变换”，那个“固定对象”我们找到了，就是那个向量。但是坐标系的变换呢？我怎么没看见？

请看：

Ma = Ib

我现在要变M为I，怎么变？对了，再前面乘以个M<sup>-1</sup>，也就是M的逆矩阵。换句话说，你不是有一个坐标系M吗，现在我让它乘以个M<sup>-1</sup>，变成I，这样一来的话，原来M坐标系中的a在I中一量，就得到b了。

我建议你此时此刻拿起纸笔，画画图，求得对这件事情的理解。比如，你画一个坐标系，x轴上的衡量单位是2，y轴上的衡量单位是3，在这样一个坐标系里，坐标为(1，1)的那一点，实际上就是笛卡尔坐标系里的点(2, 3)。而让它原形毕露的办法，就是把原来那个坐标系:

2 0
0 3

的x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3，这样一来坐标系就变成单位坐标系I了。保持点不变，那个向量现在就变成了(2, 3)了。

怎么能够让“x方向度量缩小为原来的1/2，而y方向度量缩小为原来的1/3”呢？就是让原坐标系：

2 0
0 3

被矩阵：

1/2   0
0   1/3

左乘。而这个矩阵就是原矩阵的逆矩阵。

下面我们得出一个重要的结论：

“对坐标系施加变换的方法，就是让表示那个坐标系的矩阵与表示那个变化的矩阵相乘。”

再一次的，矩阵的乘法变成了运动的施加。只不过，被施加运动的不再是向量，而是另一个坐标系。

如果你觉得你还搞得清楚，请再想一下刚才已经提到的结论，矩阵MxN，一方面表明坐标系N在运动M下的变换结果，另一方面，把M当成N的前缀，当成N的环境描述，那么就是说，在M坐标系度量下，有另一个坐标系N。这个坐标系N如果放在I坐标系中度量，其结果为坐标系MxN。

在这里，我实际上已经回答了一般人在学习线性代数是最困惑的一个问题，那就是为什么矩阵的乘法要规定成这样。简单地说，是因为：

1. 从变换的观点看，对坐标系N施加M变换，就是把组成坐标系N的每一个向量施加M变换。

2. 从坐标系的观点看，在M坐标系中表现为N的另一个坐标系，这也归结为，对N坐标系基的每一个向量，把它在I坐标系中的坐标找出来，然后汇成一个新的矩阵。

3. 至于矩阵乘以向量为什么要那样规定，那是因为一个在M中度量为a的向量，如果想要恢复在I中的真像，就必须分别与M中的每一个向量进行內积运算。我把这个结论的推导留给感兴趣的朋友吧。应该说，其实到了这一步，已经很容易了。

综合以上1/2/3，矩阵的乘法就得那么规定，一切有根有据，绝不是哪个神经病胡思乱想出来的。

我已经无法说得更多了。矩阵又是坐标系，又是变换。到底是坐标系，还是变换，已经说不清楚了，运动与实体在这里统一了，物质与意识的界限已经消失了，一切归于无法言说，无法定义了。道可道，非常道，名可名，非常名。矩阵是在是不可道之道，不可名之名的东西。到了这个时候，我们不得不承认，我们伟大的线性代数课本上说的矩阵定义，是无比正确的：

“矩阵就是由m行n列数放在一起组成的数学对象。”

好了，这基本上就是我想说的全部了。还留下一个行列式的问题。矩阵M的行列式实际上是组成M的各个向量按照平行四边形法则搭成一个n维立方体的体积。对于这一点，我只能感叹于其精妙，却无法揭开其中奥秘了。也许我掌握的数学工具不够，我希望有人能够给我们大家讲解其中的道理了。

我不知道是否讲得足够清楚了，反正这一部分需要您花些功夫去推敲。

此外，请大家不必等待这个系列的后续部分。以我的工作情况而言，近期内很难保证继续投入脑力到这个领域中，尽管我仍然对此兴致浓厚。不过如果还有（四）的话，可能是一些站在应用层面的考虑，比如对计算机图形学相关算法的理解。但是我不承诺这些讨论近期内会出现了。

作者连接：http://my.csdn.net/myan]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>180</wp:post_id>
		<wp:post_date>2014-10-15 17:15:25</wp:post_date>
		<wp:post_date_gmt>2014-10-15 09:15:25</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e7%90%86%e8%a7%a3%e7%9f%a9%e9%98%b5</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="%e7%9f%a9%e9%98%b5"><![CDATA[矩阵]]></category>
		<category domain="category" nicename="%e7%ae%97%e6%b3%95"><![CDATA[算法]]></category>
	</item>
	<item>
				<title>【概念】const,static,define区别</title>
		<link>http://localhost:81/wordpress/?p=182</link>
		<pubDate>Tue, 09 Dec 2014 16:00:37 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=182</guid>
		<description></description>
		<content:encoded><![CDATA[<strong>define部分：
</strong>宏不仅可以用来代替常数值，还可以用来代替表达式，甚至是代码段。（宏的功能很强大，但也容易出错，所以其利弊大小颇有争议。）
<strong>宏的语法为：
</strong>#define 宏名称 宏值
作为一种建议和一种广大程序员共同的习惯，宏名称经常使用全部大写的字母。
<strong>利用宏的优点：
1)让代码更简洁明了
</strong>当然，这有赖于你为宏取一个适当的名字。一般来说，宏的名字更要注重有明确直观的意义，有时宁可让它长点。
<strong>2)方便代码维护
</strong>对宏的处理，在编译过程中称为“预处理”。也就是说在正式编译前，编译器必须先将代码出现的宏，用其相应的宏值替换，这个过程有点你我在文字处理软件中的查找替换。所以在代码中使用宏表达常数，归根结底还是使用了立即数，并没有明确指定这个量的类型。
<strong>
const部分
</strong>常量定义的格式为：
const 数据类型 常量名 = 常量值;
而const定义的常量具有数据类型，定义数据类型的常量便于编译器进行数据检查，使程序可能出现错误进行排查。常量必须一开始就指定一个值，然后，在以后的代码中，我们不允许改变此常量的值。
<strong>
两者之间的区别：
</strong>内存空间的分配上。define进行宏定义的时候，不会分配内存空间，编译时会在main函数里进行替换，只是单纯的替换，不会进行任何检查,比如类型，语句结构等，即宏定义常量只是纯粹的置放关系，如#define null 0；编译器在遇到null时总是用0代替null它没有数据类型（还有疑问请找C语言书籍看预处理部分或者看MSDN.而const定义的常量具有数据类型，定义数据类型的常量便于编译器进行数据检查，使程序可能出现错误进行排查,所以const与define之间的区别在于const定义常量排除了程序之间的不安全性. define定义全局常量，在任何地方都可以访问

const用于类成员变量定义,只能用类名访问不能更改要是初学这样显理解着就行别太钻牛角尖就行 PHP5中加入了很多面向对象的思想,PHP5的面向对象比较接近Java的面向对象思想。我们这里对PHP5中的static和const关键字作用进行一下描述，希望对学习PHP5的朋友有帮助。

(1) staticstatic关键字在类中是，描述一个成员是静态的，static能够限制外部的访问，因为static后的成员是属于类的，是不属于任何对象实例，其他类是无法访问的，只对类的实例共享，能一定程序对该成员尽心保护。类的静态变量，非常类似全局变量，能够被所有类的实例共享，类的静态方法也是一样的，类似于全局函数。类的静态方法能访问类的静态的属性。另外说明的是，static的成员，必须使用self来访问，使用this会出错。

(2)constconst是一个定义常量的关键字，类似于C中的#define，能够定义一个常量，如果在程序中改变了它的值，那么会出现错误。举例说明上面的代码：

<code>
class Counter
{
private static $count = 0;//定义一个静态属性
const VERSION = 2.0;//定义一个常量
//构造函数
function __construct()
{
self::$count++;
}
//析构函数
function __destruct()
{
self::$count--;
}
//定义一个静态的方法
static function getCount()
{
return self::$count;
}
}
//创建一个实例
$c = new Counter();
//执行打印
print( Counter::getCount(). "\n" ); //使用直接输入类名来访问静态方法Counter::getCount
//打印类的版本
print( "Version useed: " .Counter::VERSION. "
\n" );
?&gt;
</code>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>182</wp:post_id>
		<wp:post_date>2014-12-10 00:00:37</wp:post_date>
		<wp:post_date_gmt>2014-12-09 16:00:37</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e3%80%90%e6%a6%82%e5%bf%b5%e3%80%91conststaticdefine%e5%8c%ba%e5%88%ab</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
	</item>
	<item>
				<title>Mysql全文搜索match...against的用法</title>
		<link>http://localhost:81/wordpress/?p=187</link>
		<pubDate>Thu, 11 Dec 2014 17:04:46 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=187</guid>
		<description></description>
		<content:encoded><![CDATA[前提：mysql只支持英文内容的全文索引，所以只考虑英文的全文搜索。假定数据表名为post，有三列：id、title、content。id是自增长序号，title是varchar，content是text，给content添加全文索引。

mysql全文搜索有三种模式：

一、自然语言查找。这是mysql默认的全文搜索方式，sql示例：
<pre lang="sql" line="1" escaped="true">select  id,title FROM post WHERE MATCH(content) AGAINST ('search keyword')
</pre>
或者显式声明使用自然语言搜索方式
<pre lang="sql" line="1" escaped="true">select  id,title FROM post WHERE MATCH(content) AGAINST ('search keyword' IN NATURAL LANGUAGE MODE)
</pre>
由于自然语言搜索方式是默认模式，所以可以省略声明模式的“IN NATURAL LANGUAGE MODE”部分。
自然语言搜索模式的么特点：
<ul type="1">
	<li>忽略停词（stopword），英语中频繁出现的and/or/to等词被认为是没有实际搜索的意义，搜索这些不会获得任何结果。</li>
	<li>如果某个词在数据集中频繁出现的几率超过了50%，也会被认为是停词，所以如果数据库中只有一行数据，不管你怎么全文搜索都不能获得结果。</li>
	<li>搜索结果都具有一个相关度的数据，返回结果自动按相关度由高到低排列。</li>
	<li>只针对独立的单词进行检索，而不考虑单词的局部匹配，如搜索box时，就不会将boxing作为检索目标。</li>
</ul>
二、布尔查找。这种查找方式的特点是没有自然查找模式中的50%规则，即便有词语在数据集中频繁出现的几率超过50%，也会被作为搜索目标进行检索并返回结果，而且检索时单词的局部匹配也会被作为目标进行检索。sql示例
<pre lang="sql" line="1" escaped="true">select  id,title FROM post WHERE MATCH(content) AGAINST ('search keyword' IN BOOLEAN MODE)</pre>
三、带子查询扩展的自然语言查找。
<pre lang="sql" line="1" escaped="true">
select  id,title FROM post WHERE MATCH(content) AGAINST ('search keyword' IN BOOLEAN MODE WITH EXPANSION)
</pre>
暂时没有明白这种模式。

在我的实际使用中还发现了以下细节：
<ul>
	<li>布尔查找时必须指定返回结果的排序方式，它不会像自然语言查找那样会自动将结果按相关度排序返回。</li>
	<li>即使是布尔查找，对长度小于等于3的单词也不会进行检索，因为mysql有一个系统变量FT_MIN_WORD_LEN指定了全文检索时可接受的最小单词长度，默认值是4。</li>
</ul>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>187</wp:post_id>
		<wp:post_date>2014-12-12 01:04:46</wp:post_date>
		<wp:post_date_gmt>2014-12-11 17:04:46</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>mysql%e5%85%a8%e6%96%87%e6%90%9c%e7%b4%a2match-against%e7%9a%84%e7%94%a8%e6%b3%95</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="mysql"><![CDATA[MySQL]]></category>
		<category domain="category" nicename="mysql"><![CDATA[MySQL]]></category>
		<category domain="post_tag" nicename="%e5%85%a8%e6%96%87%e6%90%9c%e7%b4%a2"><![CDATA[全文搜索]]></category>
	</item>
	<item>
				<title>PHP 字符编码转换函数</title>
		<link>http://localhost:81/wordpress/?p=191</link>
		<pubDate>Fri, 12 Dec 2014 08:12:21 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=191</guid>
		<description></description>
		<content:encoded><![CDATA[在php函数库有一个函数：iconv()，iconv函数库能够完成各种字符集间的转换，是php编程中不可缺少的基础函数库。

最近在做一个小偷程序，需要用到iconv函数把抓取来过的utf-8编码的页面转成gb2312， 发现只有用iconv函数把抓取过来的数据一转码数据就会无缘无故的少一些。 让我郁闷了好一会儿，去网上一查资料才知道这是iconv函数的一个bug。iconv在转换字符"—"到gb2312时会出错。

下面慢慢看一下这个函数的用法。

最简单的应用，把gb2312置换成utf-8：
<pre lang="php" line="1">$text=iconv("GB2312","UTF-8",$text);
</pre>
在用$text=iconv("UTF-8","GB2312",$text)过程中，如果遇到一些特别字符时，如："—"，英文名中的"."等等字符，转换就断掉了。这些字符后的文字都没法继续转换了。

针对这的问题，可以用如下代码实现：
<pre lang="php" line="1">$text=iconv("UTF-8","GBK",$text);
</pre>
你没有看错，就这么简单，不使用gb2312，而写成GBK，就可以了。

还有一种方法，第二个参数，加上//IGNORE，忽略错误，如下：
<pre lang="php" line="1">iconv("UTF-8","GB2312//IGNORE",$data);</pre>
没有具体比较这两种方法，感觉第一种（GBK代替gb2312）方法更好。

php手册中iconv() 说明：
<pre lang="php" line="1">
iconv
 
(PHP 4 >= 4.0.5, PHP 5)
iconv – Convert string to requested character encoding
Description
string iconv ( string in_charset, string out_charset, string str )
Performs a character set conversion on the string str from in_charset to out_charset. Returns the converted string or FALSE on failure.
If you append the string //TRANSLIT to out_charset transliteration is activated. This means that when a character can't be represented in the target charset, it can be approximated through one or several similarly looking characters. If you append the string //IGNORE, characters that cannot be represented in the target charset are silently discarded. Otherwise, str is cut from the first illegal character.
</pre>
在使用这个函数进行字符串编码转换时，需要注意，如果将utf-8转换为gb2312时，可能会出现字符串被截断的情况发生。此时可以使用以下方法解决：
<pre lang="php" line="1">
$str=iconv('utf-8',"gb2312//TRANSLIT",file_get_contents($filepath));
</pre>
即在第二个参数出添加红色字部分，表示：如果在目标编码中找不到与源编码相匹配的字符，会选择相似的字符进行转换。此处也可以使用：//IGNORE 这个参数，表示忽略不能转换的字符。

ignore的意思是忽略转换时的错误，如果没有ignore参数，所有该字符后面的字符串都无法被保存。

iconv不是php的默认函数，也是默认安装的模块。需要安装才能用的。

如果是windows2000+php，你可以修改php.ini文件，将extension=php_iconv.dll前的";"去掉，同时你要copy你的原php安装文件下的iconv.dll到你的winnt/system32下（如果你的dll指向的是这个目录）。在linux环境下，用静态安装的方式，在configure时加多一项 --with-iconv就可以了，phpinfo看得到iconv的项。(Linux7.3+Apache4.06+php4.3.2)。
<h4>mb_convert_encoding与iconv函数介绍</h4>
mb_convert_encoding这个函数是用来转换编码的。原来一直对程序编码这一概念不理解，不过现在好像有点开窍了。不过英文一般不会存在编码问题，只有中文数据才会有这个问题。比如你用Zend Studio或Editplus写程序时，用的是gbk编码，如果数据需要入数据库，而数据库的编码为utf8时，这时就要把数据进行编码转换，不然进到数据库就会变成乱码。

做一个GBK To UTF-8：
<pre lang="php" line="1">
<?php 
header("content-Type: text/html; charset=Utf-8"); 
echo mb_convert_encoding("妳係我的友仔", "UTF-8", "GBK"); 
?> 
</pre>

再来个GB2312 To Big5：
<pre lang="php" line="1">
<?php 
header("content-Type: text/html; charset=big5"); 
echo mb_convert_encoding("你是我的朋友", "big5", "GB2312"); 
?> 
</pre>
不过要使用上面的函数需要安装但是需要先enable mbstring 扩展库。

string mb_convert_encoding ( string str, string to_encoding [, mixed from_encoding] )需要先enable mbstring 扩展库，在 php.ini里将; extension=php_mbstring.dll 前面的 ; 去掉mb_convert_encoding 可以指定多种输入编码，它会根据内容自动识别,但是执行效率比iconv差太多；

string iconv ( string in_charset, string out_charset, string str )注意：第二个参数，除了可以指定要转化到的编码以外，还可以增加两个后缀：//TRANSLIT 和 //IGNORE，其中 //TRANSLIT 会自动将不能直接转化的字符变成一个或多个近似的字符，//IGNORE 会忽略掉不能转化的字符，而默认效果是从第一个非法字符截断。

一般情况下用 iconv，只有当遇到无法确定原编码是何种编码，或者iconv转化后无法正常显示时才用mb_convert_encoding 函数。
<pre lang="php" line="1">
$content = iconv("GBK", "UTF-8″, $content);
$content = mb_convert_encoding($content, "UTF-8″, "GBK");
</pre>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>191</wp:post_id>
		<wp:post_date>2014-12-12 16:12:21</wp:post_date>
		<wp:post_date_gmt>2014-12-12 08:12:21</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>php-%e5%ad%97%e7%ac%a6%e7%bc%96%e7%a0%81%e8%bd%ac%e6%8d%a2%e5%87%bd%e6%95%b0</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="php"><![CDATA[PHP]]></category>
	</item>
	<item>
				<title>[Java SE] 类集框架总结</title>
		<link>http://localhost:81/wordpress/?p=193</link>
		<pubDate>Thu, 02 Apr 2015 11:48:03 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=193</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>
<pre>概述 ： 最早通过对象数组保存一组数据，但是数组的大小不可改变，存在大小限制问题。后来通过链表解决此问题，但每一次开发如果都使用链表肯定很麻烦。所以JAVA提供了类集框架。</pre>
</blockquote>
<strong>类集框架 ：</strong> 动态数据操作类，在Java中类集框架实际上就是对数据结构的JAVA实现。
<h2><strong>主要的操作接口：</strong></h2>
<ul>
	<li>Collection : 存放单值的最大父接口  public interface Collection&lt;E&gt; extends Iterable&lt;E&gt;</li>
	<li>Map : 存放键值对内容  public interface Map&lt;K,V&gt;</li>
	<li>Iterator : 输出作用  public interface Iterator&lt;E&gt;</li>
</ul>
<em>注：在JDK 1.5之后这些接口中都增加了泛型的定义，最早的时候这三个接口中的内容都使用Object进行操作，但是很明显这样是会存在安全问题的，那么在JDK 1.5之后使用了泛型，那么这种安全性的问题就解决了，此时的类集真正的可以达到了以相同的类型或高度进行操作。</em>
<h3><strong> Collection 接口</strong></h3>
Collection 接口并不会被直接使用，而都是使用它的两个子接口： List  、 Set

几个核心操作：
<table style="height: 635px;" width="718">
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36"><strong>1</strong></td>
<td width="282"><strong><span style="color: #ff0000;">public boolean add(E e)</span></strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>向集合中增加元素</strong></td>
</tr>
<tr>
<td width="36">2</td>
<td width="282">public void clear()</td>
<td width="42">普通</td>
<td width="276">删除集合中的全部内容</td>
</tr>
<tr>
<td width="36">3</td>
<td width="282">public boolean contains(Object o)</td>
<td width="42">普通</td>
<td width="276">判断指定内容是否存在</td>
</tr>
<tr>
<td width="36"><strong>4</strong></td>
<td width="282"><strong><span style="color: #ff0000;">public Iterator&lt;E&gt; iterator()</span></strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>为</strong><strong>Iterator</strong><strong>接口实例化</strong></td>
</tr>
<tr>
<td width="36"><strong>5</strong></td>
<td width="282"><strong><span style="color: #ff0000;">public boolean remove(Object o)</span></strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>从集合中删除元素</strong></td>
</tr>
<tr>
<td width="36">6</td>
<td width="282">public int size()</td>
<td width="42">普通</td>
<td width="276">取得集合的大小</td>
</tr>
<tr>
<td width="36">7</td>
<td width="282">public Object[] toArray()</td>
<td width="42">普通</td>
<td width="276">将集合变为对象数组输出</td>
</tr>
<tr>
<td width="36">8</td>
<td width="282">public &lt;T&gt; T[] toArray(T[] a)</td>
<td width="42">普通</td>
<td width="276">将集合变为对象数组输出</td>
</tr>
</tbody>
</table>
<h4><strong>1） List 子接口 ：</strong> 允许重复的子接口  （<strong><span style="color: #ff0000;">Important！！</span></strong>）</h4>
扩充了Collection 接口，主要方法如下：
<table style="height: 449px;" width="718">
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36">1</td>
<td width="282">public void add(int index,E element)</td>
<td width="42">普通</td>
<td width="276">在指定的位置上增加内容</td>
</tr>
<tr>
<td width="36"><strong>2</strong></td>
<td width="282"><strong><span style="color: #ff0000;">public E get(int index)</span></strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>取得指定位置上的内容</strong></td>
</tr>
<tr>
<td width="36">3</td>
<td width="282">public E set(int index,E element)</td>
<td width="42">普通</td>
<td width="276">修改指定位置的内容</td>
</tr>
<tr>
<td width="36">4</td>
<td width="282">public ListIterator&lt;E&gt; listIterator()</td>
<td width="42">普通</td>
<td width="276">为ListIterator接口实例化</td>
</tr>
<tr>
<td width="36">5</td>
<td width="282">public E remove(int index)</td>
<td width="42">普通</td>
<td width="276">删除指定位置上的内容</td>
</tr>
</tbody>
</table>
<ul>
	<li>
<h5><strong>新的子类 ： ArrayList  (使用最多）</strong></h5>
</li>
</ul>
public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; .....
<table style="height: 598px;" width="690">
<tbody>
<tr>
<td width="636"><strong>package</strong> org.lxh.listdemo;

<strong>import</strong> java.util.ArrayList;

<strong>import</strong> java.util.List;

<strong>public</strong> <strong>class</strong> ArrayListDemo01 {

<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {

List&lt;String&gt; all = <strong>new</strong> ArrayList&lt;String&gt;(); // 实例化List接口

all.add("hello"); // 向集合中增加内容

all.add("world"); // 向集合中增加内容

all.add("!!!"); // 向集合中增加内容

<strong>for</strong> (<strong>int</strong> x = 0; x &lt; all.size(); x++) {

System.<em>out</em>.println(all.get(x)) ;

}

}

}</td>
</tr>
</tbody>
</table>
<ul>
	<li>
<h5><strong>旧的子类 ： Vector</strong></h5>
</li>
</ul>
不管是使用何种子类的，最终的代码的操作形式永远是一样的，因为所有的子类最终都必须发生向上转型的关系为父接口进行对象的实例化。
<table>
<tbody>
<tr>
<td width="636"><strong>package</strong> org.lxh.listdemo;

<strong>import</strong> java.util.List;

<strong>import</strong> java.util.Vector;

<strong>public</strong> <strong>class</strong> VectorDemo {

<strong>public</strong> <strong>static</strong> <strong>void</strong> main(String[] args) {

List&lt;String&gt; all = <strong>new</strong> Vector&lt;String&gt;(); // 实例化List接口

all.add("hello"); // 向集合中增加内容

all.add("world"); // 向集合中增加内容

all.add("!!!"); // 向集合中增加内容

<strong>for</strong> (<strong>int</strong> x = 0; x &lt; all.size(); x++) {

System.<em>out</em>.println(all.get(x)) ;

}

}

}</td>
</tr>
</tbody>
</table>
<ul>
	<li>
<h5><strong> ArrayList 与Vector 的区别</strong></h5>
</li>
</ul>
从代码的最终的操作形式上可以发现，代码的输出结果与之前是一样的，而且没有区别，但是两者的区别还在于其内部的组成上。
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="84"><strong>区别点</strong></td>
<td width="258"><strong>ArrayList</strong></td>
<td width="258"><strong>Vector</strong></td>
</tr>
<tr>
<td width="36">1</td>
<td width="84">推出时间</td>
<td width="258">JDK 1.2之后</td>
<td width="258">JDK 1.0的时候推出</td>
</tr>
<tr>
<td width="36">2</td>
<td width="84">线程处理</td>
<td width="258">ArrayList采用异步处理</td>
<td width="258">采用同步处理</td>
</tr>
<tr>
<td width="36">3</td>
<td width="84">性能</td>
<td width="258">速度较快</td>
<td width="258">速度相对较慢</td>
</tr>
<tr>
<td width="36">4</td>
<td width="84">安全性</td>
<td width="258">非线程安全性的操作</td>
<td width="258">属于线程安全的操作</td>
</tr>
<tr>
<td rowspan="2" width="36">5</td>
<td rowspan="2" width="84">输出</td>
<td colspan="2" width="516">由于都是List接口的子类，所以都可以依靠size()和get()两个方法完成循环输出</td>
</tr>
<tr>
<td width="258">for、Iterator、ListIterator</td>
<td width="258">for、Iterator、ListIterator、Enumeration</td>
</tr>
</tbody>
</table>
注：关于 JAVA中的线程安全
<blockquote>
<pre>如果你的代码所在的进程中有多个线程在同时运行，而这些线程可能会同时运行这段代码。如果每次运行结果和单线程运行的结果是一样的，而且其他的变量的值也和预期的是一样的，就是线程安全的。
比如一个 ArrayList 类，在添加一个元素的时候，它可能会有两步来完成：1. 在 Items[Size] 的位置存放此元素；2. 增大 Size 的值。</pre>
<pre>　　在单线程运行的情况下，如果 Size = 0，添加一个元素后，此元素在位置 0，而且 Size=1；</pre>
<pre>　　而如果是在多线程情况下，比如有两个线程，线程 A 先将元素存放在位置 0。但是此时 CPU 调度线程A暂停，线程 B 得到运行的机会。线程B也向此 ArrayList 添加元素，因为此时 Size 仍然等于 0 （注意哦，我们假设的是添加一个元素是要两个步骤哦，而线程A仅仅完成了步骤1），所以线程B也将元素存放在位置0。然后线程A和线程B都继续运行，都增加 Size 的值。</pre>
<pre>　　那好，现在我们来看看 ArrayList 的情况，元素实际上只有一个，存放在位置 0，而 Size 却等于 2。这就是“线程不安全”了。
如何做到线程安全：
四种方式   sychronized关键字
 1. sychronized method(){}
 2. sychronized (objectReference) {/*block*/}
 3. static synchronized method(){}
 4. sychronized(classname.class)</pre>
</blockquote>
<h4><strong> 2） Set : 不允许重复的子接口 （Important !!! )</strong></h4>
Set接口没有对Collection 进行扩充，接口的定义与Collection是完全一致的

Set 接口也需要对通过子类进行对象的实例化，常用的子类如下：
<ul>
	<li>
<h5><strong>HashSet</strong></h5>
</li>
</ul>
public class HashSet&lt;E&gt; extends AbstractSet&lt;E&gt; Implements Set&lt;E&gt;, Cloneable, Serializable

Set 接口中不允许有重复的元素出现，而且与List接口不同的是，List采用的是顺序的方式加入元素，而Set中的内容并没有任何的顺序，属于散列存放

Set&lt;String&gt; all = new HashSet&lt;String&gt; ();
all.add("Hello");
all.add("Hello");  //重复设置
all.add("World");
all.add("！！！");
System.out.println(all);
<ul>
	<li>
<h5><strong>TreeSet</strong></h5>
</li>
</ul>
TreeSet 操作的子类是使用顺序的方式保存元素。<code></code>

Set&lt;String&gt; all = new TreeSet&lt;String&gt;();
all.add("A");
all.add("A");
all.add("C");
all.add("B");
System.out.println(all);

没有重复内容，加入的时候没有顺序，但输出的时候是按照顺序输出的。具体的排序规则由元素类型及所重写的compareTo 方法决定（Comparable接口）

hashCode()就相当于一个对象的唯一的编号，而如果要想进行具体的内容验证，就需要使用equals()方法完成。
hashCode()方法返回的是一个数字，那么很明显，就必须通过一种算法，可以完成一个唯一的编号。如果现在使用的是eclipse进行开发的话，则此工具将会自动生成编号和比较。

&nbsp;
<h3><strong>集合输出</strong></h3>
在正常情况下，不会使用将集合变成对象数组的方式进行输出，而是用以下四种形式：
<ul>
	<li>Iterator</li>
	<li>ListIterator</li>
	<li>Enumeration</li>
	<li>Foreach</li>
</ul>
<strong>*) 迭代输出 Iterator  （用于输出的操作接口）</strong>

只要是集合输出的问题同，直接使用Iterator输出

三个操作方法
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36"><strong>1</strong></td>
<td width="282"><strong>public boolean hasNext()</strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>判断是否有下一个元素</strong></td>
</tr>
<tr>
<td width="36"><strong>2</strong></td>
<td width="282"><strong>public E next()</strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>取出当前元素</strong></td>
</tr>
<tr>
<td width="36">3</td>
<td width="282">public void remove()</td>
<td width="42">普通</td>
<td width="276">删除当前内容</td>
</tr>
</tbody>
</table>
示例代码：

List&lt;String&gt; all = new ArrayList&lt;String&gt; ();
all.add("hello");
all.add("world");
Iterator&lt;String&gt; iter = all.iterator();
while(iter.hasNext()) {
String str = iter.next();
System.out.println(str + "、");
}

<strong>*) 双向迭代输出 ListIterator</strong>

ListIterator可完成双向（由前向后，由后向前） 输出

public interface ListIterator &lt;E&gt; extends Iterator&lt;E&gt;

ListIterator 是Iterator的子接口，有额外的两个重要方法：
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36">1</td>
<td width="282">public boolean hasPrevious()</td>
<td width="42">普通</td>
<td width="276">判断是否有前一个元素</td>
</tr>
<tr>
<td width="36">2</td>
<td width="282">public E previous()</td>
<td width="42">普通</td>
<td width="276">取出当前的元素</td>
</tr>
</tbody>
</table>
但是需要注意的是，<span style="color: #ff0000;">如果要想进行由后向前的输出，必须先由前向后</span>。但是在Collection接口中并没有为ListIterator接口实例化的操作，但是在List接口中存在此方法：public ListIterator&lt;E&gt; listIterator()

<strong>*) 几乎废弃的接口 ： Enumeration</strong>
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36">1</td>
<td width="282">public boolean hasMoreElements()</td>
<td width="42">普通</td>
<td width="276">判断是否有下一个元素</td>
</tr>
<tr>
<td width="36">2</td>
<td width="282">public E nextElement()</td>
<td width="42">普通</td>
<td width="276">取出当前元素</td>
</tr>
</tbody>
</table>
从方法名称上可以发现，要比Iterator接口中的方法难记很多，所以这个接口几乎废弃了。 而且Collection接口本身并不支持这种输出，而只有与之同时期出现的Vector支持此种输出方式。

<strong>*) 新的支持：Foreach</strong>

for (String str : all) {
System.out.println(str);
}
<h3><strong>Map 接口</strong></h3>
保存键值对元素

public interface Map&lt;K,V&gt;
需要同时指定两个泛型

常用方法：
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="282"><strong>方法名称</strong></td>
<td width="42"><strong>类型</strong></td>
<td width="276"><strong>描述</strong></td>
</tr>
<tr>
<td width="36"><strong>1</strong></td>
<td width="282"><strong>public V put(K key,V value)</strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>向集合中增加元素</strong></td>
</tr>
<tr>
<td width="36"><strong>2</strong></td>
<td width="282"><strong>public V get(Object key)</strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>根据</strong><strong>key</strong><strong>取得</strong><strong>value</strong></td>
</tr>
<tr>
<td width="36">3</td>
<td width="282">public Set&lt;K&gt; keySet()</td>
<td width="42">普通</td>
<td width="276">取出所有的key</td>
</tr>
<tr>
<td width="36">4</td>
<td width="282">public Collection&lt;V&gt; values()</td>
<td width="42">普通</td>
<td width="276">取出所有的value</td>
</tr>
<tr>
<td width="36">5</td>
<td width="282">public V remove(Object key)</td>
<td width="42">普通</td>
<td width="276">删除一个指定的key</td>
</tr>
<tr>
<td width="36"><strong>6</strong></td>
<td width="282"><strong>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</strong></td>
<td width="42"><strong>普通</strong></td>
<td width="276"><strong>将所有的集合变为</strong><strong>Set</strong><strong>集合</strong></td>
</tr>
</tbody>
</table>
Map中的内部接口： Map.Entry

Map 中的一个元素就是一个Map.Entry
<ul>
	<li>HashMap</li>
	<li>TreeMap</li>
	<li>HashTable</li>
</ul>
<h4><strong>1) HashMap</strong></h4>
Map&lt;String, String&gt; all = new HashMap&lt;String, String&gt;();
all.put("BJ", "Beijing");
all.put("GZ", "Guangzhou");
all.put("SZ", "Shenzhen");
String value = all.get("SZ");

在Map的操作中，如果根据key找不到value,则内容为NULL

<strong>Map集合的输出问题：</strong>

使用Iterator进行Map的输出需要采用如下的步骤：
<ul>
	<li>将所有的Map集合通过entrySet() 方法变成Set集合，里面的每一个元素都是Map.Entry的实例</li>
	<li>利用Set接口提供的Iterator()方法为Iterator接口实例化</li>
	<li>通过迭代，并利用完成key value分离</li>
</ul>
Set&lt;Map.Entry&lt;String, String&gt;&gt; set = all.entrySet();
Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iter = set.iterator();
while (iter.hasNext()) {
Map.Entry&lt;String, String&gt; me = iter.next();
。。。。。
}
<h4><strong>2) TreeMap</strong></h4>
HashMap子类中的key都属于无序存放的，如果希望有序存放（按key排序）， 则可以使用TreeMap类完成。
<h4><strong>3) HashTable</strong></h4>
属于旧的子类，与Vector情况有点类似。

HashMap与HashTable的区别：
<table>
<tbody>
<tr>
<td width="36"><strong>No.</strong></td>
<td width="84"><strong>区别点</strong></td>
<td width="258"><strong>HashMap</strong></td>
<td width="258"><strong>Hashtable</strong></td>
</tr>
<tr>
<td width="36">1</td>
<td width="84">推出时间</td>
<td width="258">JDK 1.2之后</td>
<td width="258">JDK 1.0的时候推出</td>
</tr>
<tr>
<td width="36">2</td>
<td width="84">线程处理</td>
<td width="258">采用异步处理</td>
<td width="258">采用同步处理</td>
</tr>
<tr>
<td width="36">3</td>
<td width="84">性能</td>
<td width="258">速度较快</td>
<td width="258">速度相对较慢</td>
</tr>
<tr>
<td width="36">4</td>
<td width="84">安全性</td>
<td width="258">非线程安全性的操作</td>
<td width="258">属于线程安全的操作</td>
</tr>
<tr>
<td width="36">5</td>
<td width="84">保存null</td>
<td width="258">允许key设置成null</td>
<td width="258">不允许设置，否则出现NullPointerException</td>
</tr>
</tbody>
</table>
&nbsp;]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>193</wp:post_id>
		<wp:post_date>2015-04-02 19:48:03</wp:post_date>
		<wp:post_date_gmt>2015-04-02 11:48:03</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>java-se-%e7%b1%bb%e9%9b%86%e6%a1%86%e6%9e%b6%e6%80%bb%e7%bb%93</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="java"><![CDATA[JAVA]]></category>
	</item>
	<item>
				<title>ETL 简介</title>
		<link>http://localhost:81/wordpress/?p=196</link>
		<pubDate>Tue, 20 Oct 2015 06:25:15 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=196</guid>
		<description></description>
		<content:encoded><![CDATA[1、ETL的定义

ETL分别是“Extract”、“ Transform” 、“Load”三个单词的首字母缩写也就是“抽取”、“转换”、“装载”，但我们日常往往简称其为数据抽取。

ETL是BI/DW（商务智能/数据仓库）的核心和灵魂，按照统一的规则集成并提高数据的价值，是负责完成数据从数据源向目标数据仓库转化的过程，是实施数据仓库的重要步骤。

ETL包含了三方面：

“抽取”：将数据从各种原始的业务系统中读取出来，这是所有工作的前提。

“转换”：按照预先设计好的规则将抽取得数据进行转换，使本来异构的数据格式能统一起来。

“装载”：将转换完的数据按计划增量或全部导入到数据仓库中。

 

2、为什么需要ETL？

因为目前运行的应用系统是用户花费了很大精力和财力构建的、不可替代的系统，尤其系统中的数据是非常之宝贵。但由于不同原始数据库中的数据的来源、格式不一样，导致了系统实施、数据整合出现问题。ETL就是用来解决这一问题的。

3.ETL工具的典型代表有:Informatica、Datastage、OWB、微软DTS、Beeload、Kettle]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>196</wp:post_id>
		<wp:post_date>2015-10-20 14:25:15</wp:post_date>
		<wp:post_date_gmt>2015-10-20 06:25:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>etl-%e7%ae%80%e4%bb%8b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="etl"><![CDATA[ETL]]></category>
		<category domain="category" nicename="oracle-db"><![CDATA[Oracle DB]]></category>
		<category domain="category" nicename="big-data"><![CDATA[大数据]]></category>
	</item>
	<item>
				<title>hashcode 与 equals 区别与联系</title>
		<link>http://localhost:81/wordpress/?p=198</link>
		<pubDate>Tue, 20 Oct 2015 06:45:15 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=198</guid>
		<description></description>
		<content:encoded><![CDATA[一、equals方法的作用
   1、默认情况（没有覆盖equals方法）下equals方法都是调用Object类的equals方法，而Object的equals方法主要用于判断对象的内存地址引用是不是同一个地址（是不是同一个对象）。

2 、要是类中覆盖了equals方法，那么就要根据具体的代码来确定equals方法的作用了，覆盖后一般都是通过对象的内容是否相等来判断对象是否相等。

没有覆盖equals方法代码如下：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
      
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
}  
测试 代码如下：

[java] view plaincopy
import java.util.HashSet;  
import java.util.LinkedList;  
import java.util.Set;  
  
  
public class EqualsTest {  
    public static void main(String[] args) {  
        LinkedList<Student> list = new LinkedList<Student>();  
        Set<Student> set = new HashSet<Student>();  
        Student stu1  = new Student(3,"张三");  
        Student stu2  = new Student(3,"张三");  
        System.out.println("stu1 == stu2 : "+(stu1 == stu2));  
        System.out.println("stu1.equals(stu2) : "+stu1.equals(stu2));  
        list.add(stu1);  
        list.add(stu2);  
        System.out.println("list size:"+ list.size());  
          
        set.add(stu1);  
        set.add(stu2);  
        System.out.println("set size:"+ set.size());  
    }  
  
}  


运行结果：

stu1 == stu2 : false
stu1.equals(stu2) : false
list size:2
set size:2
结果分析：Student类没有覆盖equals方法，stu1调用equals方法实际上调用的是Object的equals方法。所以采用对象内存地址是否相等来判断对象是否相等。因为是两个新对象所以对象的内存地址不相等，所以stu1.equals(stu2) 是false。

3、我们覆盖一下equals方法（age和name属性），让Student类其通过判断对象的内容是否相等来确定对象是否相等。

覆盖后的Student类：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
      
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    @Override  
    public boolean equals(Object obj) {  
        if (this == obj)  
            return true;  
        if (obj == null)  
            return false;  
        if (getClass() != obj.getClass())  
            return false;  
        Student other = (Student) obj;  
        if (age != other.age)  
            return false;  
        if (name == null) {  
            if (other.name != null)  
                return false;  
        } else if (!name.equals(other.name))  
            return false;  
        return true;  
    }  
      
}  

运行结果：
stu1 == stu2 : false
stu1.equals(stu2) : true
list size:2
set size:2

结果分析：因为Student两个对象的age和name属性相等，而且又是通过覆盖equals方法来判断的，所示stu1.equals(stu2) 为true。注意以上几次测试list和set的size都是2

二、HashCode

4、通过以上的代码运行，我们知道equals方法已经生效。接下来我们在覆盖一下hashCode方法（通过age和name属性来生成hashcode）并不覆盖equals方法，其中Hash码是通过age和name生成的。

覆盖hashcode后的Student类：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
      
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    @Override  
    public int hashCode() {  
        final int prime = 31;  
        int result = 1;  
        result = prime * result + age;  
        result = prime * result + ((name == null) ? 0 : name.hashCode());  
        return result;  
    }     
}  

运行结果：
stu1 == stu2 : false
stu1.equals(stu2) : false
list size:2
hashCode :775943
hashCode :775943
set size:2

结果分析：我们并没有覆盖equals方法只覆盖了hashCode方法，两个对象虽然hashCode一样，但在将stu1和stu2放入set集合时由于equals方法比较的两个对象是false，所以就没有在比较两个对象的hashcode值。

5、我们覆盖一下equals方法和hashCode方法。

Student代码如下：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    @Override  
    public int hashCode() {  
        final int prime = 31;  
        int result = 1;  
        result = prime * result + age;  
        result = prime * result + ((name == null) ? 0 : name.hashCode());  
        System.out.println("hashCode : "+ result);  
        return result;  
    }  
    @Override  
    public boolean equals(Object obj) {  
        if (this == obj)  
            return true;  
        if (obj == null)  
            return false;  
        if (getClass() != obj.getClass())  
            return false;  
        Student other = (Student) obj;  
        if (age != other.age)  
            return false;  
        if (name == null) {  
            if (other.name != null)  
                return false;  
        } else if (!name.equals(other.name))  
            return false;  
        return true;  
    }  
      
}  


运行结果：

stu1 == stu2 : false

stu1.equals(stu2) :true

list size:2

hashCode :775943

hashCode :775943

set size:1

结果分析：stu1和stu2通过equals方法比较相等，而且返回的hashCode值一样，所以放入set集合中时只放入了一个对象。

6、下面我们让两个对象equals方法比较相等，但hashCode值不相等试试。

Student类的代码如下：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
    <span style="color:#ff0000;">private static int index=5;</span>  
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    @Override  
    public int hashCode() {  
        final int prime = 31;  
        int result = 1;  
        result = prime * result + <span style="color:#ff0000;">(age+index++)</span>;  
        result = prime * result + ((name == null) ? 0 : name.hashCode());  
        <span style="color:#ff0000;">System.out.println("result :"+result);</span>  
        return result;  
    }  
    @Override  
    public boolean equals(Object obj) {  
        if (this == obj)  
            return true;  
        if (obj == null)  
            return false;  
        if (getClass() != obj.getClass())  
            return false;  
        Student other = (Student) obj;  
        if (age != other.age)  
            return false;  
        if (name == null) {  
            if (other.name != null)  
                return false;  
        } else if (!name.equals(other.name))  
            return false;  
        return true;  
    }  
      
}  
运行结果：
stu1 == stu2 : false
stu1.equals(stu2) : true
list size:2
hashCode :776098
hashCode :776129
set size:2

结果分析：虽然stu1和stu2通过equals方法比较相等，但两个对象的hashcode的值并不相等，所以在将stu1和stu2放入set集合中时认为是两个不同的对象。

7、修改stu1的某个属性值

Student代码如下：


[java] view plaincopy
//学生类  
public class Student {  
    private int age;  
    private String name;  
    public Student() {  
    }  
    public Student(int age, String name) {  
        super();  
        this.age = age;  
        this.name = name;  
    }  
    public int getAge() {  
        return age;  
    }  
    public String getName() {  
        return name;  
    }  
    public void setAge(int age) {  
        this.age = age;  
    }  
    public void setName(String name) {  
        this.name = name;  
    }  
    @Override  
    public int hashCode() {  
        final int prime = 31;  
        int result = 1;  
        result = prime * result + age;  
        result = prime * result + ((name == null) ? 0 : name.hashCode());  
        System.out.println("hashCode : "+ result);  
        return result;  
    }  
    @Override  
    public boolean equals(Object obj) {  
        if (this == obj)  
            return true;  
        if (obj == null)  
            return false;  
        if (getClass() != obj.getClass())  
            return false;  
        Student other = (Student) obj;  
        if (age != other.age)  
            return false;  
        if (name == null) {  
            if (other.name != null)  
                return false;  
        } else if (!name.equals(other.name))  
            return false;  
        return true;  
    }  
      
}  

测试代码如下：

[java] view plaincopy
import java.util.HashSet;  
import java.util.LinkedList;  
import java.util.Set;  
  
  
public class EqualsTest {  
    public static void main(String[] args) {  
        LinkedList<Student> list = new LinkedList<Student>();  
        Set<Student> set = new HashSet<Student>();  
        Student stu1  = new Student(3,"张三");  
        Student stu2  = new Student(3,"张三");  
        System.out.println("stu1 == stu2 : "+(stu1 == stu2));  
        System.out.println("stu1.equals(stu2) : "+stu1.equals(stu2));  
        list.add(stu1);  
        list.add(stu2);  
        System.out.println("list size:"+ list.size());  
          
        set.add(stu1);  
        set.add(stu2);  
        System.out.println("set size:"+ set.size());  
        stu1.setAge(34);  
        System.out.println("remove stu1 : "+set.remove(stu1));  
        System.out.println("set size:"+ set.size());  
    }  
  
}  

运行结果：
stu1 == stu2 : false
stu1.equals(stu2) : true
list size:2
hashCode : 775943
hashCode : 775943
set size:1
hashCode : 776904
remove stu1 : false
set size:1

结果分析：

当我们将某个对象存到set中时，如果该对象的属性参与了hashcode的计算，那么以后就不能修改该对象参与hashcode计算的那些属性了，否则会引起意向不到的错误的。正如测试中，不能够移除stu1对象。
总结：

1、equals方法用于比较对象的内容是否相等（覆盖以后）

2、hashcode方法只有在集合中用到

3、当覆盖了equals方法时，比较对象是否相等将通过覆盖后的equals方法进行比较（判断对象的内容是否相等）。

4、将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。

5、将元素放入集合的流程图：







6、HashSet中add方法源代码：


[java] view plaincopy
public boolean add(E e) {  
    return map.put(e, PRESENT)==null;  
    }  
map.put源代码:
[java] view plaincopy
<pre name="code" class="java"> public V put(K key, V value) {  
        if (key == null)  
            return putForNullKey(value);  
        int hash = hash(key.hashCode());  
        int i = indexFor(hash, table.length);  
        for (Entry<K,V> e = table[i]; e != null; e = e.next) {  
            Object k;  
            if (e.hash == hash && ((k = e.key) == key || key.equals(k))) {  
                V oldValue = e.value;  
                e.value = value;  
                e.recordAccess(this);  
                return oldValue;  
            }  
        }  
  
        modCount++;  
        addEntry(hash, key, value, i);  
        return null;  
    }</pre>  
<pre></pre>  
<pre></pre>  
      
        <div style="padding-top:20px">           
            <p style="font-size:12px;">版权声明：本文为博主原创文章，未经博主允许不得转载。</p>  
        </div>  ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>198</wp:post_id>
		<wp:post_date>2015-10-20 14:45:15</wp:post_date>
		<wp:post_date_gmt>2015-10-20 06:45:15</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>hashcode-%e4%b8%8e-equals-%e5%8c%ba%e5%88%ab%e4%b8%8e%e8%81%94%e7%b3%bb</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="equals"><![CDATA[equals]]></category>
		<category domain="post_tag" nicename="hashcode"><![CDATA[hashcode]]></category>
		<category domain="category" nicename="java"><![CDATA[JAVA]]></category>
		<category domain="post_tag" nicename="java-2"><![CDATA[java]]></category>
	</item>
	<item>
				<title>Oracle使用SQL语句进行递归查询</title>
		<link>http://localhost:81/wordpress/?p=200</link>
		<pubDate>Tue, 20 Oct 2015 07:52:17 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=200</guid>
		<description></description>
		<content:encoded><![CDATA[Oracle使用SQL语句进行递归查询

问题描述：
1	0		
2	0		
3	1		
4	1		
5	2		
6	2		
7	3		
8	4		
9	5		
取出id为1及其下属的所有的数据,结果为下
id	pid		
1	0		
3	1		
4	1		
7	3		
8	4	 	 
 
SQL> CREATE TABLE TBL_TEST
  2  (
  3    ID    NUMBER,
  4    NAME  VARCHAR2(100 BYTE),
  5    PID   NUMBER                                  DEFAULT 0
  6  );
Table created
SQL> INSERT INTO TBL_TEST(ID,NAME,PID) VALUES('1','10','0');
1 row inserted
SQL> INSERT INTO TBL_TEST(ID,NAME,PID) VALUES('2','11','1');
1 row inserted
SQL> INSERT INTO TBL_TEST(ID,NAME,PID) VALUES('3','20','0');
1 row inserted
SQL> INSERT INTO TBL_TEST(ID,NAME,PID) VALUES('4','12','1');
1 row inserted
SQL> INSERT INTO TBL_TEST(ID,NAME,PID) VALUES('5','121','2');
1 row inserted
SQL> 
SQL> select * from TBL_TEST
  2   start with id=1
  3   connect by prior id = pid
  4  /
        ID NAME                                                                                    PID
---------- -------------------------------------------------------------------------------- ----------
         1 10                                                                                        0
         2 11                                                                                        1
         5 121                                                                                       2
         4 12                                                                                        1
SQL> 
SQL> select * from TBL_TEST
  2   start with id=5
  3   connect by prior pid = id
  4  /
        ID NAME                                                                                    PID
---------- -------------------------------------------------------------------------------- ----------
         5 121                                                                                       2
         2 11                                                                                        1
         1 10 ]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>200</wp:post_id>
		<wp:post_date>2015-10-20 15:52:17</wp:post_date>
		<wp:post_date_gmt>2015-10-20 07:52:17</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle%e4%bd%bf%e7%94%a8sql%e8%af%ad%e5%8f%a5%e8%bf%9b%e8%a1%8c%e9%80%92%e5%bd%92%e6%9f%a5%e8%af%a2</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="oracle-db"><![CDATA[Oracle DB]]></category>
	</item>
	<item>
				<title>Oracle 产品线概述与总结</title>
		<link>http://localhost:81/wordpress/?p=202</link>
		<pubDate>Tue, 27 Oct 2015 13:03:01 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=202</guid>
		<description></description>
		<content:encoded><![CDATA[最近看了Oracle Open World大会的相关视频，忽然对Oracle的产品线产生兴趣，于是把之前的一些了解重新梳理了一下。。

这次Oracle Open World大会的重头戏是Oracle Cloud云产品，还把“退休”的拉里老头给请回来，讲了一个多小时的云。。重要程度不言而喻。

自己脑爆地根据理解和了解到的一些信息画了下面这个图。对于企业产品来说，Oracle确实已经通过各种途径（自研、收购）达到了全栈式、一体式的企业软件管理及应用。从最底层的存储服务设备，再到应用层的各个产品，企业软件这块，Oracle确实已经可以说是No1了。

这次的Open World正式推出的Oracle Cloud，则可以说是Oracle野心的真实显露。同时这也印证了Larry Ellison追求的对行业的引领和绝对的掌控力。云是一个全新的时代，重新定义了计算，而Oracle就是想做三层服务的提供者。

<a href="http://bugalot.com/wp-content/uploads/2015/10/Oracle-Product.png"><img class="alignleft size-full wp-image-203" src="http://bugalot.com/wp-content/uploads/2015/10/Oracle-Product.png" alt="Oracle Product" width="1064" height="1564" /></a>

<a href="http://bugalot.com/wp-content/uploads/2015/10/Oracle-优化解决方案.png"><img class="alignleft size-full wp-image-204" src="http://bugalot.com/wp-content/uploads/2015/10/Oracle-优化解决方案.png" alt="Oracle 优化解决方案" width="924" height="511" /></a>

<a href="http://bugalot.com/wp-content/uploads/2015/10/QQ截图20151027200355.png"><img class="alignleft size-full wp-image-205" src="http://bugalot.com/wp-content/uploads/2015/10/QQ截图20151027200355.png" alt="QQ截图20151027200355" width="870" height="456" /></a>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>202</wp:post_id>
		<wp:post_date>2015-10-27 21:03:01</wp:post_date>
		<wp:post_date_gmt>2015-10-27 13:03:01</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-%e4%ba%a7%e5%93%81%e7%ba%bf%e6%a6%82%e8%bf%b0%e4%b8%8e%e6%80%bb%e7%bb%93</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="post_tag" nicename="%e4%ba%91%e8%ae%a1%e7%ae%97"><![CDATA[云计算]]></category>
		<category domain="category" nicename="cloud"><![CDATA[云计算]]></category>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
		<category domain="post_tag" nicename="%e5%a4%a7%e6%95%b0%e6%8d%ae"><![CDATA[大数据]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
	</item>
	<item>
				<title>Java 线程与线程池 总结</title>
		<link>http://localhost:81/wordpress/?p=210</link>
		<pubDate>Sun, 01 Nov 2015 18:56:06 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=210</guid>
		<description></description>
		<content:encoded><![CDATA[<pre><strong>为什么使用线程？</strong>
程序的运行模式可以分成串行和并行，传统的dos系统就是典型的串行程序的运行，在同一时间内只能有一个程序运行，而并行就是可以同一时间运行多个程序。多个程序就是多个进程。

而线程是相对于进程而言的。在操作系统中，可以在同一个时间段上运行多个程序。所有的程序都是并发运行的。但在一个时间点上只能有一个进行执行。
而线程实际就是进程基础上的进一步划分，一个进程可以划分多个线程。
就好比word，word运行于windows中就相当于一个进程，而拼写检查就是这个进程中的一个线程，当word运行时，才会可能存在拼写检查的操作。

在一个程序中，这些独立运行的程序片段就叫作线程，它能允许程序在同一时间执行多个任务，进而提升整体处理性能。

一个采用了多线程技术的应用程序可以更好地利用系统资源。其主要优势在于充分利用了CPU的空闲时间片，可以用尽可能少的时间来对用户的要求做出响应，使得进程的整体运行效率得到较大提高，同时增强了应用程序的灵活性。更为重要的是，由于同一进程的所有线程是共享同一内存，所以不需要特殊的数据传送机制，不需要建立共享存储区或共享文件，从而使得不同任务之间的协调操作与运行、数据的交互、资源的分配等问题更加易于解决。</pre>
<h2>Java创建线程的三种方式及对比</h2>
<h3>1.继承Thread 类</h3>
<ul>
	<li>重写run 方法，方法体代表要处理的任务。因此把run()方法称为执行体。</li>
	<li>调用start()方法来启动线程</li>
	<li>在Thread中可以直接使用getName()方法返回调用的当前线程的线程名</li>
	<li>使用Thread.currentThread() 方法返回当前正在执行的线程对象</li>
</ul>
<pre class="java">class Thread_Thread extends Thread {
	int i = 0;
	
	public void run() {
		for (; i&lt;100; i++) {
			System.out.println(getName() + "" +i);
		}
	}
	
}
</pre>
<h3> 2.实现Runnable接口</h3>
<ul>
	<li>重写run()方法</li>
	<li>借助Thread类来创建Thread对象</li>
	<li>调用线程对象start()方法来启动线程</li>
</ul>
<pre class="java">class Thread_Runnable implements Runnable {
	
	private int i;

	@Override
	public void run() {
		// TODO Auto-generated method stub
		for (; i&lt;100; i++) {
			System.out.println(Thread.currentThread().getName() + "" +i);
		}
	}
}
</pre>
<h3> 3.通过Callable和Future创建线程</h3>
1) 实现Callable接口，重写实现call（）方法。call()方法作为线程执行体，并且有返回值
2) 使用FutureTask类来包装Callable对象，该FutureTask对象封装了Callable对象的call()方法的返回值
3) 使用FutureTask对象作为Thread对象的target创建并启动新线程|
4) 调用FutureTask对象的get() 方法来获得子线程执行结束后的返回值
<pre class="java">package com.thread;

import java.util.concurrent.Callable;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.FutureTask;

public class CallableThreadTest implements Callable
{

	public static void main(String[] args)
	{
		CallableThreadTest ctt = new CallableThreadTest();
		FutureTask ft = new FutureTask&lt;&gt;(ctt);
		for(int i = 0;i &lt; 100;i++)
		{
			System.out.println(Thread.currentThread().getName()+" 的循环变量i的值"+i);
			if(i==20)
			{
				new Thread(ft,"有返回值的线程").start();
			}
		}
		try
		{
			System.out.println("子线程的返回值："+ft.get());
		} catch (InterruptedException e)
		{
			e.printStackTrace();
		} catch (ExecutionException e)
		{
			e.printStackTrace();
		}

	}

	@Override
	public Integer call() throws Exception
	{
		int i = 0;
		for(;i&lt;100;i++)
		{
			System.out.println(Thread.currentThread().getName()+" "+i);
		}
		return i;
	}

}

</pre>
<h3> 4.创建线程三种方式的对比</h3>
<ul>
	<li>继承局限： 采用Runnable， Callable接口的方式创建多线程时，可以避免单继承的局限，而Thread类则有此局限。</li>
	<li>资源共享： 采用Runnable, Callable接口的方式，可以共享同一个target对象，所以适合用来多个相同线程来处理同一个资源的情况。从而把CPU，代码和数据分开。较好地体现了面向对象的思想。</li>
</ul>
<blockquote>为什么能实现资源共享：
因为Runnable和Callable 接口实现的线程，最终都是通过Thread类来启动，相当于一个任务可以启动多个线程，用多个线程来同时处理这个任务。实际是开辟一个线程将任务传递进去，由此线程执行。可以实例化多个Thread对象 ，将同一个任务传递进去。这些线程执行的是同一个任务。所以他们的资源是共享的。
<pre class="java">public class RunnableDemo02  
{  
    public static void main(String args[]){  
        MyThread A = new MyThread("A");  //实例化线程要执行的任务  
        Thread Ta = new Thread(A);    //实例两个线程对象，实际传递的是一个任务  
        Thread Tb = new Thread(A);    //因为两个线程执行的是一个任务，所以资源是共享的  
        Ta.start();  
        Tb.start();  
    }  
}
</pre>
&nbsp;

而Thread类实现的线程，线程和线程要执行的任务是捆绑在一起的。也就使得一个任务只能启动一个线程，不同的线程执行的任务是不相同的，所以没有必要，也不能让两个线程共享此任务中的资源。</blockquote>
<ul>
	<li>使用Thread类的好处是：编写简单，如果需要访问当前的线程，则无需使用Thread.currentThread()方法，直接使用this即可获取到当前线程。</li>
	<li>Thread类实际上是Runnable的子类，而Thread类也要去接收Runnable其他子类的对象，而Runnable实现的子类都是编写具体的功能，并没有CPU调试，真正意义的CPU调试是由操作系统完成的，而Java的实现中就是通过Thread类的start()方法。在Thread的源码中有一个native 的方法 start0 (JNI实现)</li>
</ul>
<blockquote>    public synchronized void start() {

if (threadStatus != 0)

throw new<strong> IllegalThreadStateException();</strong>

group.add(this);

start0();

if (stopBeforeStart) {

stop0(throwableFromStop);

}

}

<strong>private native void start0();</strong></blockquote>
<ul>
	<li>从Thread类与Runnable接口的关系中可以发现，现在在线程中应用的设计思路就是代理设计模式。</li>
</ul>
<h3>5.线程的休眠</h3>
休眠就是减缓程序的运行速度。

sleep(long millis)

&nbsp;
<h3>6.线程同步与锁</h3>
当多个线程同时进行一种资源的操作时，为了保证操作的完整性，所以引入了同步处理。

使用Synchronized关键字来加入锁的标记，锁的标记中将判断和修改同时进行，要想完成锁的程序可以通过以下四种方式：
<ul>
	<li>sychronized method(){}</li>
	<li>sychronized (objectReference) {/*block*/}</li>
	<li>static synchronized method(){}</li>
	<li>sychronized(classname.class)</li>
</ul>
<strong>多个线程访问同一个资源的时候需要进行同步，但是过多的同步会产生死锁。</strong>

在Object类中提供了以下的方法可以实现对线程的等待及唤醒的处理：
<ul>
	<li>等待：public final void wait() throws InterruptedException</li>
	<li>唤醒：public final void notify()，唤醒第一个等待的线程</li>
	<li>唤醒：public final void notifyAll()，唤醒全部等待的线程</li>
</ul>
<h3>7.线程其他注意点</h3>
<ul>
	<li>Java本身属于多线程的处理机制，每次Java运行的时候，实际上都会启动一个JVM的进程</li>
	<li>主方法是在一个JVM上产生的一个线程而已，一个JVM启动的时候会产生两个线程：main,GC</li>
	<li>关于线程安全与不安全：线程安全的执行效率相对较低，但是安全，能保证数据的一致性以及操作的完整性。而线程非安全的执行效率肯定高，但是不安全。Java中提供了很多线程安全或者不安全的类，外部可以根据具体的需求来选择需要使用的类。比如在集合中，如果对于不需要同时处理某一资源的情况，可选择使用非线程安全的集合（ArrayList)来处理。</li>
	<li>线程的优先级：所有线程在启动之后并不是立刻运行的，都需要等待CPU进行调试。调试的时候会本身也存在优先级。优先级高的则有可能最先被执行。</li>
</ul>
<blockquote>setPriority(int new Priority) 可以设置优先级

最高：MAX_PRIORITY
中等：NORM_PRIORITY
低级：MIN_PRIORITY</blockquote>
<h2>二、线程池</h2>
<h3>1、简介</h3>
线程池主要还是在Java1.5之后加入了java.util.concurrent包才使用得比较多，在这之前使用是比较简陋的。
<h3>2、线程池的作用</h3>
线程池作用就是限制系统中执行线程的数量。

根据系统的环境情况，可以自动或手动设置线程数量，达到运行的最佳效果；少了浪费了系统资源，多了造成系统拥挤效率不高。用线程池控制线程数量，其他线程排队等候。一个任务执行完毕，再从队列的中取最前面的任务开始执行。若队列中没有等待进程，线程池的这一资源处于等待。当一个新任务需要运行时，如果线程池中有等待的工作线程，就可以开始运行了；否则进入等待队列。
<h3>3、为什么要使用线程池</h3>
<ul>
	<li>减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务</li>
	<li>可以根据系统的承受能力，调整线程池中工作线程的数目，防止因为消耗过多的内存，而把服务器累趴下<span lang="EN-US">(</span>每个线程需要大约<span lang="EN-US">1MB</span>内存，线程开的越多，消耗的内存也就越大，最后死机<span lang="EN-US">)</span>。</li>
</ul>
<h3>4、线程池的使用</h3>
Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。

比较重要的几个类：
<table style="height: 308px;" width="837">
<tbody>
<tr>
<td width="168">ExecutorService</td>
<td width="400">真正的线程池接口。</td>
</tr>
<tr>
<td width="168">ScheduledExecutorService</td>
<td width="400">能和Timer/TimerTask类似，解决那些需要任务重复执行的问题。</td>
</tr>
<tr>
<td width="168">ThreadPoolExecutor</td>
<td width="400">ExecutorService的默认实现。</td>
</tr>
<tr>
<td width="168">ScheduledThreadPoolExecutor</td>
<td width="400">继承ThreadPoolExecutor的ScheduledExecutorService接口实现，周期性任务调度的类实现。</td>
</tr>
</tbody>
</table>
要配置一个线程池是比较复杂的，尤其是对于线程池的原理不是很清楚的情况下，很有可能配置的线程池不是较优的，因此在Executors类里面提供了一些静态工厂，生成一些常用的线程池。
<ol>
	<li><strong> newSingleThreadExecutor</strong></li>
</ol>
创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。

2.<strong>newFixedThreadPool</strong>

创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。
<ol start="3">
	<li><strong> newCachedThreadPool</strong></li>
</ol>
创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

4.<strong>newScheduledThreadPool</strong>

创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。

<strong>实例</strong>

<strong>1：newSingleThreadExecutor</strong>

MyThread.java
<table>
<tbody>
<tr>
<td width="568"><strong>public</strong><strong>class</strong>MyThread <strong>extends</strong> Thread {

@Override

<strong>public</strong><strong>void</strong> run() {

System.<em>out</em>.println(Thread.<em>currentThread</em>().getName() + "正在执行。。。");

}

}</td>
</tr>
</tbody>
</table>
TestSingleThreadExecutor.java
<table>
<tbody>
<tr>
<td width="568"><strong>public</strong><strong>class</strong>TestSingleThreadExecutor {

<strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {

//创建一个可重用固定线程数的线程池

ExecutorService pool = Executors.<em> newSingleThreadExecutor</em>();

//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口

Thread t1 = <strong>new</strong> MyThread();

Thread t2 = <strong>new</strong> MyThread();

Thread t3 = <strong>new</strong> MyThread();

Thread t4 = <strong>new</strong> MyThread();

Thread t5 = <strong>new</strong> MyThread();

//将线程放入池中进行执行

pool.execute(t1);

pool.execute(t2);

pool.execute(t3);

pool.execute(t4);

pool.execute(t5);

//关闭线程池

pool.shutdown();

}

}</td>
</tr>
</tbody>
</table>
<strong>输出结果</strong>
<table>
<tbody>
<tr>
<td width="568">pool-1-thread-1正在执行。。。

pool-1-thread-1正在执行。。。

pool-1-thread-1正在执行。。。

pool-1-thread-1正在执行。。。

pool-1-thread-1正在执行。。。</td>
</tr>
</tbody>
</table>
<strong>2newFixedThreadPool</strong>

TestFixedThreadPool.Java
<table>
<tbody>
<tr>
<td width="568"><strong>public</strong><strong>class</strong> TestFixedThreadPool {

<strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {

//创建一个可重用固定线程数的线程池

ExecutorService pool = Executors.<em>newFixedThreadPool</em>(2);

//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口

Thread t1 = <strong>new</strong> MyThread();

Thread t2 = <strong>new</strong> MyThread();

Thread t3 = <strong>new</strong> MyThread();

Thread t4 = <strong>new</strong> MyThread();

Thread t5 = <strong>new</strong> MyThread();

//将线程放入池中进行执行

pool.execute(t1);

pool.execute(t2);

pool.execute(t3);

pool.execute(t4);

pool.execute(t5);

//关闭线程池

pool.shutdown();

}

}</td>
</tr>
</tbody>
</table>
<strong>输出结果</strong>
<table>
<tbody>
<tr>
<td width="568">pool-1-thread-1正在执行。。。

pool-1-thread-2正在执行。。。

pool-1-thread-1正在执行。。。

pool-1-thread-2正在执行。。。

pool-1-thread-1正在执行。。。</td>
</tr>
</tbody>
</table>
3<strong> newCachedThreadPool</strong>

TestCachedThreadPool.java
<table>
<tbody>
<tr>
<td width="568"><strong>public</strong><strong>class</strong> TestCachedThreadPool {

<strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {

//创建一个可重用固定线程数的线程池

ExecutorService pool = Executors.<em>newCachedThreadPool</em>();

//创建实现了Runnable接口对象，Thread对象当然也实现了Runnable接口

Thread t1 = <strong>new</strong> MyThread();

Thread t2 = <strong>new</strong> MyThread();

Thread t3 = <strong>new</strong> MyThread();

Thread t4 = <strong>new</strong> MyThread();

Thread t5 = <strong>new</strong> MyThread();

//将线程放入池中进行执行

pool.execute(t1);

pool.execute(t2);

pool.execute(t3);

pool.execute(t4);

pool.execute(t5);

//关闭线程池

pool.shutdown();

}

}</td>
</tr>
</tbody>
</table>
输出结果：
<table>
<tbody>
<tr>
<td width="568">pool-1-thread-2正在执行。。。

pool-1-thread-4正在执行。。。

pool-1-thread-3正在执行。。。

pool-1-thread-1正在执行。。。

pool-1-thread-5正在执行。。。</td>
</tr>
</tbody>
</table>
4<strong>newScheduledThreadPool</strong>

TestScheduledThreadPoolExecutor.java
<table>
<tbody>
<tr>
<td width="568"><strong>public</strong><strong>class</strong> TestScheduledThreadPoolExecutor {

<strong>public</strong><strong>static</strong><strong>void</strong> main(String[] args) {

ScheduledThreadPoolExecutor exec = <strong>new</strong> ScheduledThreadPoolExecutor(1);

exec.scheduleAtFixedRate(<strong>new</strong> Runnable() {//每隔一段时间就触发异常

@Override

<strong>public</strong><strong>void</strong> run() {

//throw new RuntimeException();

System.<em>out</em>.println("================");

}

}, 1000, 5000, TimeUnit.<em>MILLISECONDS</em>);

exec.scheduleAtFixedRate(<strong>new</strong> Runnable() {//每隔一段时间打印系统时间，证明两者是互不影响的

@Override

<strong>public</strong><strong>void</strong> run() {

System.<em>out</em>.println(System.<em>nanoTime</em>());

}

}, 1000, 2000, TimeUnit.<em>MILLISECONDS</em>);

}

}</td>
</tr>
</tbody>
</table>
输出结果
<table>
<tbody>
<tr>
<td width="568">================

8384644549516

8386643829034

8388643830710

================

8390643851383

8392643879319

8400643939383</td>
</tr>
</tbody>
</table>
&nbsp;
<h3>5、ThreadPoolExecutor类</h3>
ThreadPoolExecutor的完整构造方法的签名是：<strong>ThreadPoolExecutor</strong>(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) .

<strong>corePoolSize</strong> - 池中所保存的线程数，包括空闲线程。

<strong>maximumPoolSize</strong>-池中允许的最大线程数。

<strong>keepAliveTime</strong> - 当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。

<strong>unit</strong> - keepAliveTime 参数的时间单位。

<strong>workQueue</strong> - 执行前用于保持任务的队列。此队列仅保持由 execute方法提交的 Runnable任务。

<strong>threadFactory</strong> - 执行程序创建新线程时使用的工厂。

<strong>handler</strong> - 由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序。

<strong>ThreadPoolExecutor是Executors类的底层实现。</strong>

&nbsp;

详细参考资料：

http://www.cnblogs.com/dolphin0520/p/3932921.html

http://www.oschina.net/question/565065_86540]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>210</wp:post_id>
		<wp:post_date>2015-11-02 02:56:06</wp:post_date>
		<wp:post_date_gmt>2015-11-01 18:56:06</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>java-%e7%ba%bf%e7%a8%8b%e4%b8%8e%e7%ba%bf%e7%a8%8b%e6%b1%a0-%e6%80%bb%e7%bb%93</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="java"><![CDATA[JAVA]]></category>
		<category domain="post_tag" nicename="java-2"><![CDATA[java]]></category>
		<category domain="post_tag" nicename="%e5%a4%9a%e7%ba%bf%e7%a8%8b"><![CDATA[多线程]]></category>
		<wp:postmeta>
			<wp:meta_key>_oembed_a3613046e8a5b52256f1694cf57bc2fd</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
		<wp:postmeta>
			<wp:meta_key>_oembed_fedab564d393ca5e420b51dffe6a8d78</wp:meta_key>
			<wp:meta_value><![CDATA[{{unknown}}]]></wp:meta_value>
		</wp:postmeta>
	</item>
	<item>
				<title>Oracle 基本数据类型总结</title>
		<link>http://localhost:81/wordpress/?p=212</link>
		<pubDate>Mon, 02 Nov 2015 04:01:56 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=212</guid>
		<description></description>
		<content:encoded><![CDATA[1、字符类型
• CHAR：一个定长字符串，当位数不足自动用空格填充来达到其最大长度。如非NULL的CHAR(12)总是包含12字节信息。CHAR字段最多可以存储2,000字节的
信息。
• VARCHAR2：目前这也是VARCHAR 的同义词。这是一个变长字符串，与CHAR 类型不同，它不会用空格填充至最大长度。VARCHAR2(12)可能包含0～

12字节的信息。VARCHAR2最多可以存储4,000 字节的信息。

CHAR和VARCHAR2的比较
CHAR(4) “A“ 实际在数据库中存储为"A “
“ABCDE”超长报错
VARCHAR2(4) “A” 存储的还是“A”
“ABCDE”超长报错
汉字：每个汉字占多少字节，要看具体的编码方式，如UTF-8（1-3字节）、
GB2312（2字节）、GBK（2字节）、GB18030（1、2、4字节）

2、数字类型

• NUMBER：该数据类型能存储精度最多达38位的数字。每个数存储在一个变长字段中，其长度在0～22字节之间。Oracle的NUMBER类型精度很高， 远远高于许多编程语言中常规的FLOAT和DOUBLE类型。

NUMBER( p,s ) p表示精度（总长度） s表示小数位置且四舍五入

NUMBER(10,3) 10是总长度，3是小数位数的长度
123.456
123.4567 ：将存储为123.457
12345679.899 ：精度超长了，10是总长度，3是小数位， 整数位为10-3=7位
NUMBER(10)==NUMBER(10,0) java.lang.Integer
NUMBER(19)==NUMBER(19,0) java.lang.Long

3、日期类型

• DATE：一个7字节的定宽日期/时间数据类型。其中总包含7个属性，包括：世纪、世纪中哪一年、月份、月中的哪一天、小时、分钟和秒。

• TIMESTAMP：一个7 字节或12.字节的定宽日期/时间数据类型。它与DATE 数据类型不同，因为TIMESTAMP 可以包含小数秒（fractional second）；带小数秒的TIMESTAMP 在小数点右边最多可以保留9位。

4、二进制及大文本数据

• BLOB： (binary large object)在Oracle9i及以前的版本中， 这种数据类型允许存储最多4GB的数据， 在Oracle 10g及以后的版本中允许存储最多（4GB）×（数据库块大小）字节的数据。BLOB包含不需要进行字符集转换的“二进制“数据，如果要存储电子表格、字处理文档、图像文件等就很适合采用

• CLOB：（Character Large Object）在Oracle9i及以前的版本中， 这种数据类型允许存储最多4GB的数据， 在Oracle 10g及以后的版本中允许存储最多（4GB）×（数据库块大小）字节的数据。CLOB包含要进行字符集转换的信息。这种数据类型很适合存储纯文本信息。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>212</wp:post_id>
		<wp:post_date>2015-11-02 12:01:56</wp:post_date>
		<wp:post_date_gmt>2015-11-02 04:01:56</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>oracle-%e5%9f%ba%e6%9c%ac%e6%95%b0%e6%8d%ae%e7%b1%bb%e5%9e%8b%e6%80%bb%e7%bb%93</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="oracle"><![CDATA[Oracle]]></category>
		<category domain="category" nicename="oracle-db"><![CDATA[Oracle DB]]></category>
	</item>
	<item>
				<title>从战后德国和日本及中国的发展史想到的。。</title>
		<link>http://localhost:81/wordpress/?p=214</link>
		<pubDate>Fri, 27 Nov 2015 06:23:05 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=214</guid>
		<description></description>
		<content:encoded><![CDATA[<blockquote>为什么一穷二白的德国和日本在二战后的一穷二白中能够快速崛起？

战后的日本和德国基本被炸成一片废墟，还要负担巨额赔款，然而现在他们是发达国家，而中国作为战胜国却依然是发展中国家。</blockquote>
这里其实可以作为简单的比喻：1997年史玉柱因巨人大厦项目失败而身负巨债，净资产为负数。
同一时期，新疆库尔勒牧民买买提老汉有500只羊，无外债。

因此，2015年史玉柱比买买提老汉还要富有，这是不合理的，对吧！？

这其实就是一个简单的道理：对于人来说，即使暂时的负资产，但是商业头脑、经营能力、社交范围、潜在资源，都量一个普通人所不能比的，所以，史玉柱能东山再起，但新疆的买买提同志却可能放一辈子的羊。

同样，对于德国和日本两个国家，他们虽然战败，就算不考虑其战后的物质资源仍然高于中国的事实，就算他们真的是一穷二白，至少他们人还在，他们有工业的底子，他们在1920年代有代造航母的经验，他们有科研和教育的基础，这一切，都是中国这个当时识字率不足25%，连火柴、煤油、水泥等都要靠进口的农业国家所不能比的。所以，从概率学上来说，德日的崛起是大概率事件，而中国虽然有各种各样的问题，但是能够成为世界工厂，包括现在借助互联网诞生了很多能影响世界的企业，某种程度来说，已经是一个很大的进步，远远谈不上完美，但是进步是不能被否认的。]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>214</wp:post_id>
		<wp:post_date>2015-11-27 14:23:05</wp:post_date>
		<wp:post_date_gmt>2015-11-27 06:23:05</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>%e4%bb%8e%e6%88%98%e5%90%8e%e5%be%b7%e5%9b%bd%e5%92%8c%e6%97%a5%e6%9c%ac%e5%8f%8a%e4%b8%ad%e5%9b%bd%e7%9a%84%e5%8f%91%e5%b1%95%e5%8f%b2%e6%83%b3%e5%88%b0%e7%9a%84%e3%80%82%e3%80%82</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="category" nicename="%e5%90%b9%e6%b0%b4%e4%b8%80%e5%88%bb"><![CDATA[吹水一刻]]></category>
		<category domain="post_tag" nicename="%e6%80%9d%e8%80%83"><![CDATA[思考]]></category>
	</item>
	<item>
				<title>AMF协议简介</title>
		<link>http://localhost:81/wordpress/?p=217</link>
		<pubDate>Thu, 07 Jan 2016 02:59:45 +0000</pubDate>
		<dc:creator><![CDATA[xuxji]]></dc:creator>
		<guid isPermaLink="false">http://bugalot.com/?p=217</guid>
		<description></description>
		<content:encoded><![CDATA[AMF协议是Action Message Format协议的简称，AMF协议是Adobe公司的协议，主要用于数据交互和远程过程调用，在功能上与WebService相当，但AMF与WebService中的xml不同在于AMF是二进制数据，而xml是文本数据，AMF的传输效率比xml高。AMF使用http方式传输，目前主要用于ActionScript中，实现Flex与Service之间的通信。目前最新的版本是AMF3。附件是<a href="http://dl.iteye.com/topics/download/e6013472-9d41-38b8-aa34-c3fbe0459e1e">AMF3的官方文档</a>。

AMF最大的特色在于可直接将Flash内置对象，例如Object, Array, Date, XML，传回服务器端，并且在服务器端自动进行解析成适当的对象，这就减轻了开发人员繁复工作，同时也更省了开发时间。由于AMF采用二进制编码，这种方式可以高度压缩数据(<a href="http://www.51edu.com/it/flash/zhizuojc/1415560.html">对flash中的AMF3的误解</a>)，因此非常适合用来传递大量的资料。数据量越大，Flash Remoting的传输效能就越高，远远超过Web Service。至于XML, 它们使用纯文本的传输方式，效能就更不能与Flash Remoting相提并论了。除了AMF编码进行高效数据操作的功能之外，ByteArray还有一个很酷的功能，就是从内存中深层次的Copy(Clone)整个对象，请参考<a href="http://www.7yue.com/post/33.html">使用ByteArray及AMF来提高Data Object的操作效率</a>。

AMF协议是基于Http协议的.它的内容处理过程大致是这样:
1.从客户端获取Http请求(Request)流.
2.对流进行解串行化(Deserialize)，得到服务器端程序能够识别的数据，并建立一个响应(Response)消息。
3. 对流进行各种处理(记录、许可、服务)得到返回值。
4.对响应流进行串行化。
6.发送Http响应给客户端。

&nbsp;

下面看看java类型与As3类型之间的对应关系。

&nbsp;

<img src="http://dl.iteye.com/upload/attachment/247439/74fb3db3-9e97-3285-9301-1971bb1885e4.jpg" alt="" width="600" height="680" />

&nbsp;

说个题外话，从oracle数据库中读取数据，如果是大整数则转化为BigDecimal，BigDecimal在Flex端会转化为String类型，DataGrid中的列排序只有两种排序类型Number和String，因此就会出现数字排序不正确的情况。解决此问题，请继续关注我的博客。

&nbsp;

AS3对象与java对象的对应图。

<img src="http://dl.iteye.com/upload/attachment/247440/e996ae50-da21-30ef-8e2d-b417e3a046c8.jpg" alt="" width="600" height="795" />]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>217</wp:post_id>
		<wp:post_date>2016-01-07 10:59:45</wp:post_date>
		<wp:post_date_gmt>2016-01-07 02:59:45</wp:post_date_gmt>
		<wp:comment_status>open</wp:comment_status>
		<wp:ping_status>open</wp:ping_status>
		<wp:post_name>amf%e5%8d%8f%e8%ae%ae%e7%ae%80%e4%bb%8b</wp:post_name>
		<wp:status>publish</wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type>post</wp:post_type>
		<wp:post_password></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
		<category domain="post_tag" nicename="amf"><![CDATA[AMF]]></category>
		<category domain="post_tag" nicename="flex"><![CDATA[FLEX]]></category>
		<category domain="post_tag" nicename="%e5%8d%8f%e8%ae%ae"><![CDATA[协议]]></category>
		<category domain="category" nicename="uncategorized"><![CDATA[未分类]]></category>
	</item>
</channel>
</rss>
